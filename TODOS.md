# TODO

* TTT lecture material doesn't show `move`, but that's assumed for the first lab. In 2025, I covered it instead of `example` so they'd have it. 

* Various TODO notes in chapters


<!-- find . -name '*.frg' -print0 | xargs -0 sed -i "" "s/is theorem/is checked/g" -- >


<!-- # What do tic-tac-toe, binary trees, and operating systems have in common? -->
<!-- STATIC INSTANCES; NO TRANSITIONS YET -->


<!-- ## Atoms from bits (Relational Forge)
 
  - Relations in Forge (cities, objects/heap, course requirements, ACL synthesis)
	- Lab follow-up: reference-counting GC

  - Relational: Boolean logic (modeled)

  - Relational: Prim’s algorithm (modeled, validation)
  - Prim's vs. Dijkstra's (both so alike, but so different)

  - Validation (part 2)
     - domain vs. system, “optional” predicates, combinations and consistency

  - Correspondence between models, abstraction functions
  - Tying it all together: how does Forge work?
 -->



<!-- - The challenge of testing
  - Python: tic-tac-toe. Let's test our TTT program.
    - What does it mean to test such a program?
    - Fuzzing (doesn't crash mid-game)
    - Is there only one "best" move? No. Relational problems.
    - Property-based testing (generator vs. is-valid) 
    
    
    - Satisfiability and unsatisfiability
    - => as "if"; classical logic weirdness when it comes up first
    - methodology, shapes
    -->

<!--
- From tests to specification   [ended up doing this in reverse]
    - our is-valid looks really similar to Froglet predicate
    - our generator looks really similar to a different Froglet predicate
    - algorithms differ, specification is forever (random search vs bounded-exhaustive search vs proof vs…) -->

