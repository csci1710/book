<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Logic for Systems: Lightweight Formal Methods for Everybody</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="././mdbook-admonish.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="welcome.html">How to Read this book</a></li><li class="chapter-item affix "><li class="part-title">Preamble: Beyond Testing</li><li class="chapter-item "><a href="chapters/manifesto/job.html">What good is this book?</a></li><li class="chapter-item "><a href="chapters/manifesto/manifesto.html">Logic for Systems</a></li><li class="chapter-item "><a href="chapters/properties/pbt.html">From Tests to Properties</a></li><li class="chapter-item affix "><li class="part-title">Modeling Static Scenarios</li><li class="chapter-item "><a href="chapters/ttt/ttt.html">Tic-Tac-Toe</a></li><li class="chapter-item "><a href="chapters/bst/bst.html">Binary Search Trees</a></li><li class="chapter-item "><a href="chapters/adder/rca.html">Ripple-Carry Adder</a></li><li class="chapter-item "><a href="chapters/qna/static.html">Q&A: Static Modeling</a></li><li class="chapter-item affix "><li class="part-title">Discrete Event Systems</li><li class="chapter-item "><a href="chapters/ttt/ttt_games.html">Transitions, Traces, and Verification</a></li><li class="chapter-item "><a href="chapters/inductive/bsearch.html">Counterexamples to Induction</a></li><li class="chapter-item "><a href="chapters/bst/descent.html">BSTs: Recursive Descent</a></li><li class="chapter-item "><a href="chapters/validation/validating_events.html">Validating Models</a></li><li class="chapter-item "><a href="chapters/qna/events.html">Q&A: Event Systems</a></li><li class="chapter-item affix "><li class="part-title">Modeling Relationships</li><li class="chapter-item "><a href="chapters/relations/modeling-booleans-1.html">Relational Forge, Modeling Logic</a></li><li class="chapter-item "><a href="chapters/relations/reachability.html">Transitive Closure</a></li><li class="chapter-item "><a href="chapters/relations/sets-induction-mutex.html">Modeling Mutual Exclusion</a></li><li class="chapter-item "><a href="chapters/relations/sets-beyond-assertions.html">Going Beyond Assertions</a></li><li class="chapter-item "><a href="chapters/solvers/bounds_booleans_how_forge_works.html">How does Forge Work?</a></li><li class="chapter-item "><a href="chapters/qna/relations.html">Q&A: Relations</a></li><li class="chapter-item affix "><li class="part-title">Temporal Specification</li><li class="chapter-item "><a href="chapters/temporal/liveness_and_lassos.html">Liveness and Lassos</a></li><li class="chapter-item "><a href="chapters/temporal/temporal_operators.html">Temporal Forge</a></li><li class="chapter-item "><a href="chapters/temporal/temporal_operators_2.html">Linear Temporal Logic</a></li><li class="chapter-item "><a href="chapters/temporal/obligations_past.html">Obligations and the Past</a></li><li class="chapter-item "><a href="chapters/temporal/fixing_lock_temporal.html">Mutual Exclusion, Revisited</a></li><li class="chapter-item "><a href="chapters/temporal/testing_temporal.html">Testing Temporally</a></li><li class="chapter-item affix "><li class="part-title">Boolean Solver Algorithms</li><li class="chapter-item "><a href="chapters/solvers/dpll.html">Boolean SAT (DPLL)</a></li><li class="chapter-item "><a href="chapters/solvers/resolution.html">Witnessing Unsat: Propositional resolution</a></li><li class="chapter-item affix "><li class="part-title">Beyond SAT</li><li class="chapter-item "><a href="chapters/solvers/smt.html">Satisfiability Modulo Theories (SMT)</a></li><li class="chapter-item "><a href="chapters/solvers/cegis.html">Learning with Solvers: CEGIS</a></li><li class="chapter-item affix "><li class="part-title">Case Studies and Further Reading</li><li class="chapter-item "><div>Modeling Raft in Anger</div></li><li class="chapter-item "><div>Forge: Comparing Prim's and Dijkstra's Algorithms</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Logic for Systems: Lightweight Formal Methods for Everybody</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How To Read This Book</a></h2>
<p>Welcome to Logic for Systems! Here are some quick hints that will help you use this book effectively.</p>
<div id="admonition-this-book-is-a-draft" class="admonition admonish-note">
<div class="admonition-title">
<p>This book is a draft!</p>
<p><a class="admonition-anchor-link" href="welcome.html#admonition-this-book-is-a-draft"></a></p>
</div>
<div>
<p>This book is a draft, and there are some sections that are currently being filled in. If you want to use these materials and need support (e.g., you want to use the Forge homeworks that go with it, or a specific section you need is incomplete), please contact <code>Tim_Nelson@brown.edu</code>. </p>
<p>Especially during the Spring semester at Brown University, the deployed content of this book may be expanded and improved. </p>
<ul>
<li>If you are a Brown University student taking CSCI 1710, expect the book to be edited as the semester proceeds.</li>
<li>If you are using the book in your own course or for your own studies, and want a &quot;frozen&quot; version to ensure consistency, we'd be happy to assist you. Please reach out to <code>Tim_Nelson@brown.edu</code>.</li>
</ul>
</div>
</div>
<hr />
<h3 id="organization"><a class="header" href="#organization">Organization</a></h3>
<p>The book is organized into a series of short sections, each of which are grouped into chapters: </p>
<ul>
<li><strong>Chapter 1 (Beyond Testing)</strong> briefly motivates the content in this book and sets the stage with a new technique for testing your software. </li>
<li><strong>Chapter 2 (Modeling Static Scenarios)</strong> provides an introduction to modeling systems in Forge by focusing on systems that don't change over time. </li>
<li><strong>Chapter 3 (Discrete Event Systems)</strong> shows a common way to model the state of a system changing over time. </li>
<li><strong>Chapter 4 (Modeling Relationships)</strong> enriches the modeling language to support arbitrary relations between objects in the world.</li>
<li><strong>Chapter 5 (Temporal Specification)</strong> covers temporal operators, which are commonly used in industrial modeling and specification, and how to use them. </li>
<li><strong>Chapter 6 (Case Studies)</strong> touches on some larger applications of lightweight formal methods. Some of these will involve large models written in Forge, and others will lean more heavily on industrial systems.</li>
<li>The <strong>Forge Documentation</strong>, which covers the syntax of the language more concisely and isn't focused on teaching. At the moment, this is in a <a href="https://csci1710.github.io/forge-documentation/">separate document</a> in order to make searching easier.</li>
</ul>
<p>Each chapter contains a variety of examples: data structures, puzzles, algorithms, hardware concepts, etc. We hope that the diversity of domains covered means that everyone will see an example that resonates with them. Full language and tool documentation come <em>after</em> the main body of the book. </p>
<h4 id="what-does-this-book-assume-what-is-its-goal"><a class="header" href="#what-does-this-book-assume-what-is-its-goal">What does this book assume? What is its goal?</a></h4>
<p>This book does not assume <em>any</em> prior background with formal methods or even discrete math. It does assume the reader has written programs before at the level of an introductory college course. </p>
<p>The goal of this chapter progression is to prepare the reader to formally model and reason about a domain <em>of their own choosing</em> in Forge (or perhaps in a related tool, such as an SMT solver). </p>
<p>With that in mind...</p>
<h4 id="do-more-than-read"><a class="header" href="#do-more-than-read">Do More Than Read</a></h4>
<p>This book is example driven, and the examples are almost always built up from the beginning. The flow of the examples is deliberate, and might even take a &quot;wrong turn&quot; that is meant to teach a specific lesson before changing direction. If you try to read the book passively, you're likely to be very disappointed. Worse, you may not actually be able to <em>do</em> much with the material after reading.</p>
<p>Instead, <strong>follow along</strong>, pasting each snippet of code or Forge model into the appropriate tool, and try it! Better yet, try modifying it and see what happens. You'll get much more out of each section as a result. Forge especially is designed to aid experimentation. Let your motto be:</p>
<center><strong>Let's find out!</strong></center>
<br/>
<hr />
<h3 id="navigating-the-book-site"><a class="header" href="#navigating-the-book-site">Navigating the Book Site</a></h3>
<p>With JavaScript enabled, the table of contents (to the left, by default) will allow you to select a specific section of this book. Likewise, the search bar (enabled via the &quot;Toggle Searchbar&quot; icon) should allow you to search for arbitrary alphanumeric phrases in the full text; unfortunately, non alphanumeric operators are not supported by search at present.</p>
<div id="admonition-table-of-contents-theme-and-search" class="admonition admonish-tip">
<div class="admonition-title">
<p>Table of Contents, Theme, and Search</p>
<p><a class="admonition-anchor-link" href="welcome.html#admonition-table-of-contents-theme-and-search"></a></p>
</div>
<div>
<p>The three buttons for popping out the table of contents, changing the color theme, and searching are in the upper-left corner of this page, by default. If you do not see them, please ensure that JavaScript is enabled.</p>
<center>
If the table of contents isn't open, click this button:
<label id="sidebar-toggle-alternate" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents (Alternate Button)" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
<p>The table of contents for the Forge documentation is expandable. Once it is open, click the ❱ icons to expand individual sections and subsections to browse more easily! </p>
<p>To change the color theme of the page, click this button:
<button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme (Alternate Button)" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
<i class="fa fa-paint-brush"></i>
</button></p>
<p>To search, click this button:
<button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar (Alternate Button)" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
<i class="fa fa-search"></i>
</button></p>
</center>
</div>
</div>
<hr />
<h3 id="callout-boxes"><a class="header" href="#callout-boxes">Callout Boxes</a></h3>
<p>Callout boxes can give valuable warnings, helpful hints, and other supplemental information. They are color- and symbol-coded depending on the type of information. For example:</p>
<div id="admonition-this-is-a-helpful-tip" class="admonition admonish-tip">
<div class="admonition-title">
<p>This is a helpful tip.</p>
<p><a class="admonition-anchor-link" href="welcome.html#admonition-this-is-a-helpful-tip"></a></p>
</div>
<div>
<p>Make sure to stay hydrated; it will help you learn.</p>
</div>
</div>
<div id="admonition-this-is-a-warning" class="admonition admonish-warning">
<div class="admonition-title">
<p>This is a warning!</p>
<p><a class="admonition-anchor-link" href="welcome.html#admonition-this-is-a-warning"></a></p>
</div>
<div>
<p>Look both ways before you cross the street!</p>
</div>
</div>
<div id="admonition-this-is-a-side-note" class="admonition admonish-note">
<div class="admonition-title">
<p>This is a side note.</p>
<p><a class="admonition-anchor-link" href="welcome.html#admonition-this-is-a-side-note"></a></p>
</div>
<div>
<p>This book is written using the <code>mdbook</code> package.</p>
</div>
</div>
<p>If you see a callout labeled &quot;CSCI 1710&quot;, it means that it's specifically for students in Brown University's CSCI 1710 course, Logic for Systems.</p>
<hr />
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<p>Every now and then, you'll find question prompts, followed by a clickable header that looks like this: </p>
<details>
<summary>Think, then click!</summary>
<p><strong>SPOILER TEXT</strong></p>
</details> 
<p>If you click the arrow, it will expand to show hidden text, often revealing an answer or some other piece of information that is meant to be read <em>after</em> you've thought about the question. When you see these exercises, <strong>don't skip past them</strong>, and <strong>don't just read the hidden text</strong>. </p>
<h2 id="thanks-to"><a class="header" href="#thanks-to">Thanks To</a></h2>
<p>The current draft has benefitted from the feedback of many people, including: 
Shriram Krishnamurthi, 
Emily Nelson, 
Hillel Wayne, 
...</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="our-value-proposition"><a class="header" href="#our-value-proposition">Our Value Proposition</a></h2>
<p>Everybody has endless demands on their time. If you're a student, you might be deciding which classes to take. There's never enough time to take them all, so you need to prioritize based on expected value. If you're a professional, you're deciding how to best use your limited &quot;free&quot; time to learn new skills and stay current. Either way, you're probably wondering: <strong>What good is this book?</strong> (And if you aren't asking that, you ought to be.)</p>
<p>You need many different skills for a successful career. This book won't teach you how to work with other people, or manage your tasks, or give and receive feedback. It won't teach you to program either; there are plenty of other books for that. Instead, this book will teach you:</p>
<ul>
<li>how to think more richly about what matters about a system; </li>
<li>how to better express what you want from it;</li>
<li>how to more thoroughly evaluate what a system actually does give you; and</li>
<li>how to use constraints and constraint solvers in your work (because we'll use them as tools to help us out).
It will also give you a set of baseline skills that will aid you in using any further formal-methods techniques you might encounter in your work, such as <a href="https://rust-book.cs.brown.edu">advanced type systems</a>, <a href="https://dafny.org">program verification</a>, <a href="https://lean-lang.org">theorem proving</a>, and more. </li>
</ul>
<h3 id="modeling-what-really-matters"><a class="header" href="#modeling-what-really-matters">Modeling: What really matters?</a></h3>
<p>There's a useful maxim by George Box: <strong>&quot;All models are wrong, but some are useful&quot;</strong>. The only completely accurate model of a system is that system itself, including all of its real external context. This is impractical; instead, a modeler needs to make choices about what really matters to them: what do you keep, and what do you disregard? Done well, a model gets at the essence of a system. Done poorly, a model yields nothing useful or, worse, gives a false sense of security. </p>
<div id="admonition-george-box-1978" class="admonition admonish-note">
<div class="admonition-title">
<p>George Box (1978)</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/job.html#admonition-george-box-1978"></a></p>
</div>
<div>
<p>I suspect that people were saying &quot;All models are wrong&quot; long before Box did! But it's worth reading <a href="https://doi.org/10.1016%2FB978-0-12-438150-6.50018-2">this quote of his from 1978</a>, and thinking about the implications.</p>
<blockquote>
<p>Now it would be very remarkable if any system existing in the real world could be exactly represented by any simple model. However, cunningly chosen parsimonious models often do provide remarkably useful approximations. For example, the law <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span></span></span></span> relating pressure <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, volume <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and temperature <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> of an &quot;ideal&quot; gas via a constant <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is not exactly true for any real gas, but it frequently provides a useful approximation and furthermore its structure is informative since it springs from a physical view of the behavior of gas molecules. For such a model there is no need to ask the question &quot;Is the model true?&quot;. If &quot;truth&quot; is to be the &quot;whole truth&quot; the answer must be &quot;No&quot;. <strong>The only question of interest is &quot;Is the model illuminating and useful?&quot;.</strong> </p>
</blockquote>
<p>(Bolding mine. The text is taken from pages 2 through 3 of the original paper.)</p>
</div>
</div>
<!-- https://archive.org/details/DTIC_ADA070213/page/n7/mode/2up -->
<p>If you want to do software (or hardware) engineering, some amount of modeling is unavoidable. Here are two basic examples of many.</p>
<h4 id="data-models-everywhere"><a class="header" href="#data-models-everywhere">Data Models Everywhere</a></h4>
<p>You might already have benefitted from a good model (or suffered from a poor one) in your programming work. Whenever you write data definitions or class declarations in a program, <a href="https://en.wikipedia.org/wiki/Data_model">you're modeling</a>. The ground truth of the data is rarely identical to its representation. You decide on a particular way that it should be stored, transformed, and accessed. You say how one piece of data relates to another. </p>
<p>Your data-modeling choices affect more than just execution speed: if a pizza order can't have a delivery address that is separate from the user's billing address, important user needs will be neglected. On the other hand, it is probably OK to leave the choice of cardboard box out of the user-facing order. An order has a delivery time, which probably comes with a time zone. You could model the time zone as an integer offset from UTC, but this is a <a href="https://en.wikipedia.org/wiki/Time_zone">very bad idea</a>. And, since there are 24 hours in a day, the real world imposes range limits: a timezone that's a million hours ahead of UTC is probably a buggy value, even though the value <code>1000000</code> is much smaller than even a signed 32-bit <code>int</code> can represent. </p>
<h4 id="data-vs-its-representation"><a class="header" href="#data-vs-its-representation">Data vs. Its Representation</a></h4>
<p>The <em>level</em> of abstraction matters, too. Suppose that your app scans handwritten orders. Then handwriting becomes pixels, which are converted into an instance of your data model, which is implemented as bytes, which are stored in hardware flip-flops and so on. You probably don't need, or want, to keep all those perspectives in mind simultaneously. Languages are valuable in part because of the abstractions they foster, even if those abstractions are incomplete—they can be usefully incomplete! What matters is whether the abstraction level suits your needs, and your users'.</p>
<div id="admonition-memory-management" class="admonition admonish-tip">
<div class="admonition-title">
<p>Memory Management</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/job.html#admonition-memory-management"></a></p>
</div>
<div>
<p>I learned to program in the 1990s, when practitioners were at odds over automated vs. manual memory management. It was often claimed that a programmer needed to <em>really understand</em> what was happening at the hardware level, and manually control memory allocation and deallocation for the sake of performance. Most of us don't think that anymore, <em>unless we need to</em>! Sometimes we do; often we don't. Focus your attention on what matters for the task at hand.</p>
</div>
</div>
<p>The examples don't stop: In security, a <em>threat model</em> says what powers an attacker has. In robotics and AI, reinforcement learning works over a probabilistic model of real space. And so on. The key is: <strong>what matters for your needs?</strong> Box had something to say about that, too (<a href="http://www-sop.inria.fr/members/Ian.Jermyn/philosophy/writings/Boxonmaths.pdf">in 1976</a>):</p>
<blockquote>
<p>Since all models are wrong the scientist must be alert to what is importantly wrong. It is inappropriate to be concerned about safety from mice when there are tigers abroad.</p>
</blockquote>
<h3 id="specification-what-do-you-want"><a class="header" href="#specification-what-do-you-want">Specification: What do you want?</a></h3>
<p>Suppose that I want to store date-and-time values in a computer program. That's easy enough to say, right? But the devil is in the details: What is the layout of the data? Which fields will be stored, and which will be omitted? Which values are valid, and which are out of bounds? Is the format efficiently serializable? How far backward in time should the format extend, and <a href="https://en.wikipedia.org/wiki/Year_2000_problem">how far into the future should it reach</a>?</p>
<p>And which calendar are we using, anyway? </p>
<div id="admonition-yes-thats-a-real-question" class="admonition admonish-note">
<div class="admonition-title">
<p>Yes, that's a real question.</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/job.html#admonition-yes-thats-a-real-question"></a></p>
</div>
<div>
<p>If our programs are meant to work with dates prior to the 1600's, only their historical context can say whether they should be interpreted with the <a href="https://en.wikipedia.org/wiki/Gregorian_calendar">Gregorian calendar</a> or the <a href="https://en.wikipedia.org/wiki/Julian_calendar">Julian calendar</a>. And that's just two (Eurocentric) possibilities!</p>
</div>
</div>
<p>If you're just building a food delivery app, you probably only need to think about some of these aspects of dates and times. If you're defining <a href="https://en.wikipedia.org/wiki/ISO_8601">an international standard</a>, you need to think about them all.</p>
<p>Either way, being able to think carefully about your specification can separate quiet success from famous failure.</p>
<h3 id="validation-and-verification-did-you-get-what-you-wanted"><a class="header" href="#validation-and-verification-did-you-get-what-you-wanted">Validation and Verification: Did you get what you wanted?</a></h3>
<p>Whether you're working out an algorithm on paper or checking a finished implementation, you need some means of judging correctness. Here, too, precision (and a little bit of adversarial thinking) matters in industry:</p>
<ul>
<li>When ordinary testing isn't good enough, techniques like fuzzing, <a href="chapters/manifesto/../properties/pbt.html">property-based testing</a>, and others give you new evaluative power. </li>
<li>When you're updating, refactoring, or optimizing a system, a model of its ideal behavior can be leveraged for validation. <a href="https://news.ycombinator.com/item?id=34726919">Here's an example from 2014</a>—click through the header of the linked article to read the original blog post.)</li>
<li>A model of the system's behavior is also useful for test-case generation, and <a href="https://hypothesis.readthedocs.io/en/latest/stateful.html">enable tools to generate test suites</a> that have a higher coverage of the potential state space. </li>
</ul>
<p>And all that's even before we consider more heavyweight methods, like model checking and program verification.</p>
<h3 id="formalism-isnt-absolute"><a class="header" href="#formalism-isnt-absolute">Formalism Isn't Absolute</a></h3>
<p>The word &quot;formal&quot; has accumulated some unfortunate connotations: pedantry, stuffiness, ivory-tower snootiness, being an <a href="https://en.wikipedia.org/wiki/Architecture_astronaut">architecture astronaut</a>, etc. The truth is that formalism is a sliding scale. <em>We can take what we need and leave the rest.</em> What really matters is the ability to precisely express your goals, and the ability to take advantage of that precision. </p>
<p>In fact, formalism powers many <em>software tools</em> that help us to reason about the systems we create. In the next section, we'll start sketching what that means for us as engineers and humans.</p>
<!-- You might not be used to thinking of programming as a "formal" activity, but it is. A programming language is a formal artifact: it has a precise meaning, usually defined in a detailed specification that few people need to read fully. Some factors are often left unspecified, and thus "implementation dependent", which is one reason why the difference between specification and implementation is more fluid than you might think.  -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="logic-for-systems"><a class="header" href="#logic-for-systems">Logic for Systems</a></h1>
<h2 id="setting-the-stage"><a class="header" href="#setting-the-stage">Setting the Stage</a></h2>
<p>If you're reading this book, you've probably had to complete some programming assignments—or at least written some small program for a course or an online tutorial. Take a moment to list a handful of such assignments: what did you have to build? </p>
<p>Now ask yourself:</p>
<ul>
<li>How did you know what behavior to implement?</li>
<li>How did you know which data structures or algorithms were the right ones to use?</li>
<li>How did you know your program &quot;worked&quot;, in the end?</li>
</ul>
<p>In the context of assignments, there are expected answers to these questions. For instance, you might say you know your code worked because you tested it (<em>very</em> thoroughly, I'm sure)! But is that really the truth? In terms of consequences, the true bar for excellence in a programming class is the grade you got. That is:</p>
<ul>
<li>You knew what to do because <em>you were told what to do</em>.</li>
<li>You probably knew which algorithms to use because they'd <em>just been taught to you</em>.</li>
<li>You were confident that your programs worked because <em>you were told by an authority figure</em>.</li>
</ul>
<p>But outside that context, as (say) a professional engineer, you lose the safety net. You might be working on a program that controls the fate of billions of dollars, tempers geopolitical strife, or controls a patient's insulin pump. Even if you had a TA, would you trust them to tell you that those programs worked? Would you trust your boss to understand <em>exactly</em> what needed to happen, and tell you <em>exactly</em> how to do it? Probably not! Instead, you need to think carefully about what you want, how to build it, and how to evaluate what you and others have built. </p>
<div id="admonition-dont-let-the-perfect-be-the-enemy-of-the-good" class="admonition admonish-warning">
<div class="admonition-title">
<p>Don't let the perfect be the enemy of the good.</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/manifesto.html#admonition-dont-let-the-perfect-be-the-enemy-of-the-good"></a></p>
</div>
<div>
<p>As engineers, we strive for perfection. But perfection is an ideal; it's not obtainable. Why? First: we're human. Even if we could read our customers' minds, that's no guarantee that <em>they</em> know what they really need. And even if we can prove our code is correct, we might be checking for the wrong things. Second: our environment is hostile. Computers break. Patches to dependencies introduce errors. Cosmic radiation can flip bits in memory. 100% reliability is hopeless. Anyone who tells you differently is trying to sell you something. </p>
<p>But that doesn't mean we should give up. It just means that we should moderate our expectations. Instead of focusing on perfect correctness, instead try to <em>increase your confidence</em> in correctness.</p>
</div>
</div>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<p>Hopefully we all agree that unit testing with concrete input-output pairs has its virtues and that we should keep doing it. But let's investigate what it does and doesn't do well. </p>
<p><strong>Exercise:</strong> Make two lists: What does unit testing do well? What doesn't it do well? (Hint: Why do we test? What could go wrong, and how can the sort of testing you've done in other classes let us down?)</p>
<details>
<summary>Think, then click!</summary>
<p>You might have observed that (for most interesting programs, anyway) tests cannot be exhaustive because there are infinitely many possible inputs. And since we're forced to test non-exhaustively, we have to hope we pick good tests---tests that not only focus on our own implementation, but on others (like the implementation that replaces yours eventually) too.</p>
<p>Worse, we can't test the things we don't think of, or don't know about; we're vulnerable to our limited knowledge, the availability heuristic, confirmation bias, and so on. In fact, we humans are generally ill equipped for logical reasoning, even if trained. </p>
</details> 
<h2 id="humans-and-reasoning"><a class="header" href="#humans-and-reasoning">Humans and Reasoning</a></h2>
<h3 id="a-toy-example"><a class="header" href="#a-toy-example">A Toy Example</a></h3>
<p>Suppose we're thinking about the workings of a small company. We're given some facts about the company, and have to answer a question based on those facts. Here's an example. We know that:</p>
<ul>
<li>Alice directly supervises Bob.</li>
<li>Bob directly supervises Charlie.</li>
<li>Alice graduated Brown.</li>
<li>Charlie graduated Harvale.</li>
</ul>
<p>To keep things simple, we'll assume that all three people graduated some university.</p>
<p><strong>Exercise:</strong> Does someone who graduated from Brown directly supervise someone who graduated from another University?</p>
<details>
<summary>Think, then click.</summary>
<p>Yes! Regardless of whether Bob graduated from Brown, <em>some</em> Brown graduate supervises <em>some</em> non-Brown graduate. Reasoning by hypotheticals, there is one fact we don't know: where Bob graduated. In case he graduated Brown, he supervises Charlie, a non-Brown graduate. In case he graduated from another school, he's supervised by Alice, a Brown graduate.</p>
<p>Humans tend to be very bad at reasoning by hypotheticals. There's a temptation to think that this puzzle isn't solvable because we don't know where Bob graduated from. Even Tim thought this at first after seeing the puzzle—in grad school! For logic!</p>
</details>
<hr />
<p>Now imagine a puzzle with a thousand of these unknowns. A thousand boolean variables means <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span></span></span></span></span></span></span></span></span></span></span></span> cases to reason through. Want to use a computer yet?</p>
<!-- ### Reasoning about knowledge

There is a prison in a magical world where an evil wizard holds a family of four gnomes. Every day, the wizard forces the gnomes to play a game for their freedom: he lines them up, single-file, in one or more rooms, facing the wall. The gnomes cannot move or communicate with each other; they can only look straight ahead. The wizard then pulls out four hats: two orange and two blue, and magics one onto each gnome's head.

The wizard then walks the line, asking each gnome: "What is your hat color?" They may try to answer, or remain silent for 10 seconds (and then the wizard moves on). If a gnome guesses correctly, they all immediately go free. But if one guesses incorrectly, they become the wizard's magical servants forever. So it's in their best interest to not answer unless they are absolutely convinced that they have guessed correctly.

Neither the wizard nor the gnomes can cheat. It's against magical law. The gnomes are, however, very intelligent. Smarter than the wizard for sure: they're perfect logical reasoners.

Here's an example configuration of the puzzle room:

| ![Picture of gnomes-puzzle setup](https://i.imgur.com/SFAoYZy.jpg) |
|:--:| 
|  *(Why are they smiling?)* |

**Exercise:** In this configuration, can the gnomes escape? If so, why?

<details>
    <summary>Think, then click.</summary>

Yes! The gnomes can escape, because they're able to use the knowledge of other gnomes _without explicit communication_. When the wizard asks Gnome #2 what color their hat is, Gnome #2 can conclude nothing, and is silent. Gnome #3 can then reason that his hat, and the hat of Gnome #4, must be different colors. Only two colors are possible. And so the wizard is thwarted.
</details>

To solve this puzzle, you need to reason about what the other agents know, and what we expect them to do with that knowledge. These sorts of epistemic statements can be useful in practice. -->
<p><strong>This isn't really about logic puzzles.</strong></p>
<h3 id="a-real-scenario"><a class="header" href="#a-real-scenario">A Real Scenario</a></h3>
<p>There's a real cryptographic protocol called the Needham-Schroeder public-key protocol. You can read about it <a href="https://en.wikipedia.org/wiki/Needham%E2%80%93Schroeder_protocol#The_public-key_protocol">here</a>. Unfortunately the protocol has a bug: it's vulnerable to attack if one of the principles can be fooled into starting an exchange with a badly-behaved or compromised agent. We won't go into specifics. Instead, let's focus on the fact that it's quite easy to get things like protocols wrong, and sometimes challenging for us humans to completely explore all possible behaviors -- especially since there might be behaviors we'd never even considered! It sure would be nice if we could get a computer to help out with that.</p>
<p>A pair of former 1710 students did an <a href="http://cs.brown.edu/~tbn/publications/ssdnk-fest21-forge.pdf">ISP on modeling crypto protocols</a>, using the tools you'll learn in class. Here's an example picture, generated by their model, of the flaw in the Needham-Schroeder protocol:</p>
<p><img src="chapters/manifesto/./ns-custom.png" alt="An execution of the Needham-Schroeder protocol." /></p>
<p>You don't need to understand the specifics of the visualization; the point is that someone who has studied crypto protocols <strong>would</strong>. And this really does show the classic attack on Needham-Schroeder. You may not be a crypto-protocol person, but you probably are an expert in something subtle that you'd like to model, reason about, and understand better. </p>
<div id="admonition-brown-csci-1710" class="admonition admonish-warning">
<div class="admonition-title">
<p>Brown CSCI 1710</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/manifesto.html#admonition-brown-csci-1710"></a></p>
</div>
<div>
<p>In fact, if you're reading this as part of your coursework for CSCI 1710, you will be <em>expected</em> to select, research, and model something yourself based on your interests. This is one of our main end-goals for the course.</p>
</div>
</div>
<h2 id="automated-reasoning-as-an-assistive-device"><a class="header" href="#automated-reasoning-as-an-assistive-device">Automated Reasoning as an Assistive Device</a></h2>
<p>The human species has been so successful, in part, because of our ability to use assistive devices—tools! Eyeglasses, bicycles, hammers, bridges: all devices that assist us in navigating the world in our fragile meat-bodies. One of our oldest inventions, writing, is an assistive device that increases our long-term memory space and makes that memory <em>persistent</em>. Computers are only one in a long line of such inventions.</p>
<p>So, naturally, we've found ways to:</p>
<ul>
<li>use computers to help us test our ideas;</li>
<li>use computers to exhaustively check program correctness;</li>
<li>use computers to help us find gaps in our intuition about a program;</li>
<li>use computers to help us explore the design space of a data structure, or algorithm, card game, or chemical reaction; </li>
<li>etc.</li>
</ul>
<p>There's a large body of work in Computer Science that uses logic to do all those things. We tend to call it <em>formal methods</em>, especially when the focus is on reasoning about systems. It touches on topics like system modeling, constraint solving, program analysis, design exploration, and more. That's what this book is about: the foundational knowledge to engage with many different applications of these ideas, even if you don't end up working with them directly every day. </p>
<p>More concretely, we'll focus on a class of techniques called <em>lightweight</em> formal methods, which are characterized by tradeoffs that favor ease of use over strong guarantees (although we'll sometimes achieve those as well).</p>
<div id="admonition-further-reading" class="admonition admonish-tip">
<div class="admonition-title">
<p>Further Reading</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/manifesto.html#admonition-further-reading"></a></p>
</div>
<div>
<p>Jeanette Wing and Daniel Jackson wrote a short article coining the term &quot;lightweight FM&quot; in the 90's, which you can find <a href="http://www.cs.cmu.edu/~wing/publications/JacksonWing96.pdf">online</a>.</p>
</div>
</div>
<div id="admonition-what-is-a-system" class="admonition admonish-warning">
<div class="admonition-title">
<p>What is a system?</p>
<p><a class="admonition-anchor-link" href="chapters/manifesto/manifesto.html#admonition-what-is-a-system"></a></p>
</div>
<div>
<p>When we say &quot;systems&quot; in this book we don't necessarily mean the kind of systems you see in a class on networks, hardware architecture, or operating systems. You can apply the techniques in this book to those subjects quite naturally, but you can also apply it to user interfaces, type systems in programming, hardware, version control systems like Git, web security, cryptographic protocols, robotics, puzzles, sports and games, and much more. So we construe the word &quot;system&quot; very broadly.</p>
<p>Here are some examples of &quot;systems&quot; that students have modeled in Forge: lifetimes in Rust, network reachability, and poker!</p>
<div class="showcase">
  <div class="example">
    <div class="vizimg"><img width="100%" src="chapters/manifesto/./borrow-newt-custom.png"/></div>
    <div class="viztext">
      <div class="vizlabel">Rust Lifetimes and Borrowing</div>
      <div class="vizauthor">Thomas Castleman and Ria Rajesh</div>
      <div class="vizpub">Course Project</div>
    </div>
  </div>
  <div class="example">
    <div class="vizimg"><img width="100%" src="chapters/manifesto/./netlab-custom-def1.png"/></div>
    <div class="viztext">
      <div class="vizlabel">Network Reachability</div>
      <div class="vizauthor">Tim Nelson and Pamela Zave</div>
      <div class="vizpub"><a href="https://fm.csl.sri.com/SSFT23/">(link to lab)</a></div>
    </div>
  </div>
  <div class="example">
    <div class="vizimg"><img width="100%" src="chapters/manifesto/./texas.png"/></div>
    <div class="viztext">
      <div class="vizlabel">Texas Hold 'Em</div>
      <div class="vizauthor">Matthew Boranian and Austin Lang</div>
      <div class="vizpub">Course Project</div>
    </div>
  </div>
</div>
</div>
</div>
<h2 id="the-future-of-computing"><a class="header" href="#the-future-of-computing">The Future of Computing</a></h2>
<p>For better or worse, The shape of engineering is changing. Lots of people are excited, scared, or both about large language models like ChatGPT. This book won't teach you how to use generative AI, so it's reasonable to wonder: <em>why learn from this book, instead of reading yet another book on another (deservedly) hot topic, like machine learning?</em></p>
<p>There are two questions that will never go out of style, and won't be answered by AI (at least, not in our lifetimes):</p>
<ul>
<li><strong>What do you want to build?</strong> What does your customer really need? Answering this requires talking to them and other stakeholders, watching their processes, seeking their feedback, and adjusting your design based on it. And no matter who (or what) is writing the actual code, you need to be able to express all this precisely enough that they (or it) can succeed at the implementation.</li>
<li><strong>How will you evaluate what you get?</strong> No matter who (or what) is building the system, verification is needed before the system can be trusted.</li>
</ul>
<p>Even setting aside the customer-facing aspects, we'll still need to think critically about what it is we want and how to evaluate whether we're getting it. The skills you learn here will remain useful (or become even more so) as engineering evolves. In the next chapter, we'll try to convince you that these skills will be useful for more than just code.</p>
<h2 id="formal-methods"><a class="header" href="#formal-methods">&quot;Formal Methods&quot;</a></h2>
<p><em>Formal methods</em> (FM) are ways to help you think carefully about a domain, process, or system. They use math-based techniques (which are usually implemented in tools) to help. They aren't an academic exercise; they are used widely in industry and have likely saved billions of dollars and thousands of lives.</p>
<p>Some industrial examples I'm fond of include:</p>
<ul>
<li><a href="https://aws.amazon.com/blogs/security/protect-sensitive-data-in-the-cloud-with-automated-reasoning-zelkova/">Amazon Web Services' Zelkova</a>, which helps administrators author better security policies for their services. This book will give you the tools to build a policy-analysis system like Zelkova yourself. </li>
<li><a href="https://www.microsoft.com/en-us/research/publication/thorough-static-analysis-of-device-drivers/">Microsoft's static driver verifier</a>, which helps increase the reliability of low-level device drivers in Windows. While this book doesn't cover the techniques they used, I love to showcase this work (which helped Microsoft ship more stable drivers and, at this point, is now decades old).</li>
<li><a href="https://github.com/visualzhou/mongo-repl-tla">MongoDB's work on modeling replication</a>, which found a real bug in their code. Quoting the linked page: &quot;We've never encountered this issue in testing or in the field and only found it by reasoning about the edge cases. This shows writing and model checking ... specs is an excellent alternative way to find and verify edge cases.&quot; (Ellipsis mine.) We won't use this exact <em>tool</em>, but we'll cover other model checkers in this book.</li>
</ul>
<p>We can find real applications for FM outside Computer Science too---even the law. <a href="https://roundtablelaw.medium.com/utterly-unpersuasive-formal-methods-and-law-bb8ecf048374">Here's an article</a> about the value of modeling <em>legal concepts</em> to find loopholes in the law. This is the sort of FM we'll be learning how to do in 1710.</p>
<p><a href="https://github.com/ligurio/practical-fm">This Github repository</a> keeps a (reasonably up to date, but not exhaustive!) list of other industrial applications of formal methods. Check it out! </p>
<h3 id="exercise"><a class="header" href="#exercise">Exercise</a></h3>
<p>Can you think of one or two domains, systems, or processes that especially interest you? Think about the kinds of &quot;system&quot; you interact with regularly or have learned about in your life. What would you like to understand better about those systems? </p>
<p>Remember that we construe the word <em>system</em> broadly. A cryptographic protocol is a system, but so is the game of baseball. A data structure is a system, but so are chemical reactions. </p>
<h2 id="looking-ahead-tools"><a class="header" href="#looking-ahead-tools">Looking Ahead: Tools</a></h2>
<p>The main tool we'll use in this book is <a href="http://forge-fm.org">Forge</a>, a tool for modeling systems. In the course of the book, we'll be progressing through three <em>language levels</em> in Forge:</p>
<ul>
<li><strong>Froglet</strong>, which restricts the set of operations so that we can jump right in more easily. If you have intuitions about object-oriented programming, those intuitions will be useful in Froglet, although there are a few important differences that we'll talk about.</li>
<li><strong>Relational Forge</strong>, which expands the set of operations available to include sets, relations, and relational operators. These are useful for reasoning about complex relationships between objects and for representing certain domains, like databases or graphs.</li>
<li><strong>Temporal Forge</strong>, which helps us cleanly model how a system's state evolves over time. Temporal Forge is based on the industry-standard specification language LTL—Linear Temporal Logic.</li>
</ul>
<p>We'll also use some other tools, like:</p>
<ul>
<li><a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a>, a testing library for Python; and</li>
<li><a href="https://github.com/Z3Prover/z3">Z3</a>, an SMT solver library. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="from-tests-to-properties"><a class="header" href="#from-tests-to-properties">From Tests to Properties</a></h2>
<!-- Other examples we could include

Implementation of a linked list. 
* What should `add` guarantee?

* change-making 
  * simple greedy algorithm (largest coins first)
  * apply PBT (correct total, in drawer)
  * let's try this on LLM-generated code

 -->
<p>We'll talk about more than just software soon. For now, let's go back to testing. Most of us have learned how to write test cases. Given an input, here's the output to expect. Tests are a kind of pointwise <em>specification</em>; a partial one, and not great for fully describing what you want, but a kind of specification nonetheless. They're cheap, non-trivially useful, and better than nothing.</p>
<p>But they also carry our biases, they can't cover an infinite input space, etc. Even more, they're not always adequate carriers of intent: if I am writing a program to compute the statistical median of a dataset, and write <code>assert median([1,2,3]) == 2</code>, what exactly is the behavior of the system I'm trying to confirm? Surely I'm not writing the test because I care specifically about <code>[1,2,3]</code> only, and not about <code>[3,4,5]</code> in the same way? Maybe there was some broader aspect, some <em>property</em> of median I cared about when I wrote that test. </p>
<p><strong>Exercise:</strong> What do you think it was? What makes an implementation of <code>median</code> correct?</p>
<details>
<summary>Think, then click!</summary>
<p>There might be many things! One particular idea is that, if the input list has odd length, the median needs to be an element of the list. Or that, once the set is sorted, the median should be the &quot;middle&quot; element.</p>
</details>
<hr />
<p>There isn't always an easy-to-extract property for every unit test. But this idea—encoding <em>goals</em> instead of specific behaviors—forces us to start thinking critically about <em>what exactly we want</em> from a system and helps us to express it in a way that others (including, perhaps, LLMs) can better use. It's only a short hop from there to some of the real applications we talked about last time, like verifying firewalls or modeling the Java type system.</p>
<div id="admonition-sometimes-you-can-test-exhaustively" class="admonition admonish-note">
<div class="admonition-title">
<p>Sometimes, you can test exhaustively!</p>
<p><a class="admonition-anchor-link" href="chapters/properties/pbt.html#admonition-sometimes-you-can-test-exhaustively"></a></p>
</div>
<div>
<p>Sometimes the input space is small enough that exhaustive testing works well. This blog post, entitled <a href="https://news.ycombinator.com/item?id=34726919">&quot;There are only four billion floats&quot;</a> is an example.</p>
<p>Depending on your experience, this may also be a different kind from testing from what you're used to. Building a repertoire of different tools is essential for any engineer!</p>
</div>
</div>
<h3 id="a-new-kind-of-testing"><a class="header" href="#a-new-kind-of-testing">A New Kind of Testing</a></h3>
<h4 id="cheapest-paths"><a class="header" href="#cheapest-paths">Cheapest Paths</a></h4>
<p>Consider the problem of finding cheapest paths in a weighted graph. There are quite a few algorithms you might use: Dijkstra, Bellman-Ford, even a plain breadth-first search for an unweighted graph. You might have implemented one of these for another class! </p>
<p>The problem statement seems simple: take a graph <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">GR</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> and two vertex names <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">2</span></span></span></span> as input. Produce the cheapest path from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">1</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">2</span></span></span></span> in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">GR</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>. But it turns out that this problem hides a lurking issue.</p>
<p><strong>Exercise:</strong> Find the cheapest path from vertex <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> to vertex <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> on the graph below.</p>
<p><img src="https://i.imgur.com/CT7MSgl.jpg" alt="" /></p>
<details>
<summary>Think, then click!</summary>
The path is G to A to B to E.    
<p>Great! We have the answer. Now we can go and add a test case for with that graph as input and (G, A, B, E) as the output. </p>
<p>Wait -- you found a different path? G to D to B to E?</p>
<p>And another path? G to H to F to E?</p>
</details>
<hr />
<p>If we add a traditional test case corresponding to <em>one</em> of the correct answers, our test suite will falsely raise alarms for correct implementations that happen to find different answers. In short, we'll be over-fitting our tests to @italic{one specific implementation}: ours. But there's a fix. Maybe instead of writing:</p>
<p><code>shortest(GRAPH, G, E) == [(G, A), (A, B), (B, E)]</code></p>
<p>we write:</p>
<pre><code>shortest(GRAPH, G, E) == [(G, A), (A, B), (B, E)] or
shortest(GRAPH, G, E) == [(G, D), (D, B), (B, E)] or
shortest(GRAPH, G, E) == [(G, H), (H, F), (F, E)]
</code></pre>
<p><strong>Exercise:</strong> What's wrong with the &quot;big or&quot; strategy? Can you think of a graph where it'd be unwise to try to do this?</p>
<details>
    <summary>Think, then click!</summary>
<p>There are at least two problems. First, we might have missed some possible solutions, which is quite easy to do; the first time Tim was preparing these notes, he missed the third path above! Second, there might be an unmanageable number of equally correct solutions. The most pathological case might be something like a graph with all possible edges present, all of which have weight zero. Then, every path is cheapest.</p>
</details>
<hr />
<p>This problem -- multiple correct answers -- occurs in every part of Computer Science. Once you're looking for it, you can't stop seeing it. Most graph problems exhibit it. Worse, so do most optimization problems. Unique solutions are convenient, but the universe isn't built for our convenience. </p>
<p><strong>Exercise:</strong> What's the solution? If <em>test cases</em> won't work, is there an alternative? (Hint: instead of defining correctness bottom-up, by small test cases, think top-down: can we say what it <strong>means</strong> for an implementation to be correct, at a high level?)</p>
<details>
<summary>Think, then click!</summary>
<p>In the cheapest-path case, we can notice that the costs of all cheapest paths are the same. This enables us to write:</p>
<p><code>cost(cheapest(GRAPH, G, E)) = 11</code></p>
<p>which is now robust against multiple implementations of <code>cheapest</code>.</p>
</details>
<hr />
<p>This might be something you were taught to do when implementing cheapest-path algorithms, or it might be something you did on your own, unconsciously. (You might also have been told to ignore this problem, or not told about it at all...) We're not going to stop there, however.</p>
<p>Notice that we just did something subtle and interesting. Even if there are a billion cheapest paths between two vertices in the input graph, they all have that same, minimal length. Our testing strategy has just evolved past naming <em>specific</em> values of output to checking broader <em>properties</em> of output.</p>
<p>Similarly, we can move past specific inputs: randomly generate them. Then, write a function <code>is_valid</code> that takes an arbitrary <code>input, output</code> pair and returns true if and only if the output is a valid solution for the input. Just pipe in a bunch of inputs, and the function will try them all. You can apply this strategy to most any problem, in any programming language. (For your homework this week, you'll be using Python.) Let's be more careful, though.</p>
<p><strong>Exercise:</strong> Is there something <em>else</em> that <code>cheapest</code> needs to guarantee for that input, beyond finding a path with the same cost as our solution?</p>
<details>
<summary>Think, then click!</summary>
<p>We also need to confirm that the path returned by <code>cheapest</code> is indeed a path in the graph! </p>
</details>
<hr />
<p><strong>Exercise:</strong> Now take that list of goals, and see if you can outline a function that tests for it. Remember that the function should take the problem input (in this case, a graph and the source and destination vertices) and the output (in this case, a path). You might generate something like this pseudocode:</p>
<details>
<summary>Think, then click!</summary>
<pre><code>isValid : input: (graph, vertex, vertex), output: list(vertex) -&gt; bool
  returns true IFF:
    (1) output.cost == trustedImplementation(input).cost
    (2) every vertex in output is in input's graph
    (3) every step in output is an edge in input
    ... and so on ...
</code></pre>
</details>
<hr />
<p>This style of testing is called Property-Based Testing (PBT). When we're using a trusted implementation—or some other artifact—to either evaluate the output or to help generate useful inputs, it is also a variety of Model-Based Testing (MBT). </p>
<div id="admonition-model-based-testing" class="admonition admonish-note">
<div class="admonition-title">
<p>Model-Based Testing</p>
<p><a class="admonition-anchor-link" href="chapters/properties/pbt.html#admonition-model-based-testing"></a></p>
</div>
<div>
<p>There's a lot of techniques under the umbrella of MBT. A model can be another program, a formal specification, or some other type of artifact that we can &quot;run&quot;. Often, MBT is used in a more stateful way: to generate sequences of user interactions that drive the system into interesting states. </p>
<p>For now, know that modeling systems can be helpful in generating good tests, in addition to everything else.</p>
</div>
</div>
<p>There are a few questions, though...</p>
<p><strong>Question:</strong> Can we really trust a &quot;trusted&quot; implementation?</p>
<p>No, not completely. It's impossible to reach a hundred percent trust; anybody who tells you otherwise is selling something. Even if you spend years creating a correct-by-construction system, there could be a bug in (say) how it is deployed or connected to other systems. </p>
<p>But often, questions of correctness are really about the <em>transfer of confidence</em>: my old, slow implementation has worked for a couple of years now, and it's probably mostly right. I don't trust my new, optimized implementation at all: maybe it uses an obscure data structure, or a language I'm not familiar with, or maybe I don't even have access to the source code at all. </p>
<p>And anyway, often we don't need recourse to any trusted model; we can just phrase the properties directly. </p>
<p><strong>Exercise:</strong> What if we don't have a trusted implementation?</p>
<details>
<summary>Think, then click!</summary>
<p>You can use this approach whenever you can write a function that checks the correctness of a given output. It doesn't need to use an existing implementation (it's just easier to talk about that way). In the next example we won't use a trusted implementation at all!</p>
</details>
<h4 id="input-generation"><a class="header" href="#input-generation">Input Generation</a></h4>
<p>Now you might wonder: <em>Where do the inputs come from</em>?</p>
<p>Great question! Some we will manually create based on our own cleverness and understanding of the problem. Others, we'll generate randomly.</p>
<p>Random inputs are used for many purposes in software engineering: &quot;fuzz testing&quot;, for instance, creates vast quantities of random inputs in an attempt to find crashes and other serious errors. We'll use that same idea here, except that our notion of correctness is usually a bit more nuanced.</p>
<p>Concretely:</p>
<p><img src="https://i.imgur.com/gCGDK6m.jpg" alt="A diagram of property-based testing. A random input generator, plus some manually-chosen inputs, are sent to the implementation under test. The outputs are then run through the validator function." /></p>
<p>It's important to note that some creativity is still involved here: you need to come up with an <code>is_valid</code> function (the &quot;property&quot;), and you'll almost always want to create some hand-crafted inputs (don't trust a random generator to find the subtle corner cases you already know about!) The strength of this approach lies in its resilience against problems with multiple correct answers, and in its ability to <em>mine for bugs while you sleep</em>. Did your random testing find a bug? Fix it, and then add that input to your list of regression tests. Rinse, repeat.</p>
<p>If we were still thinking in terms of traditional test cases, this would make no sense: where would the outputs come from? Instead, we've created a testing system where concrete outputs aren't something we need to provide. Instead, we check whether the program under test produces <em>any valid output</em>.</p>
<h3 id="the-hypothesis-library"><a class="header" href="#the-hypothesis-library">The Hypothesis Library</a></h3>
<p>There are PBT libraries for most every popular language. In this book, we'll be using a library for Python called <a href="https://hypothesis.readthedocs.io/en/latest/index.html">Hypothesis</a>. Hypothesis has many helper functions to make generating random inputs relatively easy. It's worth spending a little time stepping through the library. Let's test a function in Python itself: the <code>median</code> function in the <code>statistics</code> library, which we began this chapter with. What are some important properties of <code>median</code>?</p>
<div id="admonition-csci-1710-llms-and-testing" class="admonition admonish-note">
<div class="admonition-title">
<p>CSCI 1710: LLMs and Testing</p>
<p><a class="admonition-anchor-link" href="chapters/properties/pbt.html#admonition-csci-1710-llms-and-testing"></a></p>
</div>
<div>
<p>If you're in CSCI 1710, your first homework starts by asking you to generate code using an LLM of your choice, such as ChatGPT. Then, you'll use property-based testing to assess its correctness.  To be clear, <strong>you will not be graded on the correctness of the code you prompt an LLM to generate</strong>. Rather, you will be graded on how good your property-based testing is. </p>
<p>Later in the semester, you'll be using PBT again to test more complex software!</p>
</div>
</div>
<p>Now let's use Hypothesis to test at least one of those properties. We'll start with this <a href="chapters/properties/./pbt.py">template</a>:</p>
<pre><code class="language-python">from hypothesis import given, settings
from hypothesis.strategies import integers, lists
from statistics import median

# Tell Hypothesis: inputs for the following function are non-empty lists of integers
@given(lists(integers(), min_size=1)) 
# Tell Hypothesis: run up to 500 random inputs
@settings(max_examples=500)
def test_python_median(input_list):    
    pass

# Because of how Python's imports work, this if statement is needed to prevent 
# the test function from running whenever a module imports this one. This is a 
# common feature in Python modules that are meant to be run as scripts. 
if __name__ == &quot;__main__&quot;: # ...if this is the main module, then...
    test_python_median()

</code></pre>
<p>Let's start by filling in the <em>shape</em> of the property-based test case:</p>
<pre><code class="language-python">def test_python_median(input_list):    
    output_median = median(input_list) # call the implementation under test
    print(f'{input_list} -&gt; {output_median}') # for debugging our property function
    if len(input_list) % 2 == 1:
        assert output_median in input_list 
    # The above checks a conditional property. But what if the list length isn't even?
    # We should be able to do better!
</code></pre>
<p><strong>Exercise</strong>: Take a moment to try to express what it means for <code>median</code> to be correct in the language of your choice. Then continue on with reading this section.</p>
<p>Expressing properties can often be challenging. After some back and forth, we might reach a candidate function like this:</p>
<pre><code class="language-python">def test_python_median(input_list):
    output_median = median(input_list)
    print(f'{input_list} -&gt; {output_median}')
    if len(input_list) % 2 == 1:
        assert output_median in input_list
    
    lower_or_eq =  [val for val in input_list if val &lt;= output_median]
    higher_or_eq = [val for val in input_list if val &gt;= output_median]
    assert len(lower_or_eq) &gt;= len(input_list) // 2    # int division, drops decimal part
    assert len(higher_or_eq) &gt;= len(input_list) // 2   # int division, drops decimal part
</code></pre>
<p>Unfortunately, there's a problem with this solution. Python's <code>median</code> implementation <em>fails</em> this test! Hypothesis provides a random input on which the function fails: <code>input_list=[9502318016360823, 9502318016360823]</code>. Give it a try! This is what <em>my</em> computer produced; what happens on yours?</p>
<p>Exercise: <strong>What do you think is going wrong?</strong></p>
<details>
  <summary>Think, then click!</summary>
<p>Here's what my Python console reports:</p>
<pre><code class="language-python">&gt;&gt;&gt; statistics.median([9502318016360823, 9502318016360823])
9502318016360824.0
</code></pre>
<p>I really don't like seeing a number that's larger than both numbers in the input set. But I'm also suspicious of that trailing <code>.0</code>. <code>median</code> has returned a <code>float</code>, not an <code>int</code>. That might matter. But first, we'll try the computation that we might expect <code>median</code> to run:</p>
<pre><code class="language-python">&gt;&gt;&gt; (9502318016360823*2)/2
9502318016360824.0
</code></pre>
<p>What if we force Python to perform <em>integer</em> division?</p>
<pre><code class="language-python">&gt;&gt;&gt; (9502318016360823*2)//2
9502318016360823
</code></pre>
<p>Could this be a floating-point imprecision problem? Let's see if Hypothesis can find another failing input where the values are smaller. We'll change the generator to produce only small numbers, and increase the number of trials hundredfold:</p>
<pre><code class="language-python">@given(lists(integers(min_value=-1000,max_value=1000), min_size=1))
@settings(max_examples=50000)
</code></pre>
<p>No error manifests. That doesn't mean one <em>couldn't</em>, but it sure looks like large numbers make the chance of an error much higher. </p>
<p>The issue is: because Python's <code>statistics.median</code> returns a <code>float</code>, we've inadvertently been testing the accuracy of Python's primitive floating-point division, and floating-point division is <a href="https://docs.python.org/3/tutorial/floatingpoint.html">known to be imprecise</a> in some cases. It might even manifest differently on different hardware—this is only what happens on <em>my</em> laptop!</p>
<p>Anyway, we have two or three potential fixes: </p>
<ul>
<li>bound the range of potential input values when we test; </li>
<li>check equality within some small amount of error you're willing to tolerate (a common trick when writing tests about <code>float</code> values); or </li>
<li>change libraries to one that uses an arbitrary-precision, like <a href="https://pypi.org/project/BigNumber/">BigNumber</a>. We could adapt our test fairly easily to that setting, and we'd expect this problem to not occur. </li>
</ul>
<p>Which is best? I don't really like the idea of arbitrarily limiting the range of input values here, because picking a range would require me to understand the floating-point arithmetic specification a lot more than I do. For instance, how do I know that there exists some number <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> before which this issue can't manifest? How do I know that all processor architectures would produce the same thing? </p>
<p>Between the other two options (adding an error term and changing libraries) it depends on the engineering context we're working in. Changing libraries may have consequences for performance or system design. Testing equality <em>within some small window</em> may be the best option in this case, where we know that many inputs will involve <code>float</code> division. </p>
</details>
<h3 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h3>
<p>We'll close this section by noticing two things:</p>
<p>First, being precise about <em>what correctness means</em> is powerful. With ordinary unit tests, we're able to think about behavior only <em>point-wise</em>. Here, we need to broadly describe our goals, and tere's a cost to that, but also advantages: comprehensibility, more powerful testing, better coverage, etc. And we can still get value from a partial definition, because we can then at least apply PBT to that portion of the program's behavior. </p>
<p>Second, the very act of trying to precisely express, and test, correctness for <code>median</code> <em>taught us (or reminded us about) something subtle about how our programming language works</em>, which tightened our definition of correctness. Modeling often leads to such a virtuous cycle. </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="intro-to-modeling-systems-part-1-tic-tac-toe"><a class="header" href="#intro-to-modeling-systems-part-1-tic-tac-toe">Intro to Modeling Systems (Part 1: Tic-Tac-Toe)</a></h1>
<h2 id="whats-a-model"><a class="header" href="#whats-a-model">What's a Model?</a></h2>
<p>A <strong>model</strong> is a <em>representation</em> of a system that faithfully includes some but not all of the system's complexity. There are many different ways to model a system, all of which have different advantages and disadvantages. Think about what a car company does before it produces a new car design. Among other things, it creates multiple models. E.g.,</p>
<ul>
<li>it models the car in some computer-aided design tool; and then</li>
<li>creates a physical model of the car, perhaps with clay, for testing in wind tunnels etc.</li>
</ul>
<p>There may be many different models of a system, all of them focused on something different. As the statisticians say, &quot;all models are wrong, but some models are useful&quot;. Learning how to model a system is a key skill for engineers, not just within &quot;formal methods&quot;. Abstraction is one of the key tools in Computer Science, and modeling lies at the heart of abstraction.</p>
<p>In this course, <strong>the models we build aren't inert</strong>; we have tools that we can use the explore and analyze them!</p>
<h3 id="dont-be-afraid-of-imperfect-representations"><a class="header" href="#dont-be-afraid-of-imperfect-representations">Don't Be Afraid of Imperfect Representations</a></h3>
<p><em>We don't need to fully model a system to be able to make useful inferences</em>. We can simplify, omit, and abstract concepts/attributes to make models that approximate the system while preserving the fundamentals that we're interested in. </p>
<p><strong>Exercise:</strong> If you've studied physics, there's a great example of this in statics and dynamics. Suppose I drop a coin from the top of the science library, and ask you what its velocity will be when it hits the ground. Using the methods you learn in beginning physics, what's something you usefully <em>disregard</em>?</p>
<details>
<summary>Think, then click!</summary>
<p>Air resistance! Friction! We can still get a reasonable approximation for many problems without needing to include that. (And advanced physics adds even more factors that aren't worth considering at this scale.) The model without friction is often enough.</p>
</details>
<h2 id="what-is-a-system-models-vs-implementations"><a class="header" href="#what-is-a-system-models-vs-implementations">What is a &quot;System&quot;? (Models vs. Implementations)</a></h2>
<p>When we say &quot;systems&quot; in this book, we mean the term broadly. A distributed system (like <a href="https://github.com/visualzhou/mongo-repl-tla">replication in MongoDB</a>) is a system, but so are user interfaces and hardware devices like CPUs and insulin pumps. Git is a system for version control. The web stack, cryptographic protocols, chemical reactions, the rules of sports and games—these are all systems too!</p>
<p>To help build intuition, let's work with a simple system: the game of <a href="https://en.wikipedia.org/wiki/Tic-tac-toe">tic-tac-toe</a> (also called noughts and crosses). There are <em>many</em> implementations of this game, including <a href="https://csci1710.github.io/2023/examples/ttt.py">this one</a> that I wrote in Python. And, of course, these implementations often have corresponding test suites, like <a href="https://csci1710.github.io/2023/examples/test_ttt.py">this (incomplete) example</a>.</p>
<p><strong>Exercise</strong>: Play a quick game of tic-tac-toe by hand. If you can, find a partner, but if not, then play by yourself.</p>
<p>Notice what just happened. You played the game. In doing so, you ran your own mental implementation of the rules. The result you got was one of many possible games, each with its own specific sequence of legal moves, leading to a particular ending state. Maybe someone won, or maybe the game was a tie. Either way, many different games could have ended with that same board. </p>
<p>Modeling is different from programming. When you're programming traditionally, you give the computer a set of instructions and it follows them. This is true whether you're programming functionally or imperatively, with or without objects, etc. Declarative modeling languages like Forge work differently. The goal of a model isn't to <em>run instructions</em>, but rather to <em>describe the rules</em> that govern systems. </p>
<p>Here's a useful comparison to help reinforce the difference (with thanks to Daniel Jackson):</p>
<ul>
<li>An empty program <strong>does nothing</strong>.</li>
<li>An empty model <strong>allows every behavior</strong>.</li>
</ul>
<h2 id="modeling-tic-tac-toe-boards"><a class="header" href="#modeling-tic-tac-toe-boards">Modeling Tic-Tac-Toe Boards</a></h2>
<p>What are the essential concepts in a game of tic-tac-toe?</p>
<div id="admonition-modeling-methodology" class="admonition admonish-tip">
<div class="admonition-title">
<p>Modeling Methodology</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-modeling-methodology"></a></p>
</div>
<div>
<p>When we're first writing a model, we'll start with <strong>5 steps</strong>. For each step, I'll give examples from tic-tac-toe and also for binary search trees (which we'll start modeling soon) for contrast.</p>
<ul>
<li>What are the <strong>datatypes</strong> involved, and their <strong>fields</strong>? 
<ul>
<li>For tic-tac-toe: they might be the 3-by-3 board and the <code>X</code> and <code>O</code> marks that go in board locations. </li>
<li>For a binary search tree: they might be the tree nodes and their left and right children. </li>
</ul>
</li>
<li>What makes an instance of these datatypes <strong>well formed</strong>? That is, what conditions are needed for them to not be garbage? 
<ul>
<li>For tic-tac-toe, we might require that the indexes used are between <code>0</code> and <code>2</code>, since the board is 3-by-3. (We could just as easily use <code>1</code>, <code>2</code>, and <code>3</code>. I picked <code>0</code> as the starting point out of habit, because list indexes start from <code>0</code> in the programming languages I tend to use.)</li>
<li>For a binary search tree, we might require that every node has at most one left child, at most one right child, a unique parent, and so on.</li>
</ul>
</li>
<li>What's a small <strong>example</strong> of how these datatypes can be instantiated?
<ul>
<li>For tic-tac-toe, the empty board would be an example. So would the board where <code>X</code> moves first into the middle square.</li>
<li>For a binary search tree, this might be a tree with only one node, or a 3-node tree where the root's left and right children are leaves. </li>
</ul>
</li>
<li>What does the model look like when <strong>run</strong>?
<ul>
<li>For tic-tac-toe, we should see a board with some number of <code>X</code> and <code>O</code> marks.</li>
<li>For a binary search tree, we should see some set of nodes that forms a single tree via left- and right-children.</li>
</ul>
</li>
<li>What <strong>domain predicates</strong> are there? Well-formedness defines conditions that are needed for an instantiation to not be &quot;garbage&quot;. But whatever we're modeling surely has domain-specific concepts of its own, which may or may not hold. 
<ul>
<li>For tic-tac-toe, we care a great deal if the board is a winning board or not. Similarly, we might care if it looks like someone has cheated.</li>
<li>For a binary search tree, we care if the tree is balanced, or if it satisfies the BST invariant. </li>
</ul>
</li>
</ul>
<p>These steps will get us to a point we can begin to iterate: working to <strong>validate and/or refine</strong> the model as we go. It's rare that a model will do everything you need (and do so correctly) on the first try.</p>
</div>
</div>
<div id="admonition-well-formedness-vs-domain-predicates" class="admonition admonish-warning">
<div class="admonition-title">
<p>Well-formedness vs. domain predicates</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-well-formedness-vs-domain-predicates"></a></p>
</div>
<div>
<p>Why make this distinction between well-formedness and domain predicates? Because one should always hold in any instance Forge considers, but the other may or may not hold. In fact, we might want to use Forge to <em>verify</em> that a domain predicate always holds! And if we've told Forge that any instance that doesn't satisfy it is garbage, Forge won't find us such an instance.</p>
</div>
</div>
<h3 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h3>
<p>We might list:</p>
<ul>
<li>the players <code>X</code> and <code>O</code>;</li>
<li>the 3-by-3 game board, where players can put their marks;</li>
<li>the idea of whose turn it is at any given time; and</li>
<li>the idea of who has won the game at any given time.</li>
</ul>
<p>Now let's add those ideas to a model in Forge! </p>
<pre><code class="language-forge editable">#lang forge/froglet
</code></pre>
<p>The first line of any Forge model will be a <code>#lang</code> line, which says which Forge language the file uses. We'll start with the Froglet language for now. Everything you learn in this language will apply in other Forge languages, so I'll use &quot;Forge&quot; interchangeably.</p>
<p>Now we need a way to talk about the noughts and crosses themselves. So let's add a <code>sig</code> that represents them:</p>
<pre><code class="language-forge editable">#lang forge/froglet
abstract sig Player {}
one sig X, O extends Player {}
</code></pre>
<p>You can think of <code>sig</code> in Forge as declaring a kind of object. A <code>sig</code> can extend another, in which case we say that it is a <em>child</em> of its parent, and child <code>sig</code>s cannot overlap. When a sig is <code>abstract</code>, any member must also be a member of one of that <code>sig</code>'s children; in this case, any <code>Player</code> must either be <code>X</code> or <code>O</code>. Finally, a <code>one</code> sig has exactly one member—there's only a single <code>X</code> and <code>O</code> in our model.</p>
<p>We also need a way to represent the game board. We have a few options here: we could create an <code>Index</code> sig, and encode an ordering on those (something like &quot;column A, then column B, then column C&quot;). Another is to use Forge's integer support. Both solutions have their pros and cons. Let's use integers, in part to get some practice with them.</p>
<!-- this shows the play button if we say it is Rust. We have control over what to *do* 
with the highlighting and play button via theme/book.js, so mislead mdbook a bit...
-->
<!-- ```rust,editable -->
<pre><code class="language-forge editable">#lang forge/froglet
abstract sig Player {}
one sig X, O extends Player {}

sig Board {
  board: pfunc Int -&gt; Int -&gt; Player
}
</code></pre>
<p>Every <code>Board</code> object contains a <code>board</code> field describing the moves made so far. This field is a <em>partial function</em>, or dictionary, for every <code>Board</code> that maps each (<code>Int</code>, <code>Int</code>) pair to at most one <code>Player</code>. </p>
<!--
a table of (`Int`, `Int`, `Player`) tuples for each `Board`. We'll see how to work with this field shortly.
-->
<h3 id="well-formedness"><a class="header" href="#well-formedness">Well-formedness</a></h3>
<p>These definitions sketch the overall shape of a board: players, marks on the board, and so on. But not all boards that fit the definition will be valid. For example:</p>
<ul>
<li>Forge integers aren't true mathematical integers, but are bounded by a bitwidth we give whenever we run the tool. So we need to be careful here. We want a classical 3-by-3 board with indexes of (say) <code>0</code>, <code>1</code>, and <code>2</code>, not a board where (e.g.) row <code>-5</code>, column <code>-1</code> is a valid location. </li>
</ul>
<p>We'll call these <em>well-formedness</em> constraints. They aren't innately enforced by our <code>sig</code> declarations, but we'll almost always want Forge to enforce them, so that it doesn't find &quot;garbage instances&quot;. Let's write a <em>wellformedness predicate</em>:</p>
<pre><code class="language-forge editable">-- a Board is well-formed if and only if:
pred wellformed[b: Board] {
  -- row and column numbers used are between 0 and 2, inclusive  
  all row, col: Int | {
    (row &lt; 0 or row &gt; 2 or col &lt; 0 or col &gt; 2) 
      implies no b.board[row][col]      
  }
}
</code></pre>
<div id="admonition-comments-in-forge" class="admonition admonish-tip">
<div class="admonition-title">
<p>Comments in Forge</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-comments-in-forge"></a></p>
</div>
<div>
<p>Forge treats either <code>--</code> or <code>//</code> as beginning a line-level comment, and <code>/* ... */</code> as denoting a block comment. This is different from the Python code we saw in the last section! In Forge, <code>#</code> has a different meaning.</p>
</div>
</div>
<p>This predicate is true of any <code>Board</code> if and only if the above 2 constraints are satisfied. Let's break down the syntax: </p>
<ul>
<li>Constraints can quantify over a domain. E.g.,<code>all row, col: Int | ...</code> says that for any pair of integers (up to the given bitwidth), the following condition (<code>...</code>) must hold. Forge also supports, e.g., existential quantification (<code>some</code>), but we don't need that yet. We also have access to standard boolean operators like <code>or</code>, <code>implies</code>, etc. </li>
<li><em>Formulas</em> in Forge always evaluate to a boolean; <em>expressions</em> evaluate to sets. For example,
<ul>
<li>the <em>expression</em> <code>b.board[row][col]</code> evaluates to the <code>Player</code> (if any) with a mark at location (<code>row</code>, <code>col</code>) in board <code>b</code>; but</li>
<li>the <em>formula</em> <code>no b.board[row][col]</code> is true if and only if there is no such `Player``.</li>
</ul>
</li>
<li>A <code>pred</code> (predicate) in Forge is a helper function that evaluates to a boolean. Thus, its body should always be a formula. </li>
</ul>
<div id="admonition-predicates-are-declarative" class="admonition admonish-tip">
<div class="admonition-title">
<p>Predicates are declarative</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-predicates-are-declarative"></a></p>
</div>
<div>
<p>Notice that, rather than describing a process that produces a well-formed board, or even instructions to check well-formedness, we've just given a declarative description of what's necessary and sufficient for a board to be well-formed. If we'd left the predicate body empty, <em>any</em> board would be considered well-formed—there'd be no formulas to enforce!</p>
</div>
</div>
<h3 id="a-few-examples"><a class="header" href="#a-few-examples">A Few Examples</a></h3>
<p>Since a predicate is just a function that returns true or false, depending on its arguments and whichever instance Forge is looking at, we can write tests for it the same way we would for any other boolean-valued function. But even if we're not testing, it can be useful to write a small number of examples, so we can build intuition for what the predicate means.</p>
<p>In Forge, <code>example</code>s are automatically run whenever your model executes. They describe basic intent about a given predicate; in this case, let's write two examples in Forge:</p>
<ul>
<li>A board where <code>X</code> has moved 3 times in valid locations, and so ought to be considered well formed. </li>
<li>A board where a player has moved in an invalid location, and shouldn't be considered well formed. </li>
</ul>
<p>Notice that we're not making judgements about the rules being obeyed yet—just about whether our <code>wellformed</code> predicate is behaving the way we expect. And the <code>wellformed</code> predicate isn't aware of things like &quot;taking turns&quot; or &quot;stop after someone has won&quot;, etc. It just knows about the valid indexes being <code>0</code>, <code>1</code>, and <code>2</code>.</p>
<p>We'll write those two examples in Forge:</p>
<pre><code class="language-forge editable">-- Helper to make these examples easier to write
pred all_wellformed { all b: Board | wellformed[b]}

-- all_wellformed should be _true_ for the following instance
example firstRowX_wellformed is {all_wellformed} for {
  Board = `Board0                 -- backquote labels specific atoms
  X = `X      O = `O              -- examples must define all sigs
  Player = X + O                  -- only two kinds of player
  `Board0.board = (0, 0) -&gt; `X +  -- the partial function for the board's
                  (0, 1) -&gt; `X +  -- contents (unmentioned squares must 
                  (0, 2) -&gt; `X    -- remain empty, because we used &quot;=&quot; to say
                                  -- &quot;here's the function for `board0&quot;)
}

-- all_wellformed should be _false_ for the following instance
example off_board_not_wellformed is {not all_wellformed} for {
  Board = `Board0 
  X = `X      O = `O 
  Player = X + O
  `Board0.board = (-1, 0) -&gt; `X +
                  (0, 1) -&gt; `X + 
                  (0, 2) -&gt; `X 
}
</code></pre>
<div id="admonition-test-in-both-directions" class="admonition admonish-warning">
<div class="admonition-title">
<p>Test in both directions</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-test-in-both-directions"></a></p>
</div>
<div>
<p>Notice that we've got a test thats a <em>positive</em> example and another test that's a <em>negative</em> example. We want to make sure to exercise both cases, or else &quot;always true&quot; or &quot;always&quot; false could pass our suite.</p>
</div>
</div>
<h3 id="running-forge"><a class="header" href="#running-forge">Running Forge</a></h3>
<p>The <code>run</code> command tells Forge to search for an <em>instance</em> satisfying the given constraints:</p>
<pre><code class="language-forge editable">run { some b: Board | wellformed[b]} 
</code></pre>
<p>(If you're curious about <em>how</em> Forge finds solutions, you can find a brief sketch in <a href="chapters/ttt/../qna/static.html">the Q&amp;A for this chapter</a>.)</p>
<p>When we click the play button in the VSCode extension, the engine solves the constraints and produces a satisfying instance,  (Because of differences across solver versions, hardware, etc., it's possible you'll see a different instance than the one shown here.) A browser window should pop up with a visualization. You can also run <code>racket &lt;filename.frg&gt;</code> in the terminal, although we recommend the VSCode extension. </p>
<!-- Alloy -->
<!-- <img style="float: right;"  src="https://i.imgur.com/jTwED1K.png"/> -->
<!-- 
<img style="float: right;" src="https://i.imgur.com/34krUGX.png"/>
 -->
<div id="admonition-running-forge-on-windows" class="admonition admonish-warning">
<div class="admonition-title">
<p>Running Forge on Windows</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-running-forge-on-windows"></a></p>
</div>
<div>
<p>If you're running on Windows, the Windows-native <code>cmd</code> and PowerShell terminals will not properly load Forge's visualizer. Instead, we suggest using one of many other options on Windows that we've tested and know to work: the VSCode extension (available on the VSCode Marketplace), DrRacket, Git for Windows (e.g., <code>git bash</code>), Windows Subsystem for Linux, or Cygwin.</p>
</div>
</div>
<hr />
<p>There are many options for visualization. The default which loads initially is a directed-graph based one:</p>
<center><img width="70%" src="chapters/ttt/./ttt-viz.png"/></center>
<p><strong>(TODO: make this clickable to show it bigger? Want to see the whole window, but then the graph is small.)</strong></p>
<p>This isn't very useful; it looks nothing like a tic-tac-toe board! We can make more progress by using the &quot;Table&quot; visualization—which isn't ideal either:</p>
<center><img width="40%" src="chapters/ttt/./ttt-viz-table.png"/></center>
<p>Forge also allows users to make <em>custom</em> visualizations via short JavaScript programs; <a href="chapters/ttt/./ttt.js">here's</a> an example basic visualizer for this specific tic-tac-toe model that produces images like this one:</p>
<center><img width="20%" src="chapters/ttt/./ttt-custom.png"/></center>
<p>We'll talk more about visualization scripts later. For now, let's proceed. <strong>TODO: replace img with one matching the table view</strong>
<strong>TODO: add side-by-side CSS</strong></p>
<hr />
<p>This instance contains a single board, and it has 9 entries. Player <code>O</code> has moved in all of them (the <code>0</code> suffix of <code>O0</code> in the display is an artifact of how Forge's engine works; ignore it for now). It's worth noticing two things:</p>
<ul>
<li>This board doesn't look quite right: player <code>O</code> occupies all the squares. We might ask: has player <code>O</code> been cheating? But the fact is that this board <em>satisfies the constraints we have written so far</em>. Forge produces it simply because our model isn't yet restrictive enough, and for no other reason. &quot;Cheating&quot; doesn't exist yet. </li>
<li>We didn't say <em>how</em> to find that instance. We just said what we wanted, and the tool performed some kind of search to find it. So far the objects are simple, and the constraints basic, but hopefully the power of the idea is coming into focus. </li>
</ul>
<div id="admonition-why-board3-when-theres-only-one-board" class="admonition admonish-note">
<div class="admonition-title">
<p>Why <code>Board3</code> when there's only one board?</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-why-board3-when-theres-only-one-board"></a></p>
</div>
<div>
<p>Here, we see <code>Board3</code> because the solver had a few options to pick from: we never said there should only ever be one <code>Board</code>, after all. So, under the hood, it was considering the potential existence of multiple boards. And then it happened to pick this one to exist in this instance.</p>
</div>
</div>
<h3 id="reflection-implementation-vs-model"><a class="header" href="#reflection-implementation-vs-model">Reflection: Implementation vs. Model</a></h3>
<p>So far we've just modeled boards, not full games. But we can still contrast our work here against the Python <em>implementation</em> of tic-tac-toe shared above. </p>
<p><strong>Exercise:</strong> How do the data-structure choices, and type declarations, in the implementation compare with the essence of the game as reflected in the model? What is shared, and what is different? </p>
<p>Spend a minute identifying at least one commonality and at least one difference, then move on.</p>
<h2 id="domain-predicates"><a class="header" href="#domain-predicates">Domain Predicates</a></h2>
<p>Now let's write predicates that describe important ideas in the domain. What's important in the game of tic-tac-toe? Here are a few things.</p>
<h3 id="starting-boards"><a class="header" href="#starting-boards">Starting Boards</a></h3>
<p>What would it mean to be a <em>starting state</em> in a game? The board is empty:</p>
<pre><code class="language-forge editable">pred starting[s: Board] {
  all row, col: Int | 
    no s.board[row][col]
}
</code></pre>
<h3 id="turns"><a class="header" href="#turns">Turns</a></h3>
<p>How do we tell when it's a given player's turn? It's <code>X</code>'s turn when there are the same number of each mark on the board:</p>
<pre><code class="language-forge editable">pred XTurn[s: Board] {
  #{row, col: Int | s.board[row][col] = X} =
  #{row, col: Int | s.board[row][col] = O}
}
</code></pre>
<p>Here, we're measuring the size of 2 sets. The <code>{row, col: Int | ...}</code> syntax is called a <em>set comprehension</em>. A set comprehension defines a set. We're defining the set of row-column pairs where the board contains one of the player marks. The <code>#</code> operator gives the size of these sets, which we then compare.</p>
<p><strong>Exercise:</strong> Is it enough to say that <code>OTurn</code> is the negation of <code>XTurn</code>? That is, we could write: <code>pred OTurn[s: Board] { not XTurn[s: Board]}</code>. This seems reasonable enough; why might we <em>not</em> want to write this?</p>
<details>
<summary>Think, then click!</summary>
<p>Because we defined X's turn to be when the number of X's and O's on the board are in balance. So any <em>other</em> board would be O's turn, including ones that ought to be illegal, once we start defining moves of the game. Instead, let's say something like this:</p>
<pre><code class="language-forge editable">pred OTurn[s: Board] {
  -- It's O's turn if X has moved once more often than O has
  #{row, col: Int | s.board[row][col] = X} =
  add[#{row, col: Int | s.board[row][col] = O}, 1]
}
</code></pre>
</details>
<hr />
<div id="admonition-integer-addition" class="admonition admonish-note">
<div class="admonition-title">
<p>Integer addition</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-integer-addition"></a></p>
</div>
<div>
<p>Forge supports arithmetic operations on integers like <code>add</code>. Forge integers are signed (i.e., can be positive or negative) and are bounded by a <em>bit width</em>, which defaults to <code>4</code> bits. The number of available integers is always $2^k$, where $k$ is the bit width.</p>
<p>Forge follows the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">2's complement arithmetic</a> convention, which means that the available integers are split evenly between positive and negative numbers, but counting <code>0</code> as &quot;positive&quot;. So with 4 bits, we can represent numbers between <code>-8</code> and <code>7</code> (inclusive).</p>
<p>This means that (while it doesn't matter for this model yet), arithmetic operations can overflow—just like primitive integers in languages like Java! For example, if we're working with 4-bit integers, then <code>add[7,1]</code> will be <code>-8</code>. You can experiment with this in the visualizer's <em>evaluator</em>, which we'll be using a lot after the initial modeling tour is done.</p>
</div>
</div>
<div id="admonition-use-add-for-addition-not-" class="admonition admonish-warning">
<div class="admonition-title">
<p>Use <code>add</code> for addition, not <code>+</code></p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-use-add-for-addition-not-"></a></p>
</div>
<div>
<p>Don't try to use <code>+</code> for addition in any Forge language. Use <code>add</code> instead; this is because <code>+</code> is reserved for something else (which we'll explain later).</p>
</div>
</div>
<h3 id="winning-the-game"><a class="header" href="#winning-the-game">Winning the Game</a></h3>
<p>What does it mean to <em>win</em>? A player has won on a given board if:</p>
<ul>
<li>they have placed their mark in all 3 columns of a row; </li>
<li>they have placed their mark in all 3 rows of a column; or</li>
<li>they have placed their mark in all 3 squares of a diagonal.</li>
</ul>
<p>We'll express this in a <code>winner</code> predicate that takes the current board and a player name. Let's also define a couple helper predicates along the way:</p>
<pre><code class="language-forge editable">pred winRow[s: Board, p: Player] {
  -- note we cannot use `all` here because there are more Ints  
  some row: Int | {
    s.board[row][0] = p
    s.board[row][1] = p
    s.board[row][2] = p
  }
}

pred winCol[s: Board, p: Player] {
  some column: Int | {
    s.board[0][column] = p
    s.board[1][column] = p
    s.board[2][column] = p
  }      
}

pred winner[s: Board, p: Player] {
  winRow[s, p]
  or
  winCol[s, p]
  or 
  {
    s.board[0][0] = p
    s.board[1][1] = p
    s.board[2][2] = p
  } or {
    s.board[0][2] = p
    s.board[1][1] = p
    s.board[2][0] = p
  }  
}
</code></pre>
<p>After writing these domain predicates, we're reaching a fairly complete model for a single tic-tac-toe board. Let's decide how to fix the issue we saw above (the reason why <code>OTurn</code> couldn't be the negation of <code>XTurn</code>): perhaps a player has moved too often.</p>
<p>Should we add something like <code>OTurn[s] or XTurn[s]</code> to our wellformedness predicate? <strong>No!</strong> If we then later enforced wellformedness for all boards, that would exclude &quot;cheating&quot; instances where a player has more moves on the board than are allowed. But this has some risk, depending on how we intend to use the <code>wellformed</code> predicate:</p>
<ul>
<li>If we were only ever generating <em>valid boards</em>, a cheating state might well be spurious, or at least undesirable. In that case, we might prevent such states in <code>wellformed</code> and rule it out. </li>
<li>If we were generating arbitrary (not necessarily valid) boards, being able to see a cheating state might be useful. In that case, we'd leave it out of <code>wellformed</code>.</li>
<li>If we're interested in <em>verification</em>, e.g., we are asking whether the game of Tic-Tac-Toe enables ever reaching a cheating board, we shouldn't add <code>not cheating</code> to <code>wellformed</code>; because <code>wellformed</code> also excludes garbage boards, we'd probably use it in our verification—in which case, Forge will never find us a counterexample! </li>
</ul>
<div id="admonition-modeling-vs-pbt" class="admonition admonish-tip">
<div class="admonition-title">
<p>Modeling vs. PBT</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt.html#admonition-modeling-vs-pbt"></a></p>
</div>
<div>
<p>Notice the similarity between this issue and what we do in property-based testing. Here, we're forced to distinguish between what a reasonable <em>board</em> is (analogous to the generator's output in PBT) and what a reasonable <em>behavior</em> is (analogous to the validity predicate in PBT). One narrows the scope of possible worlds to avoid true &quot;garbage&quot;; the other checks whether the system behaves as expected in one of those worlds.</p>
</div>
</div>
<p>We'll come back to this later, when we've had a bit more modeling experience. For now, let's separate our goal into a new predicate called <code>balanced</code>, and add it to our <code>run</code> command above so that Forge will find us an instance where some board is both <code>balanced</code> and <code>wellformed</code>:</p>
<pre><code class="language-forge editable">pred balanced[s: Board] {
  XTurn[s] or OTurn[s]
}
run { some b: Board | wellformed[b] and balanced[b]} 
</code></pre>
<p>If we click the &quot;Next&quot; button a few times, we see that not all is well: we're getting boards where <code>wellformed</code> is violated (e.g., entries at negative rows, or multiple moves in one square). Why is this happening?</p>
<p>We're getting this because of how the <code>run</code> was phrased. We said to find an instance where <em>some board</em> was well-formed and valid, not one where <em>all boards</em> were. Our <code>run</code> is satisfied by any instance where <em>at least one</em> <code>Board</code> is <code>wellformed</code>; the others won't affect the truth of the constraint. By default, Forge will find instances with up to 4 <code>Boards</code>. So we can fix the problem either by telling Forge to find instances with only 1 Board:</p>
<pre><code class="language-forge editable">run { some b: Board | wellformed[b] and balanced[b]} 
for exactly 1 Board
</code></pre>
<p>or by saying that all boards must be well-formed and balanced:</p>
<pre><code class="language-forge editable">run { all b: Board | wellformed[b] and balanced[b]} 
</code></pre>
<h2 id="practice-with-run"><a class="header" href="#practice-with-run">Practice with <code>run</code></a></h2>
<p>The <code>run</code> command can be used to give Forge more detailed instructions for its search. </p>
<h3 id="no-boards"><a class="header" href="#no-boards">No Boards</a></h3>
<p><strong>Exercise:</strong> Is it possible for an instance with <em>no</em> boards to still satisfy constraints like these?</p>
<pre><code class="language-alloy">run {    
     all b: Board | {
         -- X has won, and the board looks OK
         wellformed[b]
         winner[b, X]
         balanced[b]    
     }
 }
</code></pre>
<details>
<summary>Think, then click!</summary>
<p>Yes! There aren't any boards, so there's no obligation for anything to satisfy the constraints inside the quantifier. You can think of the <code>all</code> as something like a <code>for</code> loop in Java or the <code>all()</code> function in Python: it checks every <code>Board</code> in the instance. If there aren't any, there's nothing to check—return true.</p>
</details>
<h3 id="adding-more"><a class="header" href="#adding-more">Adding More</a></h3>
<p>This addition also requires that <code>X</code> moved in the middle of the board:</p>
<pre><code class="language-alloy">run {    
     all b: Board | {
         -- X has won, and the board looks OK
         wellformed[b]
         winner[b, X]
         balanced[b]
         -- X started in the middle
         b.board[1][1] = X
     }
 } for exactly 2 Board
</code></pre>
<p>Notice that, because we said <code>exactly 2 Board</code> here, Forge <em>must</em> find instances containing 2 tic-tac-toe boards, and both of them must satisfy the constraints: wellformedness, <code>X</code> moving in the middle, etc. You could ask for a board where <code>X</code> <em>hasn't</em> won by adding <code>not winner[b, X]</code>. </p>
<!-- You also have `implies` and `iff` (if and only if), although you can still do something like comparing two predicates without `iff` (try, e.g., asking for instances where `A and not B` holds).  -->
<p>We'll come back to tic-tac-toe <a href="chapters/ttt/./ttt_games.html">soon</a>. The <a href="chapters/ttt/../bst/bst.html">next section</a> will cover a second static example let's cover another static example.</p>
<h2 id="testing-with-assertions"><a class="header" href="#testing-with-assertions">Testing with assertions</a></h2>
<p>Before we move on, I want to quickly note that <code>example</code> isn't the only way you can write tests in Forge. The <code>example</code> construct is powerful if you want to write &quot;pointwise&quot; tests in terms of single instances, but can quickly become verbose. If you know what properties you're interested in testing for, you can encode that into an <code>assert</code> in Forge. For example: </p>
<pre><code>// I want to check that this predicate is satisfiable for some set of arguments, 
// but I don't care about the specific instance(s) that satisfy it.
assert {some b: Board | XTurn[b]} is sat

// I want to confirm that OTurn and XTurn are mutually exclusive
// assert {} TODO ADD
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="intro-to-modeling-systems-part-2-bsts"><a class="header" href="#intro-to-modeling-systems-part-2-bsts">Intro to Modeling Systems (Part 2: BSTs)</a></h1>
<p>Now that we've written our first model—tic-tac-toe boards—let's switch to something a bit more serious: binary search trees. A binary search tree (BST) is a binary tree with an added property about its structure that allows it to efficiently answer many search queries related to the values it stores. Here's an example, drawn by hand:</p>
<!-- sips -s format png Bintree.pdf --out BinTree.png  -->
<center>
<img alt="a hand-drawn binary search tree" src="chapters/bst/./Bintree.png" width=40%/>
</center>
<p>Each node of the tree holds some value that the tree supports searching for. We'll call this value the search key, or just the <em>key</em> for each node. The common ancestor of every node in the tree is called the <em>root</em>. </p>
<p>This is obviously a <em>binary tree</em>, since it is a tree where every node has <em>at most</em> 2 children. What makes it a binary <em>search</em> tree is the invariant that every node <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> obeys: </p>
<ul>
<li>all left-descendants of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> have a key less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key; and </li>
<li>all right-descendants of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> have a key greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key.</li>
</ul>
<div id="admonition-a-common-mistake" class="admonition admonish-warning">
<div class="admonition-title">
<p>A common mistake</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-a-common-mistake"></a></p>
</div>
<div>
<p>When you're first learning about binary search trees, it's easy to phrase the invariant wrong: </p>
<ul>
<li>the left child of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> (if any) has a key less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key; and </li>
<li>the right child of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> (if any) has a key greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key.
With experience, it's straightforward to see that this is too weak; search will break. But at first that isn't so obvious. It would be interesting if we could use Forge to help us understand the difference and its impact on searching the tree.</li>
</ul>
</div>
</div>
<p>Let's start modeling. As with programming, it's a good idea to start simple, and add complexity and optimization after. So we'll start with plain binary trees, and then add the invariant.</p>
<div id="admonition-the-recipe" class="admonition admonish-tip">
<div class="admonition-title">
<p>the recipe</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-the-recipe"></a></p>
</div>
<div>
<p>Like with tic-tac-toe, we'll follow this rough 5-step progression:</p>
<ul>
<li>define the pertinent datatypes and fields;</li>
<li>define a well-formedness predicate;</li>
<li>write some examples;</li>
<li>run and exercise the base model; </li>
<li>write domain predicates. 
Keep in mind that this isn't a strict &quot;waterfall&quot; style progression; we may return to previous steps if we discover it's necessary.</li>
</ul>
</div>
</div>
<h2 id="datatypes-1"><a class="header" href="#datatypes-1">Datatypes</a></h2>
<p>A binary tree is made up of nodes. Each node in the tree has at most one left child and at most one right child. While nodes in the tree can hold values of most any type, for simplicity we'll stick to integers. </p>
<p>Unlike in tic-tac-toe, this definition is recursive:</p>
<pre><code class="language-forge runnable">#lang forge/froglet
sig Node {
  key: one Int,     -- every node has some key 
  left: lone Node,  -- every node has at most one left-child
  right: lone Node  -- every node has at most one right-child
}
</code></pre>
<div id="admonition-teminology-reminder" class="admonition admonish-note">
<div class="admonition-title">
<p>Teminology Reminder</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-teminology-reminder"></a></p>
</div>
<div>
<p>Recall that a <code>sig</code> is a datatype, each of which may have a set of <em>fields</em>. Here, we're saying that there is a datatype called <code>Node</code>, and that every <code>Node</code> has a <code>key</code>, <code>left</code>, and <code>right</code> field.</p>
</div>
</div>
<h2 id="wellformedness-for-binary-trees"><a class="header" href="#wellformedness-for-binary-trees">Wellformedness for Binary Trees</a></h2>
<p>What makes a binary tree a binary tree? We might start by saying that: </p>
<ul>
<li>it's <em>single-tree-shaped</em>: there are no cycles and all nodes have at most one parent node; and </li>
<li>it's <em>connected</em>: all non-root nodes have a common ancestor. </li>
</ul>
<p>It's sometimes useful to write domain predicates early, and then use them to define wellformedness more clearly. For example, it might be useful to write a helper that describes what it means for a node to be a <em>root</em> node, i.e., the common ancestor of every node in the tree:</p>
<pre><code class="language-forge runnable"><span class="boring">#lang forge/froglet
</span><span class="boring">sig Node {
</span><span class="boring">  key: one Int,     -- every node has some key 
</span><span class="boring">  left: lone Node,  -- every node has at most one left-child
</span><span class="boring">  right: lone Node  -- every node has at most one right-child
</span><span class="boring">}
</span><span class="boring">
</span>pred isRoot[n: Node] {
  -- a node is a root if it has no ancestor
  no n2: Node | n = n2.left or n = n2.right
}
</code></pre>
<p>Then we'll use the <code>isRoot</code> helper in our <code>wellformed</code> predicate. But to write this predicate, there's a new challenge. We'll need to express constraints like &quot;no node can reach itself via <code>left</code> or <code>right</code> fields&quot;. So far we've only spoken of a node's <em>immediate left or right child</em>. Instead, we now need a way to talk about <em>reachability</em> over any number of <code>left</code> or <code>right</code> fields. Forge provides a helper, <code>reachable</code>, that makes this straightforward.</p>
<div id="admonition-the-reachable-built-in" class="admonition admonish-tip">
<div class="admonition-title">
<p>The <code>reachable</code> built-in</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-the-reachable-built-in"></a></p>
</div>
<div>
<p>The built-in <code>reachable</code> predicate returns true if and only if its first argument is reachable from its second argument, via all of the remaining arguments. Thus, <code>reachable[n1, anc, left, right]</code> means: &quot;<code>anc</code> can reach <code>n1</code> via some sequence of <code>left</code> and <code>right</code> fields.&quot;</p>
<p>For reasons we'll explore later, <code>reachable</code> can be subtle; if you're curious now, see the <a href="chapters/bst/../qna/static.html">Static Models Q&amp;A</a> for a discussion of this.</p>
</div>
</div>
<p>Using <code>reachable</code>, we can now write:</p>
<pre><code class="language-forge editable">pred wellformed {
  -- no cycles: no node can reach itself via a succession of left and right fields
  all n: Node | not reachable[n, n, left, right] 
  
  -- all non-root nodes have a common ancestor from which both are reachable
  -- the &quot;disj&quot; keyword means that n1 and n2 must be _different_
  all disj n1, n2: Node | (not isRoot[n1] and not isRoot[n2]) implies {
    some anc: Node | reachable[n1, anc, left, right] and 
                     reachable[n2, anc, left, right] }

  -- nodes have a unique parent (if any)
  all disj n1, n2, n3: Node | 
    not ((n1.left = n3 or n1.right = n3) and (n2.left = n3 or n2.right = n3))
}
</code></pre>
<h2 id="write-an-example-or-two"><a class="header" href="#write-an-example-or-two">Write an example or two</a></h2>
<p>Let's write a few examples of well-formed and non-well-formed trees. I've listed some possibilities below.</p>
<div id="admonition-are-these-examples-enough" class="admonition admonish-note">
<div class="admonition-title">
<p>Are these examples enough?</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-are-these-examples-enough"></a></p>
</div>
<div>
<p>Just like with testing a program, it's not always immediately clear when to <em>stop</em> testing a model. 
Fortunately, Forge gives us the ability to explore and exercise the model more thoroughly than just 
running a program does. So, while we're not completely out of danger, we do have new tools to protect
ourselves with.</p>
</div>
</div>
<h3 id="positive-examples"><a class="header" href="#positive-examples">Positive examples</a></h3>
<h4 id="a-binary-tree-with-no-nodes-should-be-considered-well-formed"><a class="header" href="#a-binary-tree-with-no-nodes-should-be-considered-well-formed">A binary tree with no nodes should be considered well-formed.</a></h4>
<pre><code class="language-forge editable">example p_no_nodes is wellformed for {
  no Node  -- there are no nodes in the tree; it is empty
}
</code></pre>
<p>Drawing this one wouldn't be very interesting.</p>
<h4 id="a-binary-tree-with-a-single-node-should-be-considered-well-formed"><a class="header" href="#a-binary-tree-with-a-single-node-should-be-considered-well-formed">A binary tree with a single node should be considered well-formed.</a></h4>
<pre><code class="language-forge editable">example p_one_nodes is wellformed for {
  Node = `Node0 -- there is exactly one node in the tree, named &quot;Node0&quot;.
  no left       -- there are no left-children
  no right      -- there are no right-children
}
</code></pre>
<p>If we were going to draw the single-node example, we might draw it something like this:</p>
<img alt="a tree with a single node and no edges" src="chapters/bst/./p_one_nodes.png" width=60%/>
<p>In fact, this is what Forge's default visualizer can generate. Notice that the node has:</p>
<ul>
<li>a <em>name</em> or identity, which we supplied when we named it <code>Node0</code> in the example; and </li>
<li>a value for its <code>key</code> field, which we did not supply (and so Forge filled in). 
Be careful not to confuse these! There's a rough analogy to programming: it's very possible that (especially if we have a buggy program or model) there might be different nodes with the same key value.</li>
</ul>
<p><strong>(TODO: decide: discussion of partial vs. total examples goes where?)</strong></p>
<h4 id="a-binary-tree-with-more-than-one-row-should-be-considered-well-formed"><a class="header" href="#a-binary-tree-with-more-than-one-row-should-be-considered-well-formed">A binary tree with more than one row should be considered well-formed.</a></h4>
<pre><code class="language-forge editable">example p_multi_row is wellformed for {
  Node = `Node0 +                               -- row 0
         `Node1 + `Node2 +                      -- row 1
         `Node3 + `Node4 + `Node5 + `Node6      -- row 2
  
  -- Define the child relationships (and lack thereof, for leaves)
  -- This is a bit verbose; we'll learn more concise syntax for this soon!
  `Node0.left = `Node1 
  `Node0.right = `Node2
  `Node1.left = `Node3
  `Node1.right = `Node4
  `Node2.left = `Node5
  `Node2.right = `Node6
  no `Node3.left  no `Node3.right 
  no `Node4.left  no `Node4.right 
  no `Node5.left  no `Node5.right 
  no `Node6.left  no `Node6.right 
}
</code></pre>
<center>
<img alt="a tree with more than one row" src="chapters/bst/./p_multi_row.png" width=60%/>
</center>
<p>Wait a moment; there's something strange here. What do you notice about the way we've visualized this tree? </p>
<details> 
<summary>Think, then click!</summary>
<p>That visualization is not how we'd choose to draw the tree: it has the <code>left</code> field to the right and the <code>right</code> field to the left! This is because we used Forge's default visualizer. By default, Forge has no way to understand what &quot;left&quot; and &quot;right&quot; mean. We'll come back to this problem soon. </p>
</details>
<h4 id="an-unbalanced-binary-tree-is-still-well-formed"><a class="header" href="#an-unbalanced-binary-tree-is-still-well-formed">An unbalanced binary tree is still well-formed.</a></h4>
<p>When we draw binary trees, often we draw them in a <em>balanced</em> way: nice and &quot;bushy&quot;, with roughly even distribution of nodes to the left and right. But an unbalanced tree is still a tree, and we should make sure it counts as one.</p>
<pre><code class="language-forge editable">example p_unbalanced_chain is wellformed for {
  Node = `Node0 + `Node1 + `Node2 + `Node3
  
  -- Form a long chain; it is still a binary tree.
  `Node0.left = `Node1 
  no `Node0.right 
  `Node1.left = `Node2
  no `Node1.right
  `Node2.left = `Node3
  no `Node2.right 
  
  no `Node3.left  no `Node3.right 
}
</code></pre>
<center>
<img alt="an unbalanced chain is still a tree" src="chapters/bst/./p_unbalanced_chain.png" width=50%/>
</center>
<h3 id="negative-examples"><a class="header" href="#negative-examples">Negative examples</a></h3>
<p>It's best to write some positive <em>and</em> negative examples. Why? Well, suppose you needed to test a method or function that returned a boolean, like checking whether an integer is even. Here's an example in Python:</p>
<pre><code class="language-python">def is_even(x: int) -&gt; bool: return x % 2 == 0
</code></pre>
<p>What's wrong with this test suite? </p>
<pre><code class="language-python">assert is_even(0) == True 
assert is_even(2) == True 
assert is_even(10000) == True 
assert is_even(-10000) == True 
</code></pre>
<p>The problem isn't only the <em>size</em> of the suite! By testing only values for which we expect <code>True</code> to be returned, we're neglecting half the problem. We'd never catch buggy implementations like this one:</p>
<pre><code class="language-python">def is_even(x: int) -&gt; bool: return True
</code></pre>
<p>Forge predicates are very like boolean-valued functions, so it's important to exercise them in both directions. Here are some negative examples:</p>
<h4 id="a-single-node-that-is-its-own-left-child-is-not-well-formed"><a class="header" href="#a-single-node-that-is-its-own-left-child-is-not-well-formed">A single node that is its own left-child is not well-formed.</a></h4>
<pre><code class="language-forge editable">example n_own_left is {not wellformed} for {
  Node = `Node0 
  `Node0.left = `Node0
  no `Node0.right
}
</code></pre>
<img alt="a node that is its own left child" src="chapters/bst/./n_own_left.png" width=60%/>
<h4 id="a-single-node-that-is-its-own-right-child-is-not-well-formed"><a class="header" href="#a-single-node-that-is-its-own-right-child-is-not-well-formed">A single node that is its own right-child is not well-formed.</a></h4>
<pre><code class="language-forge editable">example n_own_right is {not wellformed} for {
  Node = `Node0 
  no `Node0.left
  `Node0.right = `Node0
}
</code></pre>
<img alt="a node that is its own right child" src="chapters/bst/./n_own_right.png" width=60%/>
<h4 id="a-single-node-thats-reachable-via-a-longer-cycle-using-both-left--and-right-children-is-not-well-formed"><a class="header" href="#a-single-node-thats-reachable-via-a-longer-cycle-using-both-left--and-right-children-is-not-well-formed">A single node that's reachable via a longer cycle using both left- and right-children is not well-formed.</a></h4>
<pre><code class="language-forge editable">example n_mixed_cycle is {not wellformed} for {
  Node = `Node0 + `Node1 + `Node2
  
  `Node0.left = `Node1 
  no `Node0.right 
  no `Node1.left
  `Node1.right = `Node2
  
  `Node2.left = `Node0
  no `Node2.right 
}
</code></pre>
<img alt="a cycle using both left and right" src="chapters/bst/./n_mixed_cycle.png" width=60%/>
<h4 id="a-forest-of-multiple-disconnected-trees-is-not-well-formed"><a class="header" href="#a-forest-of-multiple-disconnected-trees-is-not-well-formed">A &quot;forest&quot; of multiple, disconnected trees is not well-formed.</a></h4>
<pre><code class="language-forge editable">example n_forest is {not wellformed} for {
  Node = `Node0 + `Node1
  no `Node0.left
  no `Node0.right 
  no `Node1.left 
  no `Node1.right 
}
</code></pre>
<img alt="a forest, not a single tree" src="chapters/bst/./n_forest.png" width=60%/>
<div id="admonition-sometimes-it-helps-to-_start_-with-an-example" class="admonition admonish-note">
<div class="admonition-title">
<p>Sometimes it helps to <em>start</em> with an example.</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-sometimes-it-helps-to-_start_-with-an-example"></a></p>
</div>
<div>
<p>We wouldn't normally be able to <em>check</em> these examples until we'd finished writing the <code>wellformed</code> predicate, but it can still be useful to create a few examples first, to help guide the constraints you write. Binary trees are a quite simple domain; imagine modeling something like the Java class system. Things can get tricky fast, and it's good to have a few concrete cases in mind.</p>
</div>
</div>
<h3 id="run-the-examples"><a class="header" href="#run-the-examples">Run the examples</a></h3>
<p>Click the run button, and Forge will check that all of the examples satisfy (or dissatisfy) the <code>wellformed</code> predicate. One fails, but why? Notice two things:</p>
<ul>
<li>The failing example is a <em>negative</em> one. We expected this instance to be ruled out by <code>wellformed</code>, but it was not. This points to a potential <em>under</em>-constraint bug in <code>wellformed</code>. </li>
<li>We intended the example to fail because it contains separate, disconnected trees. This gives us a hint about the nature of the missing constraint. Except...</li>
</ul>
<p>We already added a constraint that forces connectivity. Didn't we? </p>
<pre><code class="language-forge editable">  all disj n1, n2: Node | (not isRoot[n1] and not isRoot[n2]) implies {
    some anc: Node | reachable[n1, anc, left, right] and 
                     reachable[n2, anc, left, right] }
</code></pre>
<p>So what's the problem? </p>
<details>
<summary>Think, then click!</summary>
<p>This constraint only applies for pairs of <em>non-root</em> nodes. That is, any two non-root nodes must have a common parent. So we ruled out forests of separate, bushy <em>trees</em>, but we neglected to exclude isolated roots!</p>
</details>
<hr />
<p>In modeling, it's common for there to be a few ways to fix problems like this. We could go back and edit the constraint we wrote before, or we could write a new constraint to handle roots. In <em>this</em> case, let's edit the original. We said that any two non-roots have a common ancestor. Why did we say &quot;non-root&quot;? Because if one of the nodes happened to be a root, it would have no such ancestors. </p>
<p>What if we allowed the node itself to count as the common ancestor? Then we would have two obligations (as before), but each would have another way to become true. </p>
<pre><code class="language-forge editable">  -- for _any_ pair of nodes, there is some ancestor node, such that...
  all disj n1, n2: Node | {
    some anc: Node | { 
      -- either n1 is the ancestor itself, or the ancestor reaches n1...
      ((n1 = anc) or reachable[n1, anc, left, right])
      -- ...and either n2 is the ancestor itself, or the ancestor reaches n2
      ((n2 = anc) or reachable[n2, anc, left, right]) 
    } }
</code></pre>
<p>Now all of our examples pass. While that doesn't mean the constraints are exactly right yet, it does increase our confidence in them. </p>
<h2 id="view-some-instances"><a class="header" href="#view-some-instances">View some instances</a></h2>
<p>Before we move on, let's at least look at some new instances of <code>wellformed</code>, as generated by Forge. By viewing a few of these, we can often spot issues in the initial stages of a model. </p>
<pre><code>-- View a tree or two
run {wellformed} for exactly 8 Node
</code></pre>
<!-- Note: custom visualization is _bad_ for this, because it may hide the problem due to 
     structural assumptions it makes. -->
<p>The <code>run</code> command searches for instances that satisfy the constraints it is given, and then automatically opens the visualizer to explore those instances. </p>
<div id="admonition-visualization" class="admonition admonish-tip">
<div class="admonition-title">
<p>Visualization</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-visualization"></a></p>
</div>
<div>
<p>By default, the visualizer will show nearly all relationships as arcs; e.g., the <code>key</code> field of each node will be shown as an arc from the node to the (numeric) key. If you want, you can clean this up a bit by opening the <code>Theme</code> drawer, selecting the <code>key</code> field, and checking to view the field as an attribute.</p>
</div>
</div>
<p>Here's something you might see in one of the instances:</p>
<p><img src="chapters/bst/same-left-right.png" alt="A fragment of an instance visualization, showing a node whose left and right children are the same" /></p>
<p>This doesn't look right, does it? We have a node whose left and right child are the same; that's not tree-like. Again, we have an <em>under</em>-constraint bug: there's some instance(s) that are permitted by <code>wellformed</code>, but shouldn't be. In fact, we completely forgot to add a constraint like:</p>
<pre><code class="language-forge editable">  -- left+right differ (unless both are empty)
  all n: Node | some n.left =&gt; n.left != n.right 
</code></pre>
<p>With that constraint added to <code>wellformed</code>, we don't see any more wrong-looking binary trees.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>So far we've tested our model in two ways:</p>
<ul>
<li>checking that specific instances satisfy, or don't satisfy, a Forge predicate; and </li>
<li>manually viewing generated instances. 
In Forge, we have recourse to more powerful techniques. </li>
</ul>
<p>Notice that, when we were writing <code>binary_tree</code>, we never said explicitly that there must be a single unique root in the instance. It should be true, of course, that such a root exists and is unique. But that is (or should be!) a <em>consequence</em> of what we wrote. In Forge, this is easy to test:</p>
<pre><code class="language-forge editable">-- Run a test: our predicate enforces a unique root exists (if any node exists)
pred unique_root {   
  no Node or {
    one root: Node | 
      all other: Node-root | other in descendantsOf[root]}}
assert binary_tree is sufficient for unique_root for 5 Node  
</code></pre>
<p>This passes; there is no counterexample using fewer than than 6 Nodes. Our confidence increases.</p>
<div id="admonition-different-ways-of-writing-predicates" class="admonition admonish-note">
<div class="admonition-title">
<p>Different ways of writing predicates</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-different-ways-of-writing-predicates"></a></p>
</div>
<div>
<p>You might be thinking that we could have just added the unique-root property as a constraint to <code>wellformed</code> directly! That's a reasonable thought, and it's true that we could have. I left it out deliberately here, for a few reasons:</p>
<ul>
<li>It's usually a good idea to not overload predicates with constraints that are really unnecessary. There's some wiggle room here in the service of making your model robust, but if we had added every possible property we could think of for a tree to have, the predicate would have become quite unwieldy, harder to understand, and (vitally) harder to debug. </li>
<li>When we start modeling, we often don't know exactly what we want. Sure, we might be able to describe it in broad terms, but 
and, of course...</li>
<li>it allowed demonstration of this general technique: checking that one predicate enforces another.</li>
</ul>
</div>
</div>
<p>Now our model is looking pretty good, although we haven't yet added the &quot;search&quot; part of &quot;binary search tree&quot;.</p>
<h2 id="more-domain-predicates-search-invariants"><a class="header" href="#more-domain-predicates-search-invariants">More Domain Predicates: Search Invariants</a></h2>
<p>Let's express our two alternative BST invariants. As a reminder, they were: </p>
<p><strong>Version 1</strong> For all nodes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>:</p>
<ul>
<li>all left-descendants of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> have a key less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key; and </li>
<li>all right-descendants of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> have a key greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key.</li>
</ul>
<p><strong>Version 2</strong> For all nodes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>:</p>
<ul>
<li>the left child of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> (if any) has a key less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key; and </li>
<li>the right child of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> (if any) has a key greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key.</li>
</ul>
<p>Notice that both are phrased in terms of single nodes, and should apply to all nodes. For convenience, we'll split these up into 2 predicates each: one to represent the per-node requirement, and another to represent the global requirement. </p>
<pre><code class="language-forge editable">pred invariant_v1[n: Node] {
  -- &quot;Every node's left-descendants...&quot; (if any)
  some n.left =&gt; {
    n.left.key &lt; n.key
    all d: Node | reachable[d, n.left, left, right] =&gt; d.key &lt; n.key
  }
  -- &quot;Every node's right-descendants...&quot; (if any)
  some n.right =&gt; {
    n.right.key &lt; n.key
    all d: Node | reachable[d, n.right, left, right] =&gt; d.key &gt; n.key
  }
}
pred binary_search_tree_v1 {
  binary_tree  -- a binary tree, with an added invariant
  all n: Node | invariant_v1[n]  
}
</code></pre>
<p>Here's the same pair of predicates for the second (<em>wrong</em>) invariant:</p>
<pre><code class="language-forge editable">pred invariant_v2[n: Node] {
  -- &quot;Every node's immediate children...&quot;
  some n.left implies n.left.key &lt; n.key
  some n.right implies n.right.key &gt; n.key
}
pred binary_search_tree_v2 {
  binary_tree  -- a binary tree, with an added invariant
  all n: Node | invariant_v2[n]
}
</code></pre>
<h3 id="semantic-differencing"><a class="header" href="#semantic-differencing">Semantic Differencing</a></h3>
<p>Forge supports a useful trick: comparing the <em>meaning</em> of two different predicates. What do we mean by &quot;meaning&quot;? Suppose that we ran <code>diff</code> on the two versions above. We'd get a report of where the <em>text</em> of the two differed. But that isn't very informative; we'd really like to know <em>which actual binary trees</em> the two disagree on. That's a better way of understanding how the meaning of the two might differ, and start to grasp the consequences. </p>
<pre><code class="language-forge editable">-- Get examples of the difference between the two. Here we name the run &quot;bstdiff&quot;.
bstdiff: run {not { binary_search_tree_v1 iff binary_search_tree_v2}} for 5 Node 
-- But how do they differ? We'd expect the first invariant to be _stronger_ than the second:
v1_is_stronger: assert binary_search_tree_v1 is sufficient for binary_search_tree_v2 for 5 Node 
</code></pre>
<p>The <code>v1_is_strong</code> test passes. The <code>run</code> command produces an instance (actually many) where the two invariants disagree. The test, however, passes, indicating that version 1 is strictly more selective than version 2: no matter how many times we clicked &quot;Next&quot;, we'd only see trees where <code>binary_search_tree_v2</code> is satisfied but <code>binary_search_tree_v1</code> isn't.</p>
<div id="admonition-differencing-for-debugging" class="admonition admonish-tip">
<div class="admonition-title">
<p>Differencing for Debugging</p>
<p><a class="admonition-anchor-link" href="chapters/bst/bst.html#admonition-differencing-for-debugging"></a></p>
</div>
<div>
<p>This simple technique really is powerful. You might use it to check whether two versions of the same constraint are equivalent when debugging or optimizing your model. <strong>We'll use this idea in a few examples later, too.</strong></p>
</div>
</div>
<p>We'll return to binary search trees soon, to model how the recursive descent search works. That will let us see how the different invariants impact the correctness of search. But first, let's get a bit more experience with Forge.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ripple-carry-adder"><a class="header" href="#ripple-carry-adder">Ripple-Carry Adder</a></h1>
<p>Let's model a third system in Froglet. We'll focus on something even more concrete, something that is implemented in <em>hardware</em>: a circuit for adding together two numbers called a <em>ripple-carry adder</em> (RCA). Along the way, even though the adder doesn't &quot;change&quot;, we'll still learn a useful technique for modeling systems that change over time. </p>
<p>To understand an RCA, let's first think about adding together a pair of one-bit numbers. We might draw a table with four rows to represent this:</p>
<div class="table-wrapper"><table><thead><tr><th>Input Bit A</th><th>Input Bit B</th><th>Result Bit</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>2</td></tr>
</tbody></table>
</div>
<p>But, wait a moment. If we're building this into a circuit, and these inputs and outputs are single bits, we can't return <code>2</code> as the result. Similarly to how we might manually add <code>12345</code> and <code>67890</code> on paper, carrying a <code>1</code> in a few places...</p>
<center><img width="50%" src="chapters/adder/./Addition.png" style="background-color:white"/></center>
<p>Notice how, on paper, we sweep from right to left. That is, we handle the least-significant digits first. </p>
<p><strong>Exercise:</strong> Why is that? (Your first answer may be: &quot;Because that's how you do it.&quot; But hold yourself to a higher standard. Was there a good reason to start on the right, and move left, rather than the other way around?)</p>
<details>
<summary>Think, then click!</summary>
<p>Carrying! If we started to the left, we'd give answers for those digits prematurely. (To see this, try doing the above arithmetic by hand again, but starting on the left and moving right. You'll need to carry, as before, but it will be <em>too late!</em>)</p>
</details>
<hr />
<p>We need to carry a bit with value <code>1</code> in the <code>2s</code> place.</p>
<div class="table-wrapper"><table><thead><tr><th>Input Bit A</th><th>Input Bit B</th><th>Result Bit</th><th>Carry Bit (double value!)</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>Suppose we've built a circuit like the above; this is called a <em>full adder</em> (FullAdder).</p>
<div id="admonition-building-circuits" class="admonition admonish-note">
<div class="admonition-title">
<p>Building circuits</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-building-circuits"></a></p>
</div>
<div>
<p>Exactly how we build that circuit is outside the scope of this example. Generally, we build them with logic gates: tiny devices that implement boolean operators like &quot;and&quot;, &quot;not&quot;, etc.</p>
</div>
</div>
<p>Now the question is: how do we build an adder that can handle numbers of the sizes that real computers use: 8-bit, 32-bit, or even 64-bit values? The answer is that we'll chain together multiple adder circuits like the above, letting the carry bits &quot;ripple&quot; forward as an extra, 3rd input to all the adders except the first one. E.g., if we were adding together a pair of 4-bit numbers—4 and 5, say—we'd chain together 4 adders like so:</p>
<center><img width="70%" src="chapters/adder/./rca.svg" style="background-color:white"/></center>
<p>Notice that each full adder accepts <em>3</em> input bits, just like in the above table: </p>
<ul>
<li>a bit from the first number;</li>
<li>a bit from the second number; and</li>
<li>a carry bit.</li>
</ul>
<p>Each full adder has <em>2</em> output bits:</p>
<ul>
<li>the value at this bit (1s place, 2s place, etc.); and </li>
<li>the carry bit, if applicable.</li>
</ul>
<p>Our task here is to model this circuit in Forge, and confirm that it actually works correctly. </p>
<div id="admonition-circuits-arent-easy" class="admonition admonish-note">
<div class="admonition-title">
<p>Circuits aren't easy</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-circuits-arent-easy"></a></p>
</div>
<div>
<p>This might look &quot;obvious&quot;, but there are things that can go wrong even at this level. </p>
<p>If you've studied physics or electrical engineering, you might also see that this model won't match reality: it takes <em>time</em> for the signals to propagate between adders, and this delay can cause serious problems if the chain of adders is too long. We'll address that with a new, more sophisticated model, later.</p>
</div>
</div>
<h2 id="datatypes-2"><a class="header" href="#datatypes-2">Datatypes</a></h2>
<p>We'll start by defining a data type—<code>Digit</code>—for the wire values, which can be either <code>T</code> or <code>F</code> (short for &quot;true&quot; and &quot;false&quot;; you can also think of these as representing &quot;1&quot; and &quot;0&quot; or &quot;high&quot; and &quot;low&quot;).</p>
<pre><code class="language-forge editable">abstract sig Digit {}
one sig T, F extends Digit {}
</code></pre>
<p>Then we'll define a <code>sig</code> for full adders, which will be chained together to form the ripple-carry adder. We'll give each full adder fields representing its input bits and output bits:</p>
<pre><code class="language-forge editable">sig FullAdder { 
  -- input value bits 
  a_in, b_in: one Digit,  
  -- input carry bit
  carry_in: one Digit,
  -- output (sum) value
  sum_out: one Digit,
  -- output carry bit 
  carry_out: one Digit
}
</code></pre>
<div id="admonition-digit-is-not-the-same-as-boolean" class="admonition admonish-warning">
<div class="admonition-title">
<p><code>Digit</code> is not the same as boolean!</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-digit-is-not-the-same-as-boolean"></a></p>
</div>
<div>
<p>Beware confusing the <code>Digit</code> sig we created, and the <code>T</code> and <code>F</code> values in it, with the result of evaluating Forge constraints. Forge doesn't &quot;know&quot; anything special about <code>T</code> or <code>F</code>; <code>Digit</code> is just another datatype. <strong>If we write something like <code>(some FullAdder) = T</code>, Forge will give an error message.</strong> This is because, to Forge, <code>T</code> is just another value we defined in the model. Instead, we write just <code>(some FullAdder)</code> to say &quot;there is some full adder in the instance&quot;. </p>
<p>This will come up again as we continue to develop the model.</p>
</div>
</div>
<p>Finally, we'll define the ripple-carry adder chain:</p>
<pre><code class="language-forge editable">one sig RCA {
  -- the first full adder in the chain
  firstAdder: one FullAdder,
  -- the next full adder in the chain (if any)
  nextAdder: pfunc FullAdder -&gt; FullAdder
}
</code></pre>
<div id="admonition-reminder" class="admonition admonish-note">
<div class="admonition-title">
<p>Reminder</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-reminder"></a></p>
</div>
<div>
<p>Recall that a <code>pfunc</code> field is a partial function, sort of like a dictionary: every input is mapped to at most one output.</p>
</div>
</div>
<p>Notice that there is only ever one ripple-carry adder in an instance, and that it has fields that define which full adder comes first (i.e., operates on the <code>1</code>s place), and what the succession is. We will probably need to enforce what these mean once we start defining wellformedness. </p>
<h2 id="wellformedness"><a class="header" href="#wellformedness">Wellformedness</a></h2>
<p>What do we need to encode in a <code>wellformed</code> predicate? Right now, it seems that nothing has told Forge that <code>firstAdder</code> should really <em>be</em> the first adder, nor that <code>nextAdder</code> defines a linear path through all the full adders. So we should probably start with those two facts. </p>
<pre><code class="language-forge editable">pred wellformed {
  -- The RCA's firstAdder is &quot;upstream&quot; from all other FullAdders
  all fa: FullAdder | (fa != RCA.firstAdder) implies reachable[fa, RCA.firstAdder, RCA.nextAdder]
  -- there are no cycles in the nextAdder function.
  all fa: FullAdder | not reachable[fa, fa, RCA.nextAdder]  
}
</code></pre>
<p>Notice that we've used <code>implies</code> to limit the power of the <code>all</code> quantifier: it doesn't impose the reachability condition on <em>all</em> <code>FullAdder</code>s, but rather than all of them except for <code>RCA.firstAdder</code>. This is a common pattern when you want to assert something is true, but only contingently. </p>
<div id="admonition-case-sensitivity-and-variable-names" class="admonition admonish-tip">
<div class="admonition-title">
<p>Case sensitivity and variable names</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-case-sensitivity-and-variable-names"></a></p>
</div>
<div>
<p>In our model so far, <code>FullAdder</code> is the name of a datatype. When writing the constraints above, I said: &quot;for every full adder...&quot; and named this arbitrary adder <code>fa</code>. These two, <code>FullAdder</code> and <code>fa</code> are different. For a start, <code>FullAdder</code> is defined within the entire model, but <code>fa</code> is only defined within the scope of the <code>all</code> quantifier.</p>
</div>
</div>
<p>We've used the <code>reachable</code> helper before, but it's worth mentioning again: <code>A</code> is reachable from <code>B</code> via <em>one or more applications</em> of <code>f</code> if and only if <code>reachable[A, B, f]</code> is true. That &quot;one or more applications&quot; is important, and is why we needed to add the <code>(fa != RCA.firstAdder) implies</code> portion of the first constraint: <code>RCA.firstAdder</code> shouldn't be the successor of any full adder, and if it were its own successor, that would be a cycle in the line of adders. If we had left out the implication, and written just <code>all fa: FullAdder | reachable[fa, RCA.firstAdder, RCA.nextAdder]</code>, <code>RCA.firstAdder</code> would need to have a predecessor, which would contradict the second constraint.</p>
<h2 id="more-predicates"><a class="header" href="#more-predicates">More Predicates</a></h2>
<p>Before we write some examples for <code>wellformed</code>, let's also try to model how each adder should behave, given that it's wired up to other adders in this specific order. Let's write a couple of helpers first, and then combine them to describe the behavior of each adder, given its place in the sequence.</p>
<h3 id="when-is-an-adders-output-bit-set-to-true"><a class="header" href="#when-is-an-adders-output-bit-set-to-true">When is an adder's output bit set to true?</a></h3>
<p>Just like <code>pred</code>icates can be used as boolean-valued helpers, <code>fun</code>ctions can act as helpers for arbitrary return types. Let's try to write one that says what the <em>output</em> bit should be for a specific full adder, given its input bits. </p>
<pre><code class="language-forge">// Helper function: what is the output sum bit for this full adder?
fun adder_S_RCA[f: one FullAdder]: one Digit  {
  // Our job is to fill this in with an expression for the output sum bit
} 
</code></pre>
<p>Looking at the table above, the adder's output value is true if and only if an odd number of its 3 inputs is true. That gives us 4 combinations:</p>
<ul>
<li><code>A</code>, <code>B</code>, and <code>CIN</code> (all 3 are true);</li>
<li><code>A</code> only (1 is true); </li>
<li><code>B</code> only (1 is true); or</li>
<li><code>CIN</code> only (1 is true). </li>
</ul>
<p>This is where we need to remember that the sig <code>T</code> is not a Forge formula yet; to make it into one, we need to explicitly test whether each value is equal to <code>T</code>. We'll use two new Forge constructs to write the function body:</p>
<ul>
<li>The <code>let</code> construct makes it easier to write the value for each of these wires. A <code>let</code> looks similar to a quantifier, but it only introduces some local helper syntax. If I write <code>let A = (f.a_in = T) | ...</code>, I can then use <code>A</code> in place of the tedious <code>(f.a_in = T)</code>. </li>
<li>Expression if-then-else lets us produce a value based on a condition, sort of like the <code>C ? X : Y</code> operator in languages like JavaScript. If I write something like <code>(A and B and C) =&gt; T else F</code> this evaluates to <code>T</code> whenever <code>A</code>, <code>B</code>, and <code>C</code> are all true, and <code>F</code> otherwise.</li>
</ul>
<p>Now we can write:</p>
<pre><code class="language-forge">// Helper function: what is the output bit for this full adder?
fun adder_S_RCA[f: one FullAdder]: one Digit  {
  // &quot;T&quot; and &quot;F&quot; are values, we cannot use them as Forge formulas. 
  let A = (f.a_in = T), B = (f.b_in = T), CIN = (f.carry_in = T) |
   -- Expression if-then-else: if any of these conditions holds...
	 ((     A  and      B  and      CIN)  or 
    (     A  and (not B) and (not CIN)) or 
    ((not A) and      B  and (not CIN)) or 
    ((not A) and (not B) and      CIN))
      -- ...then T...
	 	  =&gt;   T
      -- ...otherwise F.
      else F
} 
</code></pre>
<div id="admonition-couldnt-we-have-just-used-a-pred-here" class="admonition admonish-tip">
<div class="admonition-title">
<p>Couldn't we have just used a <code>pred</code> here?</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-couldnt-we-have-just-used-a-pred-here"></a></p>
</div>
<div>
<p>It might be a bit strange to write a helper function that returns a <code>Digit</code>, rather than a predicate directly. We could make a <code>pred</code> work, but we'd still have to eventually use <code>T</code> and <code>F</code> somewhere, since they are the values that the output bits can take on.</p>
</div>
</div>
<div id="admonition-is-the-blank-space-in-that-example-significant" class="admonition admonish-note">
<div class="admonition-title">
<p>Is the blank space in that example significant?</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-is-the-blank-space-in-that-example-significant"></a></p>
</div>
<div>
<p>Nope. I added it for clarity, because it's much harder to read without the extra space to make it apparent where the <code>not</code>s are applied. Likewise, you don't need to wrap a negation in parentheses; I just think <code>(not A)</code> is clearer than <code>not A</code> in this sort of big expression.</p>
</div>
</div>
<div id="admonition-implies-and-expression-if-then-else" class="admonition admonish-tip">
<div class="admonition-title">
<p>Implies and expression if-then-else</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-implies-and-expression-if-then-else"></a></p>
</div>
<div>
<p>You can also write <code>implies</code> as <code>=&gt;</code>. Indeed, the two keywords (<code>=&gt;</code> and <code>implies</code>) are interchangeable in Forge! To avoid confusion, always ask yourself whether you are trying to identify a <em>thing</em> in an instance, like a full-adder atom or an integer, or write a <em>constraint</em> which may or may not be true in an instance.</p>
</div>
</div>
<h3 id="when-is-an-adders-carry-bit-set-to-true"><a class="header" href="#when-is-an-adders-carry-bit-set-to-true">When is an adder's carry bit set to true?</a></h3>
<p>This one is quite similar. The carry bit is set to true if and only if 2 or 3 of the adder's inputs are true:</p>
<ul>
<li><code>B</code> and <code>CIN</code> (2 are true);</li>
<li><code>A</code> and <code>CIN</code> (2 are true); </li>
<li><code>C</code> and <code>CIN</code> (2 are true); or</li>
<li><code>A</code>, <code>B</code>, and <code>CIN</code> (all 3 are true). 
As before, we'll use <code>let</code> and expression if-then-else, and add (decorative) blank space to make the function more readable.</li>
</ul>
<pre><code class="language-forge">// Helper function: what is the output carry bit for this full adder?
fun adder_cout_RCA[f: one FullAdder]: one Digit {
 let A = (f.a_in = T), B = (f.b_in = T), CIN = (f.carry_in = T) |
     (((not A) and      B  and      CIN) or 
      (     A  and (not B) and      CIN) or 
      (     A  and      B  and (not CIN)) or 
      (     A  and      B  and      CIN)) 
	      =&gt;   T
        else F
} 
</code></pre>
<h3 id="adder-behavior"><a class="header" href="#adder-behavior">Adder Behavior</a></h3>
<p>Finally, what ought an adder's behavior to be? Well, we need to specify its output bits in terms of its input bits. We'll also add a constraint that says the full adders are connected in a line. More concretely, if there <em>is</em> a successor, its input carry bit is equal to the current adder's output carry bit. Here's a picture of what we want to say:</p>
<p><strong>TODO: fill picture</strong></p>
<p>And here's the Forge predicate:</p>
<pre><code class="language-forge">pred fullAdderBehavior[f: FullAdder] {
  -- Each full adder's outputs are as expected
  f.sum_out = adder_S_RCA[f]
  f.carry_out = adder_cout_RCA[f]
  -- Full adders are chained appropriately
  (some RCA.nextAdder[f]) implies (RCA.nextAdder[f]).carry_in = f.carry_out 
}
</code></pre>
<div id="admonition-wouldnt-it-be-better-to-put-the-carry-bit-connection-in-wellformed-or-somewhere-else" class="admonition admonish-note">
<div class="admonition-title">
<p>Wouldn't it be better to put the carry-bit connection in <code>wellformed</code>, or somewhere else?</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-wouldnt-it-be-better-to-put-the-carry-bit-connection-in-wellformed-or-somewhere-else"></a></p>
</div>
<div>
<p>That's a good point. The values of <code>f.sum_out</code> and <code>f.carry_out</code> are part of the full adder's behavior, but the way the wires are connected in <code>RCA.nextAdder</code> is not. </p>
<p>If I were going to re-write this model, I would probably move that line into somewhere that is responsible for <em>connecting</em> the adders: perhaps a predicate for the ripple-carry adder. But I haven't done that—hoping to provoke just this question!</p>
<p>The general design principle here is to think about <em>compositionality and reuse</em>: we'd like to be able to use the same predicates to reason about full adders by themselves, or what would happen if we connected them differently. As written, the <code>fullAdderBehavior</code> predicate doesn't allow for that; we'd have to refactor it. But I'll leave that as an exercise for now.</p>
</div>
</div>
<p>Finally, we'll make a predicate that describes the behavior of the overall ripple-carry adder: </p>
<pre><code>// Top-level system specification: compose preds above
pred rca {  
  wellformed
  all f: FullAdder | fullAdderBehavior[f] 
}
</code></pre>
<div id="admonition-notice-what-weve-done" class="admonition admonish-note">
<div class="admonition-title">
<p>Notice what we've done.</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-notice-what-weve-done"></a></p>
</div>
<div>
<p>Here's something to keep in mind for when we start the next chapter. By wiring together full adders into a sequence via the <code>rca</code> predicate, we are now implicitly hinting at time in our model: signal flows through each adder, in order, over time. We'll re-use this same technique in the next chapter to combine different system states into a succession of them that represents a complete run of the system.</p>
</div>
</div>
<p>Now we're ready to write some examples. We'll make a pair of examples for <code>wellformed</code> and an overall example for the full system. In practice, we'd probably want to write a couple of examples for <code>fullAdderBehavior</code> as well, but we'll leave those out for brevity. </p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Always try to write at least some positive <em>and</em> negative examples.</p>
<h3 id="positive-example"><a class="header" href="#positive-example">Positive Example</a></h3>
<pre><code class="language-forge">example twoAddersLinear is {wellformed} for {
  RCA = `RCA0 
  FullAdder = `FullAdder0 + `FullAdder1
  -- Remember the back-tick mark here! These lines say that, e.g., for the atom `RCA0, 
  -- its firstAdder field contains `FullAdder0. And so on.
  `RCA0.firstAdder = `FullAdder0
  `RCA0.nextAdder = `FullAdder0 -&gt; `FullAdder1
}
</code></pre>
<div id="admonition-notice-that-this-example-is-limited" class="admonition admonish-tip">
<div class="admonition-title">
<p>Notice that this example is limited.</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-notice-that-this-example-is-limited"></a></p>
</div>
<div>
<p>Because we are testing <code>wellformed</code>, we left out fields that didn't matter to that predicate. Forge will feel free to adjust them as needed. When a field is left unspecified, the example is said to be <em>partial</em>, and it becomes a check for consistency. E.g., in this case, the example passes because the partial instance given <em>can</em> satisfy <code>wellformed</code>—not that it must satisfy <code>wellformed</code>—although in this case the difference is immaterial because <code>wellformed</code> really doesn't care about any of the other fields.</p>
</div>
</div>
<h3 id="negative-example"><a class="header" href="#negative-example">Negative Example</a></h3>
<pre><code class="language-forge">example twoAddersLoop is {not wellformed} for {
  RCA = `RCA0 
  FullAdder = `FullAdder0 + `FullAdder1
  `RCA0.firstAdder = `FullAdder0
  `RCA0.nextAdder = `FullAdder0 -&gt; `FullAdder1 + `FullAdder1 -&gt; `FullAdder0
}
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>Let's have a look at a ripple-carry adder in action. We'll pick a reasonably small number of bits: 4. </p>
<pre><code class="language-forge">run {rca} for exactly 4 FullAdder
</code></pre>
<p><strong>(FILL: screenshot)</strong></p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Ok, we've looked at some of the model's output, and it seems right. But how can we be really confident that the ripple-carry adder <em>works</em>? Can we use our model to <em>verify</em> the adder? Yes, but we'll need to do a bit more modeling. </p>
<p><strong>Exercise:</strong> What does it mean for the adder to &quot;work&quot;? </p>
<details>
<summary>Think, then click!</summary>
<p>For one thing, it had better produce a series of boolean outputs that correspond to the output we'd get if we just did the addition. That is, if we add together the numbers <code>2</code> (<code>10</code>) and <code>3</code> (<code>11</code>) we should expect to get <code>5</code>—which should be <code>101</code> in binary, provided we always set the bit-width high enough to match the number of bits we're adding together. </p>
<p>Let's augment our model to check this. We'll ask Forge for an instance where the ripple-carry adder produces a different result (taken as the sum of the outputs of each full adder) than the expected (produced via Forge's <code>add</code> function). </p>
</details>
<hr />
<p>When I'm expanding a model in this way, I like to augment instances with extra fields that exist <em>just for verification</em>, and which aren't part of the system we're modeling. Here, we'll keep track of the place-values of each full adder, which we can then use to compute the &quot;true&quot; value of its input or output. E.g., the first full adder would have place-value 1, and its successors would have place-value 2, then 4, etc. </p>
<div id="admonition-helper-values" class="admonition admonish-note">
<div class="admonition-title">
<p>Helper values</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-helper-values"></a></p>
</div>
<div>
<p>Sometimes you'll hear this sort of new field or value referred to as a &quot;ghost&quot;: it isn't real; it doesn't exist in the actual system.</p>
</div>
</div>
<p>We could store this field in the <code>FullAdder</code> sig, but let's keep the original unmodified, and instead add a <code>Helper</code> sig. This keeps the for-verification-only fields separate from the model of the system:</p>
<pre><code class="language-forge">one sig Helper {
  place: func FullAdder -&gt; Int
}
</code></pre>
<p>The ripple-carry adder gives us the context we need to speak of the place value each full adder ought to have. We can write this for the first adder easily:</p>
<pre><code class="language-forge">-- The &quot;places&quot; helper value should agree with the ordering that the RCA establishes.
pred assignPlaces {
  -- The least-significant bit is 2^0
  Helper.place[RCA.firstAdder] = 1
  -- ...
}
</code></pre>
<p>Now we need to, in effect, write a for-loop or a recursive function that constrains <code>places</code> for all the other adders. But Forge has no recursion or loops! Fortunately, it does have the <code>all</code> quantifier, which lets us define every other adder's <code>place</code> value in terms of its predecessor:</p>
<pre><code class="language-forge">-- The &quot;places&quot; helper value should agree with the ordering that the RCA establishes.
pred assignPlaces {
  -- The least-significant bit is 2^0
  Helper.place[RCA.firstAdder] = 1
  -- Other bits are worth 2^(i+1), where the predecessor is worth 2^i.
  all fa: FullAdder | some RCA.nextAdder[fa] =&gt; {    
    Helper.place[RCA.nextAdder[fa]] = multiply[Helper.place[fa], 2]
  }
}
</code></pre>
<p>When you have quantification and helper fields, you can often avoid needing real iteration or recursion.</p>
<p>We'll add a helper function for convenience later:</p>
<pre><code class="language-forge">fun actualValue[b: Digit, placeValue: Int]: one Int {
  (b = T) =&gt; placeValue else 0
}
</code></pre>
<h3 id="the-requirement"><a class="header" href="#the-requirement">The Requirement</a></h3>
<p>Let's try to express our requirement that the adder is correct. Again, we'll phrase this as: for every full adder, the true value of its output is the sum of the true values of its inputs (where &quot;true value&quot; means the value of the boolean, taking into account its position). We might produce something like this:</p>
<pre><code class="language-forge">pred req_adderCorrect_wrong {
  (rca and assignPlaces) implies {
    all fa: FullAdder | { 
        actualValue[fa.sum_out, Helper.place[fa]] = add[actualValue[fa.a_in, Helper.place[fa]], 
                                                  actualValue[fa.b_in, Helper.place[fa]]]
    }
  }
}
</code></pre>
<p>And then we'll use it in a test. It's vital that we have a high-enough bitwidth, so that Forge can count up to the actual expected result, without overflowing. Forge <code>int</code>s are signed, so we actually need a bigger bit-width than the number of full adders. If we have, say, 6 full adders, we might end up producing a 7-bit output (with carrying). A 7-bit value can conservatively hold up to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span></span></span></span>. To count up to that high, we need to use <em>8</em> bits in Forge, giving the solver all the numbers between <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">128</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span></span></span></span>, inclusive.</p>
<div id="admonition-directly-testing-satisfiability" class="admonition admonish-tip">
<div class="admonition-title">
<p>Directly testing satisfiability</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-directly-testing-satisfiability"></a></p>
</div>
<div>
<p>So far, we've only seen <code>example</code>s and <code>assert</code>ions. Both of these are built using Forge's basic satisfiability checking. We can access this directly using the <code>test expect</code> feature. You can write that a run:</p>
<ul>
<li>should have instances (i.e., be satisfiable): <code>is sat</code>;</li>
<li>should not have instances (i.e., be unsatisfiable, within the bounds given): <code>is unsat</code>; or</li>
<li>should have no counterexample instances (within the bounds given): <code>is checked</code>.</li>
</ul>
</div>
</div>
<pre><code class="language-forge">-- Ask Forge to check the satisfiability of something...
test expect {  
  -- Is it _always_ true, up to these bounds, that `req_adderCorrect` always holds?
  r_adderCorrect: {req_adderCorrect} for 6 FullAdder, 1 RCA, 8 Int is checked
}
</code></pre>
<p>However, this requirement fails—Forge finds a counterexample. </p>
<p><strong>Exercise:</strong> What's wrong? Is the adder broken, or might our property be stated incorrectly?</p>
<details>
<summary>Think, then click!</summary>
<p>We forgot to take carrying into account! Any time a full adder carries a bit, it's dropped by the left-hand side of the above equation. </p>
<p>Notice how even if the model (or system) is correct, sometimes the property itself is wrong. Always be skeptical about your properties, just like you're skeptical about your model.</p>
</details>
<hr />
<p>Here's another attempt:</p>
<pre><code class="language-forge">pred req_adderCorrect {
  (rca and assignPlaces) implies {
    all fa: FullAdder | { 
        -- Include carrying, both for input and output. The _total_ output's true value is equal to
        -- the the sum of the total input's true value.

        -- output value bit + output carry bits; note carry value is *2 (and there may not be a &quot;next adder&quot;)
        add[actualValue[fa.sum_out, Helper.place[fa]], 
            multiply[actualValue[fa.carry_out, Helper.place[fa]], 2]] 
        = 
        -- input a bit + input b bit + input carry bit
        add[actualValue[fa.a_in, Helper.place[fa]],     
            actualValue[fa.b_in, Helper.place[fa]],    
            actualValue[fa.carry_in, Helper.place[fa]]]  
    }
  }
}
</code></pre>
<p>Now when we run the check, it passes. There's just one problem—it only passes <em>eventually</em>. The verification step took over a minute on my laptop! That's rather slow for a model this size. </p>
<h3 id="optimizing-verification"><a class="header" href="#optimizing-verification">Optimizing Verification</a></h3>
<p>When this sort of unexpected slowdown happens, it's often because we've given the solver too much freedom, causing it to explore a much larger search space than it should have to. This is especially pronounced when we expect an &quot;unsatisfiable&quot; result—then, the solver really does need to explore <em>everything</em> before concluding that no, there are no solutions. We're in that situation here, since we're hoping there are no counter-examples to correctness. </p>
<p><strong>Exercise:</strong> What did we leave the solver to figure out on its own, that we maybe could give it some help with?</p>
<details>
<summary>Think, then click!</summary>
<p>There are at least two things. </p>
<ul>
<li>First, the exact ordering of full adders isn't something we provided. We just said &quot;create up to 6 of them, and wire them together in a line&quot;. Considering just the 6-adder case (and not the 5-adder case, 4-adder case, etc.), how many ways are there to arrange the adders? <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">6</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">720</span></span></span></span>. Unless the solver can detect and eliminate these symmetries, it's doing a <em>lot</em> more work than it needs to. </li>
<li>Second, we said that <code>Helper.place</code> mapped full adders to integers. But does the solver need to consider <em>all</em> integers? No! Just <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, and so on. The vast majority of integers in the scope we provided cannot be used—and the solver will have to discover that on its own.</li>
</ul>
</details>
<hr />
<p>These both present opportunities for optimization! For now, let's just tackle the first one: we need to somehow give Forge a specific ordering on the adders, rather than letting the solver explore all possible orderings. E.g., maybe we want a series of atoms <code>FullAdder0</code>, <code>FullAdder1</code>, ..., <code>FullAdder5</code>, which ordering <code>RCA.nextAdder</code> respects. </p>
<p>We could try to express this as a constraint: </p>
<pre><code class="language-forge">pred orderingOnAdders {
  some disj fa0, fa1, fa2, fa3, fa4, fa5: FullAdder | {
    RCA.firstAdder = fa0
    RCA.nextAdder[fa0] = fa1 
    RCA.nextAdder[fa1] = fa2
    RCA.nextAdder[fa2] = fa3 
    RCA.nextAdder[fa3] = fa4 
    RCA.nextAdder[fa4] = fa5 
  }
}
</code></pre>
<p>However, this won't be very effective. </p>
<p><strong>Exercise:</strong> Why won't adding <code>orderingOnAdders</code> to our set of constraints actually help much, if at all? </p>
<details>
<summary>Think, then click!</summary>
<p>Because all of that is already implied by the other constraints we have. It's true that sometimes rephrasing a constraint like this can have a big impact on performance if the solver can figure out how to use it well, but in this case the problem is one of symmetries; the solver would <em>just keep checking all possibilities</em> for the <code>fa0</code>, <code>fa1</code>, etc. variables anyway. </p>
<p>Fortunately, there's a much better option. </p>
</details>
<hr />
<p>Recall that Forge works by searching for satisfying instances within some large possibility space, and that this space is restricted by the bounds given. The search process is run by a sophisticated solver, but the problem that the solver itself gets looks nothing like Forge. The process of solving a Forge problem thus has three separate stages: </p>
<ul>
<li>express the solution space in a form the solver understands, which is usually a large set of boolean variables; </li>
<li>convert the constraints into a form the solver understands, which needs to be in terms of the converted solution-space variables; and only then</li>
<li>invoke the solver on the converted problem.</li>
</ul>
<p>Adding constraints will affect the later steps, but we'd love to give hints to the translator even earlier in the process. We'll talk more about exactly how this works later, but for now, we'll add a <em>bounds annotation</em> to our run: that the <code>nextAdder</code> field is <em>partial-linear</em>, or <code>nextAdder is plinear</code>. Linearity means that the atoms which <code>nextAdder</code> maps should be pre-arranged in a fixed order before they get to the solver at all. Partial linearity means that the ordering may not use all of the potential atoms. </p>
<pre><code class="language-forge">test expect {  
  r_adderCorrect: {req_adderCorrect} for 6 FullAdder, 1 RCA, 8 Int for {nextAdder is plinear} is checked
}
</code></pre>
<p>This wasn't hard to add: it's just another <code>{}</code>-delimited instruction that you can add to any <code>run</code>, <code>test</code>, etc. command. Now Forge finishes the check in under a second on my laptop. Eliminating symmetries can make a huge difference! </p>
<div id="admonition-bounds-vs-constraints" class="admonition admonish-warning">
<div class="admonition-title">
<p>Bounds vs. Constraints</p>
<p><a class="admonition-anchor-link" href="chapters/adder/rca.html#admonition-bounds-vs-constraints"></a></p>
</div>
<div>
<p>Notice that the bounds annotation is grouped after the numeric bounds, <em>not</em> with the constraints. This is because the two are separate. If we had tried to put <code>nextAdder is plinear</code> in as a constraint in our predicate, we would have gotten an error, because Forge doesn't know how to interpret it as a constraint, only how to use it to shape the solution space passed to the solver.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="anticipated-questions-static-models"><a class="header" href="#anticipated-questions-static-models">Anticipated Questions: Static Models</a></h1>
<h3 id="what-happens-when-forge-searches"><a class="header" href="#what-happens-when-forge-searches">What Happens When Forge Searches?</a></h3>
<p>Our first <code>run</code> command in Forge was from <a href="chapters/qna/../ttt/ttt.html">tic-tac-toe</a>: <code>run { some b: Board | wellformed[b]}</code>.</p>
<p>How did Forge actually run the search? Surely it isn't checking all possible boards <em>one at a time</em>; that wouldn't scale at all, and we need to scale in order to model and reason about real systems. No; Forge can efficiently search much larger problem spaces than this.</p>
<p>Let's step through <em>how</em> Forge solves a problem. First, there's a space of potential solutions that it considers. Using the default engine, this space is finite—although possibly enormous. There are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">19683</span></span></span></span> 3-by-3 tic-tac-toe boards, which isn't too bad. But a 4-by-4 board would have <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">430</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">467</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">213</span></span></span></span> possibilities, and real systems might have more possible states than electrons in the observable universe. So we'd better be doing something smarter than checking one instance at a time.</p>
<p>The bounds of the space to search is set by the <code>run</code> command. In this case, no bounds were given, so defaults were used: instances may contain <em>up to 4 atoms of each top-level <code>sig</code> type</em>, and the integers <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">8</span></span></span></span> through <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> (inclusive) but no more. We can adjust that bound by adding instructions, e.g., <code>run { some b: Board | wellformed[b]} for exactly 2 Board</code> will only seek instances where there are 2 <code>Board</code> atoms. </p>
<p>The bounds describe the search space. This space is populated with instances, some of which satisfy the constraints being run and some of which don't. In principle, there exist other instances too—entirely outside the space being searched! E.g., if we said to search up to 4 <code>Board</code> atoms, an instance with 100 such atoms might (or might not) satisfy our constraints, but wouldn't be considered in the search:</p>
<center><img width="70%" src="chapters/qna/./solving.svg" style="background-color:white"/></center>
<p>Once this space is defined, <strong>and only then</strong>, a sophisticated constraint-solving engine—a boolean &quot;SAT&quot; or &quot;SMT&quot; solver—takes charge. The engine uses techniques like backtracking and heuristics to try to avoid unnecessary work in solving the problem. This divides the search space into &quot;satisfying&quot; and &quot;not satisfying&quot; areas. The solver returns the satisfying instances in some order:</p>
<center><img width="70%" src="chapters/qna/./partitioned.svg" style="background-color:white"/></center>
<div id="admonition-csci-1710" class="admonition admonish-note">
<div class="admonition-title">
<p>CSCI 1710</p>
<p><a class="admonition-anchor-link" href="chapters/qna/static.html#admonition-csci-1710"></a></p>
</div>
<div>
<p>If you're in CSCI 1710, one of your assignments will be to <em>build</em> such a constraint solver, and even to see how it performs &quot;plugged in&quot; to Forge and solving real <code>run</code> commands you write.</p>
</div>
</div>
<!-- ![](https://i.imgur.com/eQ76Hv8.png) -->
<h4 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h4>
<p>As you may have seen in the ripple-carry adder section, these two phases of solving work very differently, and  letting the solver infer constraints is often less efficient than giving it tighter bounds, because the latter restricts the overall space to be searched beforehand. Some optimization techniques in Forge need to be explicitly applied in the first phase, because the solver engine itself splits the two phases apart. For more on this, read <a href="chapters/qna/../qna/events.html">the upcoming Q&amp;A section for traces and events</a>.</p>
<!-- ### How does `reachable` work? 

We prototyped some confidence tests about the `reachable` predicate ([livecode file](./testing_reachable.frg)). -->
<h3 id="nulls-in-forge"><a class="header" href="#nulls-in-forge">&quot;Nulls&quot; in Forge</a></h3>
<p>In Forge, there is a special value called <code>none</code>. It's analogous (but not exactly the same!) to a <code>None</code> in languages like Python.</p>
<p>Suppose I add this predicate to our <code>run</code> command in the tic-tac-toe model:</p>
<pre><code class="language-alloy">pred myIdea {
    -- no 2 locations can share the same mark
    all rowA, colA, rowB, colB: Int | 
        (rowA != rowB or colA != colB) implies
            Board.board[rowA][colA] != 
            Board.board[rowB][colB]
}
</code></pre>
<p>I'm trying to express that every entry in the board is different. This should easily be true about, e.g., the initial board, as there are no pieces there at all. But <strong>do you think the empty board satisfies this predicate?</strong></p>
<details>
<summary>Think (or try it in Forge) then click!</summary>
<p>It's very likely this predicate would <em>not</em> be satisfied by the empty board. Why?</p>
<p><em>Because <code>none</code> equals itself</em>, and it's the value in each location of the board before <code>X</code> or <code>O</code> move there. </p>
<p>Thus, when you're writing constraints like the above, you need to watch out for <code>none</code>: the value for <em>every</em> cell in the initial board is equal to the value for <em>every</em> other cell!</p>
</details>
<div id="admonition-reachability-and-none" class="admonition admonish-tip">
<div class="admonition-title">
<p>Reachability and none</p>
<p><a class="admonition-anchor-link" href="chapters/qna/static.html#admonition-reachability-and-none"></a></p>
</div>
<div>
<p>The <code>none</code> value in Forge has at least one more subtlety: <code>none</code> is &quot;reachable&quot; from everything if you're using the built-in <code>reachable</code> helper predicate. That has an impact even if we don't use <code>none</code> explicitly. If I write something like: <code>reachable[p.spouse, Nim, parent1, parent2]</code> I'm asking whether, for some person <code>p</code>, their spouse is an ancestor of <code>Nim</code>. If <code>p</code> doesn't have a spouse, then <code>p.spouse</code> is <code>none</code>, and so this predicate would yield true for <code>p</code>.</p>
<p>This is why it's often advisible to qualify your use of <code>reachable</code>. E.g., I could write <code>some p.spouse and reachable[p.spouse, Nim, parent1, parent2]</code>.</p>
</div>
</div>
<h3 id="some-as-a-quantifier-versus-some-as-a-multiplicity"><a class="header" href="#some-as-a-quantifier-versus-some-as-a-multiplicity">Some as a Quantifier Versus Some as a Multiplicity</a></h3>
<p>The keyword <code>some</code> is used in 2 different ways in Forge:</p>
<ul>
<li>it's a <em>quantifier</em>, as in <code>some b: Board, p: Player | winner[s, p]</code>, which says that somebody has won in some board (and gives us a name for that board, and also for the winner); and</li>
<li>it's a <em>multiplicity operator</em>, as in <code>some Board.board[1][1]</code>, which says only that the middle cell of the board is populated (recall that the board indexes are <code>0</code>, <code>1</code>, and <code>2</code>).</li>
</ul>
<p>Don't be afraid to use both; they're both quite useful! But remember the difference. </p>
<h3 id="guarding-quantifiers-implies-vs-such-that"><a class="header" href="#guarding-quantifiers-implies-vs-such-that">Guarding Quantifiers; Implies vs. &quot;Such That&quot;</a></h3>
<p>You can read <code>some row : Int | ...</code> as &quot;There exists some integer <code>row</code> such that ...&quot;. The transliteration isn't quite as nice for <code>all</code>; it's better to read <code>all row : Int | ...</code> as &quot;In all integer <code>row</code>s, it holds that ...&quot;. </p>
<p>If you want to <em>further restrict</em> the values used in an <code>all</code>, you'd use <code>implies</code>. But if you want to <em>add additional requirements</em> for a <code>some</code>, you'd use <code>and</code>.  Here are 2 examples:</p>
<ul>
<li><strong>All</strong>: &quot;Everybody who has a <code>parent1</code> doesn't also have that person as their <code>parent2</code>&quot;: <code>all p: Person | some p.parent1 implies p.parent1 != p.parent2</code>.</li>
<li><strong>Some</strong>: &quot;There exists someone who has a <code>parent1</code> and a <code>spouse</code>&quot;: <code>some p: Person | some p.parent1 and some p.spouse</code>.</li>
</ul>
<p><strong>Technical aside:</strong> The type designation on the variable can be interpreted as having a character similar to these add-ons: <code>and</code> (for <code>some</code>) and <code>implies</code> (for <code>all</code>). E.g., &quot;there exists some <code>row</code> such that <code>row</code> is an integer and ...&quot;, or &quot;In all <code>row</code>s, if <code>row</code> is an integer, it holds that...&quot;.</p>
<h3 id="there-exists-some-atom-vs-some-instance"><a class="header" href="#there-exists-some-atom-vs-some-instance">There Exists <code>some</code> <em>Atom</em> vs. Some <em>Instance</em></a></h3>
<p>Forge searches for instances that satisfy the constraints you give it. Every <code>run</code> in Forge is about <em>satisfiability</em>; answering the question &quot;Does there exist an instance, such that...&quot;. </p>
<p>Crucially, <strong>you cannot write a Forge constraint that quantifies over <em>instances</em> themselves</strong>. You can ask Forge &quot;does there exist an instance such that...&quot;, which is pretty flexible on its own. E.g., if you want to check that something holds of <em>all</em> instances, you can ask Forge to find counterexamples. This exactly what <code>assert ... is necessary for ...</code> does; it searches for counterexample instances.</p>
<h3 id="tip-testing-predicate-equivalence"><a class="header" href="#tip-testing-predicate-equivalence">Tip: Testing Predicate Equivalence</a></h3>
<p>Checking whether or not two predicates are <em>equivalent</em> is the core of quite a few Forge applications---and a great debugging technique sometimes. (We saw this very briefly for binary trees, but it's worth repeating.)</p>
<p>How do you check for predicate equivalence? Well, suppose we tried to write a predicate in two different ways, like this:</p>
<pre><code class="language-alloy">pred myPred1 {
    some i1, i2: Int | i1 = i2
}
pred myPred2 {
    not all ii, i2: Int | i1 != i2
}
assert myPred1 is necessary for myPred2
assert myPred2 is necessary for myPred1
</code></pre>
<p>These <code>assert</code> statements will pass, because the two predicates <em>are</em> logically equivalent. But if we had written (forgetting the <code>not</code>):</p>
<pre><code class="language-alloy">pred myPred2 {
    all ii, i2: Int | i1 != i2
}
</code></pre>
<p>One of the assertions would fail, yielding an instance in Sterling you could use the evaluator with. If you get an instance where the two predicates aren't equivalent, you can use the Sterling evaluator to find out <strong>why</strong>. Try different subexpressions, discover which is producing an unexpected result! </p>
<h3 id="one-versus-some"><a class="header" href="#one-versus-some">One Versus Some</a></h3>
<p>Classical logic provides the <code>some</code> and <code>all</code> quantifiers, but Forge also gives you <code>no</code>, <code>one</code> and <code>lone</code>. The <code>no</code> quantifier is fairly straightforward: if I write <code>no row, col: Int | Board.board[row][col] = X</code>, it's equivalent to <code>all row, col: Int | Board.board[row][col] != X</code>. That is, <code>X</code> hasn't yet put a mark on the board. </p>
<p>The <code>one</code> quantifier is for saying &quot;there exists a UNIQUE ...&quot;. As a result, there are hidden constraints embedded into its use. <code>one row: Int | Board.board[row][0] = X</code> really means, roughly, <code>some row: Int | { Board.board[row][0] = X and all row2: Int | { row2 != row implies Board.board[row][0] != X}}</code>: there is <em>some</em> row where <code>X</code> has moved in the first column, but <em>only one such row</em>. The <code>lone</code> quantifier is similar, except that instead of saying &quot;exactly one&quot;, it says &quot;either one or none&quot;. </p>
<p>This means that interleaving <code>one</code> or <code>lone</code> with other quantifiers can be subtle. Consider what happens if I write <code>one row, col: Int | Board.board[row][col] = X</code>. This means that there is exactly one square on the board where <code>X</code> has moved. But what about <code>one row: Int | one col: Int | Board.board[row][col] = X</code>? </p>
<p><strong>Exercise:</strong> Test this out using Forge! Try running: </p>
<pre><code>run { not { 
      (one row, col: Int | Board.board[row][col] = X) iff
      (one row: Int | one col: Int | Board.board[row][col] = X)
}}
</code></pre>
<p>You'll get an instance showing you that the two aren't equivalent. What's the problem?</p>
<details>
<summary>Think, then click!</summary>
<p>The problem is that <code>one row, col: Int | ...</code> says that there exists one unique <em>pair</em> of indexes, but <code>one row: Int | one col: Int | ...</code> says that there exists one unique <em>index</em> such that there exists one unique <em>index</em>... These are not the same.</p>
</details>
<p>Because thinking through <code>one</code> and <code>lone</code> quantifiers can be subtle, we strongly suggest <em>not</em> using them except for very simple constraints. (Using them as a multiplicity, like saying <code>one Tim.office</code> is fine.) </p>
<h4 id="satisfiability-testing-and-a-pitfall"><a class="header" href="#satisfiability-testing-and-a-pitfall">Satisfiability Testing and a Pitfall</a></h4>
<p>The <code>test expect</code> syntax lets you check for satisfiability directly. This is quite powerful, and lets us illustrate a fairly common mistake. Here is a test block with 2 tests in it. Both of them may look like they are comparing <code>myPred1</code> and <code>myPred2</code> for equivalence:</p>
<pre><code class="language-alloy">test expect {
    -- correct: &quot;no counterexample exists&quot;
    -- Forge tries to find an instance where myPred1 and myPred2 disagree
    p1eqp2_A: {
        not (myPred1 iff myPred2)        
    } is unsat

    -- incorrect: &quot;it's possible to satisfy what i think always holds&quot;
    -- Forge tries to find an instance where myPred1 and myPred2 happen to agree
    p1eqp2_B: {
        myPred1 iff myPred2
    } is sat
}
</code></pre>
<p>These two tests do not express the same thing! One asks Forge to find an instance where the predicates are not equivalent. If it can find such an instance, we know the predicates are not equivalent, and can see why by viewing the intance. The other test asks Forge to find an arbitrary instance where they <em>are</em> equivalent. But that needn't be true in <em>all</em> instances, just the one that Forge finds. </p>
<h3 id="quantifiers-and-performance"><a class="header" href="#quantifiers-and-performance">Quantifiers and Performance</a></h3>
<p>Forge works by converting your model into a boolean satisfiability problem. That is, it builds a boolean circuit where inputs making the circuit true satisfy your model. But boolean circuits don't have a notion of quantifiers, so they need to be compiled out.</p>
<p>The compiler has a lot of clever tricks to make this fast, but if it can't apply those tricks, it uses a basic idea: an <code>all</code> is just a big <code>and</code>, and a <code>some</code> is just a big <code>or</code>. This very simple conversion process increases the size of the circuit exponentially in the depth of quantification. </p>
<p>Let's look at an example of why this matters. Here is a reasonable way to approach writing a predicate for a model solving the 8-queens problem, where Forge is searching for how to place 8 queens on a chessboard such that none of them can attack the other:</p>
<pre><code class="language-forge">pred notAttacking {
  -- For every pair of queens
  all disj q1, q2 : Queen | {
    -- There's somewhere to put them: (r1,c1) and (r2,c2)
    some r1, c1, r2, c2: Int | {
      // ... such that (r1,c1) and (r2,c2) aren't on a shared line of attack
    } } }
</code></pre>
<p>The problem is: there are 8 queens, and 16 integers. It turns out this is a pathological case for the compiler, and it runs for a really long time. In fact, it runs for a long time even if we reduce the scope to 4 queens! The default <code>verbosity</code> option shows the blowup here, in `time-ranslation, which gives the number of milliseconds used to convert the model to a boolean circuit:</p>
<pre><code>:stats ((size-variables 410425) (size-clauses 617523) (size-primary 1028) (time-translation 18770) (time-solving 184) (time-building 40)) :metadata ())
#vars: (size-variables 410425); #primary: (size-primary 1028); #clauses: (size-clauses 617523)        
Transl (ms): (time-translation 18770); Solving (ms): (time-solving 184)
</code></pre>
<p>Ouch! To avoid this blowup, we might try a different approach that uses fewer quantifiers. In fact, *we can write the constraint without referring to specific queens at all, just 4 integers representing the positions. </p>
<div id="admonition-how" class="admonition admonish-tip">
<div class="admonition-title">
<p>How?</p>
<p><a class="admonition-anchor-link" href="chapters/qna/static.html#admonition-how"></a></p>
</div>
<div>
<p>Does the identity of the queens matter at all, beyond their location?</p>
</div>
</div>
<p>If you encounter bad performance from Forge, check for this sort of unnecessary nested quantifier use. It can often be fixed by reducing quantifier nesting, or by narrowing the scope of what's being quantified over.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="from-boards-to-games"><a class="header" href="#from-boards-to-games">From Boards to Games</a></h2>
<p>Now that we've gotten some experience modeling in Forge, let's start thinking about <em>change</em>.</p>
<p>What do you think a <em>game</em> of tic-tac-toe looks like? Crucially, a game involves <em>moves</em>. </p>
<p><strong>Exercise:</strong> How could we model the moves between board states? (Hint: start thinking in terms of a graph—nodes and edges!)</p>
<details>
<summary>Think, then click!</summary>
<p>It's often convenient to use the following idiom. </p>
<p>Think of the game as a big graph, where the nodes are the <em>states</em> (possible board configurations) and the edges are <em>transitions</em> between states (in this case, legal moves of the game). Here's a rough sketch:</p>
<p><img src="https://i.imgur.com/YmsbRp8.png" alt="" /></p>
</details>
<br/>
<p>A game of tic-tac-toe is a sequence of steps in a state graph, starting from the empty board. Let's model it.</p>
<p>First, what does a move look like? A player puts their mark at a specific location. In Forge, we'll represent this using a <em>transition predicate</em>: a predicate that says when it's legal for one state to evolve into another. We'll often call these the <em>pre-state</em> and <em>post-state</em> of the transition:</p>
<pre><code class="language-forge">pred move[pre: Board, row: Int, col: Int, p: Player, post: Board] {
  // ...
}
</code></pre>
<p>What constraints should we add? It's useful to divide a transition predicate into:</p>
<ul>
<li>a <em>guard</em>, which allows the move only if the pre-state is suitable; and </li>
<li>an <em>action</em>, which defines what is in the post-state based on the pre-state and the move parameters.</li>
</ul>
<p>For the guard, in order for the move to be valid, it must hold that in the pre-state:</p>
<ul>
<li>nobody has already moved at the target location; and</li>
<li>it's the moving player's turn.</li>
</ul>
<p>For the action:</p>
<ul>
<li>the new board is the same as the old, except for the addition of the player's mark at the target location.</li>
</ul>
<p>Now we can fill in the predicate. Let's try something like this:</p>
<pre><code class="language-alloy">pred move[pre: Board, row: Int, col: Int, p: Player, post: Board] {
  -- guard:
  no pre.board[row][col]   -- nobody's moved there yet
  p = X implies XTurn[pre] -- appropriate turn
  p = O implies OTurn[pre]  
  
  -- action:
  post.board[row][col] = p
  all row2: Int, col2: Int | (row!=row2 and col!=col2) implies {        
     post.board[row2][col2] = pre.board[row2][col2]     
  }  
}
</code></pre>
<p>There are many ways to write this predicate. However, we're going to stick with this general form because it calls out an important point. Suppose we had only written <code>post.board[row][col] = p</code> for the action, without the <code>all</code> on the next following lines. Those added lines, which we'll call a <em>frame condition</em>, say that all other squares remain unchanged; without them, the contents of any other square might change in any way. Leaving them out would cause an <em>underconstraint</em> bug: the predicate would be too weak to accurately describe moves in tic-tac-toe. But that's not the only source of problems...</p>
<p><strong>Exercise</strong>: Could there be a bug in this predicate? (Run Forge and find out!)</p>
<details>
<summary>Think, then click</summary>
<p>The <code>all row2...</code> formula says that for any board location where <em>both the row and column differ</em> from the move's, the board remains the same. But is that what we really wanted? Suppose <code>X</code> moves at location <code>1</code>, <code>1</code>. Then of the 9 locations, which is actually protected?</p>
<div class="table-wrapper"><table><thead><tr><th>Row</th><th>Column</th><th>Protected?</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>yes</td></tr>
<tr><td>0</td><td>1</td><td>no (column 1 = column 1)</td></tr>
<tr><td>0</td><td>2</td><td>yes</td></tr>
<tr><td>1</td><td>0</td><td>no (row 1 = row 1)</td></tr>
<tr><td>1</td><td>1</td><td>no (as intended)</td></tr>
<tr><td>1</td><td>2</td><td>no (row 1 = row 1)</td></tr>
<tr><td>2</td><td>0</td><td>yes</td></tr>
<tr><td>2</td><td>1</td><td>no (column 1 = column 1)</td></tr>
<tr><td>2</td><td>2</td><td>yes</td></tr>
</tbody></table>
</div>
<p>Our frame condition was <em>too weak</em>! We need to have it take effect whenever <em>either</em> the row or column is different. Something like this will work:</p>
<pre><code class="language-alloy">  all row2: Int, col2: Int | 
    ((row2 != row) or (col2 != col)) implies {    
       post.board[row2][col2] = pre.board[row2][col2]     
  }  

</code></pre>
</details>
<p><strong>Exercise</strong>: Make the suggested fix to the predicate above. Comment out the 3 frame-condition lines and run the model. Do you see moves where the other 8 squares change arbitrarily? You should, because Forge is free to make such changes.</p>
<h3 id="property-preservation"><a class="header" href="#property-preservation">Property Preservation</a></h3>
<p>Once someone wins a game, does their win still persist, even if more moves are made? I'd like to think so: moves never get undone, and in our model winning just means the existence of 3-in-a-row for some player. We probably even believe this property without checking it. However, it won't always be so straightforward to show that properties are preserved by the system. We'll check this one in Forge as an example of how you might prove something similar in a more complex system.</p>
<div id="admonition-looking-ahead" class="admonition admonish-note">
<div class="admonition-title">
<p>Looking ahead</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt_games.html#admonition-looking-ahead"></a></p>
</div>
<div>
<p>This is our first step into the world of verification. Asking whether or not a program, algorithm, or other system always satisfies some assertion is a core problem in engineering, and has a centuries-long history.</p>
</div>
</div>
<p>We'll tell Forge to find us pairs of states, connected by a move: the <em>pre-state</em> before the move, and the <em>post-state</em> after it. That's <em>any</em> potential transition in tic-tac-toe—at least, following the rules as we defined them. To apply this technique, all we need to do is add two more constraints that reflect a winner existing in the pre-state, but that there's no winner in the post-state.</p>
<pre><code class="language-alloy">pred winningPreservedCounterexample {
  -- There is some pair of states
  some pre, post: Board | {
    -- such that the first transitions to the second
    some row, col: Int, p: Player | 
      move[pre, post, row, col, p]
    -- the first state has a winner
    some p: Player | winner[pre, p]
    -- the second state has no winner
    all o: Player | not winner[post, p]
  }
}
run {
  all s: Board | wellformed[s]
  winningPreservedCounterexample
}
</code></pre>
<p>The <code>run</code> is unsatisfiable. Forge can't find any counterexamples. We'll see this reported as &quot;UNSAT&quot; (short for &quot;unsatisfiable&quot;) in the visualizer. </p>
<div id="admonition-next-button" class="admonition admonish-tip">
<div class="admonition-title">
<p>Next button</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt_games.html#admonition-next-button"></a></p>
</div>
<div>
<p>Remember that the visualizer also has a &quot;Next&quot; button; you can browse many different solution instances. Of course, if you press it enough times, Forge (eventually) runs out of solutions to show.</p>
</div>
</div>
<h2 id="generating-complete-games"><a class="header" href="#generating-complete-games">Generating Complete Games</a></h2>
<p>Recall that our worldview for this model is that systems <em>transition</em> between <em>states</em>, and thus we can think of a system as a directed graph. If the transitions have arguments, we'll sometimes label the edges of the graph with those arguments. This view is sometimes called a <em>discrete event</em> model, because one event happens at a time. Here, the events are moves of the game. In a bigger model, there might be many different types of events.</p>
<p>Today, we'll ask Forge to find us <em>full traces of the system</em>, starting from an initial state. We'll also add a <code>Game</code> sig to incorporate some metadata.</p>
<pre><code class="language-alloy">-- Generate *one* game of tic-tac-toe
one sig Game {
  -- What state does the game start in?
  initialState: one Board,
  -- How does the game evolve from state to state?
  nextState: pfunc Board -&gt; Board
}

pred traces {
    -- The trace starts with an initial state
    starting[Game.initialState]
    no sprev: Board | Game.nextState[sprev] = Game.initialState
    -- Every transition is a valid move
    all s: Board | some Game.nextState[s] implies {
      some row, col: Int, p: Player |
        move[s, row, col, p, Game.nextState[s]]
    }
}
</code></pre>
<p>By itself, this wouldn't be quite enough; we might see a bunch of disjoint traces. We could add more constraints manually, but there's a better option: tell Forge, at <code>run</code>time, that <code>nextState</code> represents a linear ordering on states. This is similar to what we did back in the <a href="chapters/ttt/../adder/rca.html">ripple-carry adder</a>:</p>
<pre><code class="language-alloy">run { traces } for {nextState is linear}
</code></pre>
<p>It's worth recalling what's happening here. The phrase <code>nextState is linear</code> isn't a <em>constraint</em>; it's a separate annotation given to Forge alongside a <code>run</code> or a test. Never put such an annotation in a constraint block; Forge won't understand it. These annotations narrow Forge's <em>bounds</em> (the space of possible worlds to check) before the solver begins its work.</p>
<p>In general, Forge syntax allows such annotations <em>after</em> numeric bounds. E.g., if we wanted to see full games, rather than unfinished game prefixes (the default bound on any sig, including <code>Board</code>, is up to 4) we could have asked:</p>
<pre><code class="language-alloy">run {
  traces
} for exactly 10 Board for {nextState is linear}
</code></pre>
<p>You might notice that because of this, some traces are excluded. That's because <code>nextState is linear</code> forces exact bounds on <code>Board</code>. This is in contrast to <code>plinear</code>, which we used for the ripple-carry adder, and which didn't force exact bounds. Use whichever of the two is more appropriate to your needs.</p>
<h2 id="the-evaluator"><a class="header" href="#the-evaluator">The Evaluator</a></h2>
<p>Moreover, since we're now viewing a single fixed instance, we can <em>evaluate</em> Forge expressions in it. This is great for debugging, but also for just understanding Forge a little bit better. Open the evaluator here at the bottom of the right-side tray, under theming. Then enter an expression or constraint here:</p>
<p><img src="https://i.imgur.com/tnT8cgo.png" alt="" /></p>
<p>Type in something like <code>some s: Board | winner[s, X]</code>. Forge should give you either <code>#t</code> (for true) or <code>#f</code> (for false) depending on whether the game includes <code>X</code> winning in some state.</p>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<p>You might notice that this model takes a while to run. Something happened after we started reasoning about full games. Why might that be? Let's re-examine our bounds and see if there's anything we can adjust. In particular, here's what the evaluator says we've got for integers:</p>
<p><img src="https://i.imgur.com/UJJUqdB.png" alt="" /></p>
<p>Wow---wait, do we really <strong>need</strong> to be able to count up to <code>7</code> for this model? Even more, do we really need to count all the way down to <code>-8</code>? Probably not. If we change our integer bounds to <code>3 Int</code> we'll still be able to use <code>0</code>, <code>1</code>, and <code>2</code>, and the search space is much smaller.</p>
<h2 id="back-to-tic-tac-toe-ending-games"><a class="header" href="#back-to-tic-tac-toe-ending-games">Back To Tic-Tac-Toe: Ending Games</a></h2>
<p>Recall that we just ran this command:</p>
<pre><code class="language-alloy">run {
  wellformed
  traces
} for exactly 10 Board for {nextState is linear}
</code></pre>
<div id="admonition-nothing-without-a-command" class="admonition admonish-note">
<div class="admonition-title">
<p>Nothing without a command</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt_games.html#admonition-nothing-without-a-command"></a></p>
</div>
<div>
<p>Without a <code>run</code>, an <code>example</code>, or a similar <em>command</em>, running a Forge model will do nothing.</p>
</div>
</div>
<p>From this <code>run</code> command, Forge will find <em>traces</em> of the system (here, games of Tic-Tac-Toe) represented as a linear sequence of exactly 10 <code>State</code> atoms.</p>
<p>Do you have any worries about the way this is set up?</p>
<details>
<summary>Think, then click!</summary>
Are all Tic-Tac-Toe games 10 states long? 
<p>Well, <em>maybe</em>; it depends on how we define a game. If we want a game to stop as soon as nobody can win, our <code>exactly 10 State</code> bound is going to prevent us from finding games that are won before the final cell of the board is filled.</p>
</details>
<p>Let's add the following guard constraint to the <code>move</code> transition predicate, which forces games to end as soon as somebody wins.</p>
<pre><code class="language-alloy">all p: Player | not winner[pre, p]
</code></pre>
<p>Now we've got problems, because once we add this constraint, Forge will omit games that end before all square of the board are filled.</p>
<p>This behavior, which may initially seem strange, exists for two reasons:</p>
<ul>
<li>History: Forge's ancestor language, Alloy, has something very similar to <code>is linear</code>, with the same semantics.</li>
<li>Performance: since the <code>is linear</code> annotation is almost always used for trace-generation, and trace-generation solving time grows (in the worst case) exponentially in the length of the trace, we will almost always want to reduce unnecessary uncertainty. Forcing the trace length to always be the same reduces the load on the solver, and makes trace-generation somewhat more efficient.</li>
</ul>
<p>But now we need to work around this limitation. Any ideas? Hint: do we need to have <em>only one</em> kind of transition in our system?</p>
<details>
<summary>Think, then click!</summary>
<p>No. A common way to allow trace length to vary is by adding a &quot;do nothing&quot; transition. (In the literature, this is called a <em>stutter transition</em>.) </p>
<p>The trick is in how to add it without also allowing a &quot;game&quot; to consist of nobody doing anything. To do that requires some more careful modeling.</p>
</details>
</br>
<p>Let's add an additional transition that does nothing. We can't &quot;do nothing&quot; in the predicate body, though—an empty predicate body would just mean <em>anything</em> could happen. What we mean to say is that the state of the board remains the same, even if the before and after <code>Board</code> objects differ.</p>
<pre><code class="language-alloy">pred doNothing[pre: Board, post: Board] {
    all row2: Int, col2: Int | 
        post.board[row2][col2] = pre.board[row2][col2]
}
</code></pre>
<div id="admonition-variable-names" class="admonition admonish-warning">
<div class="admonition-title">
<p>Variable names</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt_games.html#admonition-variable-names"></a></p>
</div>
<div>
<p>Remember that <code>row2</code> and <code>col2</code> are just variable names that could stand for any <code>Int</code>; they aren't necessarily the row or column index value <code>2</code>.</p>
</div>
</div>
<p>We also need to edit the <code>traces</code> predicate to allow <code>doNothing</code> to take place:</p>
<pre><code class="language-alloy">pred traces {
    -- The trace starts with an initial state
    starting[Game.initialState]
    no sprev: Board | Game.nextState[sprev] = Game.initialState
    -- Every transition is a valid move
    all s: Board | some Game.nextState[s] implies {
      some row, col: Int, p: Player | {
        move[s, row, col, p, Game.nextState[s]] 
      }
      or
      doNothing[s, Game.nextState[s]]      
    } 
}
</code></pre>
<p>As it stands, this fix solves the <em>overconstraint</em> problem of never seeing an early win, but introduces a new <em>underconstraint</em> problem: we don't want <code>doNothing</code> transitions to happen just anywhere!</p>
<p>Here's how I like to fix it:</p>
<pre><code class="language-alloy">pred gameOver[s: Board] {
  some p: Player | winner[s, p]
}
</code></pre>
<p>Why a new predicate? Because I want to use different predicates to represent different concepts, and enable re-use.</p>
<p>When should a <code>doNothing</code> transition be possible? <em>Only when the game is over!</em></p>
<pre><code class="language-alloy">pred doNothing[pre: State, post: State] {
    gameOver[pre] -- guard of the transition
    pre.board = post.board -- effect of the transition
}
</code></pre>
<p>If we wanted to, we could add a <code>not gameOver[pre]</code> guard constraint to the <code>move</code> predicate, enforcing that nobody can move at all after someone has won.</p>
<h2 id="do-the-rules-allow-cheating"><a class="header" href="#do-the-rules-allow-cheating">Do The Rules Allow Cheating?</a></h2>
<p>Let's ask Forge whether a <code>cheating</code> state is possible under the rules. </p>
<pre><code class="language-alloy">pred cheating[b: Board] {
  -- It's neither X's nor O's turn; the balance is way off! 
  not XTurn[b] 
  not OTurn[b]
}
run {
  wellformed
  traces
  some bad: Board | cheating[bad]
} for exactly 10 State for {next is linear}
</code></pre>
<p>This should work—assuming we don't drop the <code>is linear</code> annotation. Without it, nothing says that every state must be in the trace, and so Forge could produce an instance with an &quot;unused&quot; cheating state that's not reachable from the start.</p>
<h2 id="checking-conjectures"><a class="header" href="#checking-conjectures">Checking Conjectures</a></h2>
<p>When I was very small, I thought that moving in the middle of the board would guarantee a win at Tic-Tac-Toe. Now I know that isn't true. Could I have used Forge to check my conjecture?</p>
<details>
<summary>Think, then Click!</summary>
Here's how I did it:    
<pre><code class="language-alloy">run {
  wellformed
  traces
  -- &quot;let&quot; lets us locally define an expression, which can
  -- be good for clarity in the model!
  -- here we say that X first moved in the middle
  let second = Game.nextState[Game.initialState] |
    second.board[1][1] = X
  -- ...but X didn't win
  all s: State | not winner[s, X]
} for exactly 10 State for {nextState is linear}
</code></pre>
</details>
<p>We should get a counterexample if we run that predicate.</p>
<p>We could also write this using an assertion (which would fail) rather than a <code>run</code>:</p>
<pre><code>pred xWins {
  all s: State | not winner[s, X]
}
assert moveInMiddle is sufficient for xWins 
  for exactly 10 State for {nextState is linear}
</code></pre>
<hr />
<p>You might wonder how <code>assert</code> can be used for predicates that take arguments. For example, suppose we had defined <code>wellformed</code> to take a board, rather than quantifying over <code>all</code> boards in its body. The <code>assert</code> syntax can take (one layer of) quantification. Would <code>move</code> preserve <code>wellformed</code>-ness?</p>
<p><strong>TODO: mismatch; prior sections do have a 1-ary wellformed?</strong></p>
<p>Here's how we'd write that. Notice we don't even need to use the <code>Game</code> here (and thus don't need to give the <code>is linear</code> annotation)! We're just asking Forge about 2 boards at a time:</p>
<pre><code>pred someMoveFromWF[pre, post: Board] { 
  wellformed[pre]
  some r, c: Int, p: Player | move[pre, r, c, p, post]
}
assert all pre,post: Board | move[pre,post] is sufficient for wellformed[post] 
</code></pre>
<h3 id="reminder-the-evaluator"><a class="header" href="#reminder-the-evaluator">Reminder: The Evaluator</a></h3>
<p>If you're viewing an instance, you can always select the evaluator tray and enter Forge syntax to see what it evaluates to in the instance shown. You can enter both formulas and expressions. We also have the ability to refer to atoms in the world directly. E.g., we could try:</p>
<pre><code class="language-alloy">all s: Board | not winner[s, X]
</code></pre>
<p>but also (assuming <code>Board0</code> is an atom in the instance we're currently viewing):</p>
<pre><code class="language-alloy">winner[Board0, X]
</code></pre>
<h3 id="going-further"><a class="header" href="#going-further">Going Further</a></h3>
<p>This illustrates a new class of queries we can ask Forge. Given parties following certain <em>strategies</em>, is it possible to find a trace where one strategy fails to succeed vs. another? </p>
<p><strong>Challenge exercise:</strong> Write a <code>run</code> that searches for a game where both parties always <em>block</em> immediate wins by their opponent. Is it ever possible for one party to win, if both will act to prevent a 3-in-a-row on the next turn?</p>
<h2 id="modeling-tip-dealing-with-unsatisfiability"><a class="header" href="#modeling-tip-dealing-with-unsatisfiability">Modeling Tip: Dealing with Unsatisfiability</a></h2>
<p>Overconstraint bugs, where some instances may be unintentionally ruled out by our model, can be a nightmare to detect and fix. Maybe you wrote an <code>assert</code> and it seemed to never stop. Maybe you wrote a <code>run</code> command and Forge just produced an <code>UNSAT</code> result—after a long wait.</p>
<p>Getting back an unsat result <em>can</em> take a long time. Why? Think of the search process. If there is a satisfying instance, the solver can find it early. If there isn't, the solver needs to explore the entire space of possibilities. There are smart algorithms for this, and the solver is not <em>really</em> enumerating the entire space of instances, but the general idea holds. </p>
<p>So if you run Forge and it doesn't seem to ever terminate, it's not necessarily a Forge problem. Overconstraint bugs can produce this behavior, too.</p>
<p>So, how do you debug a problem like this? The first thing I like to do is reduce the bounds (if possible) and, if I still get unsat, I'll use that smaller, faster run to debug. But at that point, we're kind of stuck. <code>UNSAT</code> isn't very helpful. </p>
<p>Today I want to show you a very useful technique for discovering the problem. There are more advanced approaches we'll get to later in the course, but for now this one should serve you well. </p>
<p><strong>TODO: insert unsat core, now that we have good highlighting!</strong></p>
<p>The idea is: encode an instance you'd expect to see as a set of constraints, run <em>those</em> constraints only, and then use the evaluator to explore why it fails your other constraints. Let's do an example!</p>
<p><strong>TODO: this is taken from a homework, not one of the above... should rewrite</strong></p>
<pre><code class="language-alloy">#lang froglet 

sig State {
  top: lone Element
}
sig Element {
  next: lone Element             
}

pred buggy {
  all s: State | all e: Element {
    s.top = e or reachable[e, s.top, next]
  }
  some st1, st2: State | st1.top != st2.top     
  all e: Element | not reachable[e, e, next]
}
test expect {
  exampleDebug: {buggy} is sat
}
</code></pre>
<p>This test fails. But why?</p>
<pre><code class="language-alloy">run {
  some st1, st2: State |
  some ele1, ele2: Element | {
    st1.top = ele1
    st2.top = ele2
    ele1.next = ele2   
    no ele2.next    
  }
} for exactly 2 State, exactly 2 Element
</code></pre>
<p>Given this instance, the question is: <strong>why didn't Forge accept it?</strong> There must be some constraint, or constraints, that it violates. Let's find out which one. We'll paste them into the evaluator...</p>
<ul>
<li><code>some st1, st2: State | st1.top != st2.top</code>? This evaluates to <code>#t</code> (true). No problem there.</li>
<li><code>  all s: State | all e: Element { s.top = e or reachable[e, s.top, next] }</code>? This evaluates to <code>#f</code> (false). So this is a problem.</li>
</ul>
<p>Now we proceed by breaking down the constraint. The outer shell is an <code>all</code>, so let's plug in a concrete value:</p>
<ul>
<li><code>all e: Element { State0.top = e or reachable[e, State0.top, next] }</code>? This evaluates to <code>#f</code>. So the constraint fails for <code>State0</code>. </li>
</ul>
<p><strong>Important</strong>: Don't try to name specific states in your model. They <em>don't exist</em> at that point. </p>
<p>Which element does the constraint fail on? Again, we'll substitute concrete values and experiment:</p>
<ul>
<li><code>State0.top = Element0 or reachable[Element0, State0.top, next]</code>? This evaluates to <code>#t</code>. What about <code>State0.top = Element1 or reachable[Element1, State0.top, next]</code>?</li>
</ul>
<p>Following this process very often leads to discovering an over-constraint bug, or a misconception the author had about the goals of the model or the meaning of the constraints. </p>
<p><strong>Question: What's the problem here?</strong></p>
<details>
<summary>Think, then click!</summary>
<p>Since the <code>next</code> field never changes with time, the <code>all</code> constraint doesn't allow states to vary the <code>top</code> of the stack. Instead, we need a weaker constraint to enforce that the stack is shaped like a state.</p>
</details>
<h2 id="aside-reminder-about-examples"><a class="header" href="#aside-reminder-about-examples">Aside: Reminder About Examples</a></h2>
<p><strong>TODO: should this part go to the Q and A for traces?</strong></p>
<p>Where an <code>assert</code> or <code>run</code> is about checking satisfiability or unsatisfiability of some set of constraints, an <code>example</code> is about whether a <em>specific</em> instance satisfies a given predicate. This style of test can be extremely useful for checking that (e.g.) small helper predicates do what you expect.</p>
<p>Why use <code>example</code> at all? A couple of reasons:</p>
<ul>
<li>It is often much more convenient (once you get past the odd syntax) than adding <code>one sig</code>s or <code>some</code> quantification for every object in the instance, provided you're trying to describe an <em>instance</em> rather than a property that defines a set of them---which becomes a better option as models become more complex.</li>
<li>Because of how it's compiled, an <code>example</code> can sometimes run faster than a constraint-based equivalent. </li>
</ul>
<p>You may be wondering whether there's a way to leverage that same speedup in a <code>run</code> command. Yes, there is! But for now, let's get used to the syntax just for writing examples. Here are some, well, examples:</p>
<pre><code class="language-alloy">pred someXTurn {some s: State | XTurn[s]}
example emptyBoardXturn is {someXTurn} for {
  State = `State0
  no `State0.board
}
</code></pre>
<p>Here, we've said that there is one state in the instance, and its <code>board</code> field has no entries. We could have also just written <code>no board</code>, and it would have worked the same.</p>
<pre><code class="language-alloy">-- You need to define all the sigs that you'll use values from
pred someOTurn {some b: Board | OTurn[b]}
example xMiddleOturn is {someOTurn} for {
  Board = `Board0
  Player = `X0 + `O0
  X = `X0
  O = `O0
  `Board0.board =  (1, 1) -&gt; `X0
}
</code></pre>
<p>What about assertions, though? You can think of assertions as <em>generalizing</em> examples. I could have written something like this:</p>
<pre><code class="language-alloy">pred someXTurn {some b: Board | xturn[b]}
pred emptySingleBoard {
  one b: Board | true
  all b: Board, r,c: Int | no b.board[r][c]
}
assert emptySingleBoard is sufficient for someXTurn  
</code></pre>
<p>That's pretty coarse-grained, though. So let's write it in a better way:</p>
<pre><code class="language-alloy">pred emptyBoard[b: Board] { all r, c: Int | no b.board[r][c] }
assert all b: Board | emptyBoard[b] is sufficient for xturn[b]
</code></pre>
<p>Notice how, by adding variables to the assertion, we're able to write less-verbose assertions and re-use our predicates better. </p>
<div id="admonition-but-if-examples-are-faster-why-use-assertions" class="admonition admonish-tip">
<div class="admonition-title">
<p>But if examples are faster, why use assertions?</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt_games.html#admonition-but-if-examples-are-faster-why-use-assertions"></a></p>
</div>
<div>
<p>First, examples aren't <em>always</em> faster. There are also some models we'll write later where <code>example</code> isn't supported. And, of course, as the model becomes more complex, the example becomes longer and longer as you try to define the value of all fields.</p>
<p>But there's a more important reason: assertions can express <em>properties</em>. Because they can state arbitrary constraints, there's an analogy to property-based testing: where <code>example</code>s are like traditional unit tests, <code>assert</code>ions are like the checker predicates you wrote in Hypothesis. </p>
<p>So there's a role for both of them.</p>
</div>
</div>
<h2 id="traces-good-and-bad"><a class="header" href="#traces-good-and-bad">Traces: Good and Bad</a></h2>
<p>We've finished our model of tic-tac-toe. We could generate a full game of up to 10 board states, and reason about what was possible in any game. </p>
<p>This works great for tic-tac-toe, and also in many other real verification settings. But there's a huge problem ahead. Think about verifying properties about a more complex system—one that didn't always stop after at most 9 steps. If we want to confirm that some bad condition can never be reached, <em>how long a trace do we need to check?</em></p>
<details>
<summary>Think, then click!</summary>
<p>What's the longest (simple—i.e., no cycles) path in the transition system? That's the trace length we'd need. </p>
</details>
<p>That's potentially a lot of states in a trace. Hundreds, thousands, billions, ... So is this entire approach doomed from the start? </p>
<p>No, for at least two reasons:</p>
<ul>
<li>Often there <em>are</em> &quot;shallow&quot; bugs that can be encountered in only a few steps. In something like a protocol or algorithm, scaling to traces of length 10 or 20 can still find real bugs and increase confidence in correctness. </li>
<li>There's more than one way to verify. Generating <em>full traces</em> wasn't the only technique we used to check properties of tic-tac-toe; let's look deeper at something we saw awhile back.</li>
</ul>
<h2 id="proving-preservation-inductively"><a class="header" href="#proving-preservation-inductively">Proving Preservation Inductively</a></h2>
<p>Let's turn to a <em>programming</em> problem. Suppose that we've just been asked to write the <code>add</code> method for a linked list class in Java. The code involves a <code>start</code> reference to the first node in the list, and every node has a <code>next</code> reference (which may be null). </p>
<p>Here's what we hope is a <em>property of linked lists</em>: <strong>the last node of a non-empty list always has <code>null</code> as its value for <code>next</code></strong>. </p>
<p>How can we prove that our <code>add</code> method preserves this property, <em>without</em> generating traces of ever-increasing length? There's no limit to how long the list might get, and so the length of the longest path in the transition system is infinite: 0 nodes, 1 node, 2 nodes, 3 nodes,...</p>
<p>This might not be immediately obvious. After all, it's not as simple as asking Forge to run <code>all s: State | last.next = none</code>. </p>
<p><strong>Exercise:</strong> Why not?</p>
<details>
<summary>Think, then click!</summary>
<p>Because that would just be asking Forge to find us instances full of good states. Really, we want a sort of higher-level <code>all</code>, something that says: &quot;for all <strong>runs of the system</strong>, it's impossible for the run to contain a bad linked-list state.</p>
</details>
<p>This illustrates a <strong>central challenge in software and hardware verification</strong>. Given a discrete-event model of a system, how can we check whether all reachable states satisfy some property? You might have heard properties like this called <em>invariants</em> of the system.</p>
<p>One way to solve the problem <em>without</em> the limitation of bounded-length traces goes something like this:</p>
<ul>
<li>Step 1: Ask whether any starting states are bad states. If not, then at least we know that executions with no moves obey our invariant. (It's not much, but it's a start. It's also easy for Forge to check.)</li>
<li>Step 2: Ask whether it's possible, in any good state, to transition to a bad state. </li>
</ul>
<p>Consider what it means if both checks pass. We'd know that runs of length <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> cannot involve a bad state. And since we know that good states can't transition to bad states, runs of length <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> can't involve bad states either. And for the same reason, runs of length <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> can't involve bad states, nor games of length <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>, and so on.</p>
<h3 id="how-do-we-write-this-in-forge"><a class="header" href="#how-do-we-write-this-in-forge">How do we write this in Forge?</a></h3>
<p>This technique isn't only applicable in Forge. It's used in many other solver-based tools, including those used in industry. And modeling linked lists in Forge is very doable, but more complicated than I'd like to do at this point. So we'll demonstrate the idea on the tic-tac-toe model. </p>
<p><strong>Step 1: are there any bad states that are also starting states?</strong></p>
<pre><code class="language-alloy">assert all b: Board | initial[b] is sufficient for balanced[b]
  for 1 Board, 3 Int
</code></pre>
<p>Notice that we didn't <em>need</em> to use the <code>next is linear</code> annotation, because we're not asking for traces at all. We've also limited our scope to exactly 1 Board. We also don't need 4 integer bits; 3 suffices. This should be quite efficient. It should also pass, because the empty board isn't unbalanced. </p>
<p><strong>Step 2: are there any transitions from a good state to a bad state?</strong></p>
<p>Again, we don't need a full trace for this to work. We only need 2 boards: the pre-state and post-state of the transition:</p>
<pre><code class="language-alloy">pred moveFromBalanced[pre: Board, row, col: Int, p: Player, post: board] {
  balanced[pre]
  move[pre, row, col, p, post]
}
assert all pre, post: Board, row, col: Int, p: Player | 
  moveFromBalanced[pre, row, col, p, post] is sufficient for balanced[post]
    for 2 Board, 3 Int
</code></pre>
<p>If both of these pass, we've just shown that bad states are impossible to reach via valid moves of the system.</p>
<div id="admonition-aside-performance" class="admonition admonish-note">
<div class="admonition-title">
<p>Aside: Performance</p>
<p><a class="admonition-anchor-link" href="chapters/ttt/ttt_games.html#admonition-aside-performance"></a></p>
</div>
<div>
<p>That second step is still pretty slow on my laptop: around 10 or 11 seconds to yield <code>UNSAT</code>. Can we give the solver any help? Hint: <strong>is the set of possible values for <code>pre</code> bigger than it really needs to be?</strong></p>
<details>
<summary>Think, then click!</summary>
<p>If we assume the <code>pre</code> board is well-formed, we'll exclude transitions involving invalid boards. There are a lot of these, even at <code>3 Int</code>, since row and column indexes will range from <code>-4</code> to <code>3</code> (inclusive). We could do this either by asserting <code>wellformed[pre]</code> or by refining the bounds we give Forge.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="counterexamples-to-induction"><a class="header" href="#counterexamples-to-induction">Counterexamples To Induction</a></h1>
<p>This section contains a running exercise where we model binary search on an array. You'll need <a href="chapters/inductive/./binarysearch_template.frg">this exercise template</a> to begin. For your reference, the completed version with comments from Q&amp;A, is <a href="chapters/inductive/./binarysearch_inclass.frg">here</a>.</p>
<p><strong>TODO: insert reminder of what binary search is</strong></p>
<h2 id="conceptual-setup"><a class="header" href="#conceptual-setup">Conceptual Setup</a></h2>
<p>When we're talking about whether or not a reachable state violates a desirable property <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> (recall we sometimes say that if this holds, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is an <em>invariant</em> of the system), it's useful to think geometrically. Here's a picture of the space of <em>all states</em>, with the cluster of &quot;good&quot; states separated from the &quot;bad&quot;:</p>
<p><img src="https://i.imgur.com/n3F16P4.png" alt="" /></p>
<p>If this space is large, we probably can't use trace-finding to get a real <em>proof</em>: we'd have to either:</p>
<ul>
<li>reduce the trace length (in which case, maybe there's a bad state <em>just barely</em> out of reach of that length but we'd never know); or </li>
<li>possibly be waiting for the solver until the sun expands and engulfs the earth.</li>
</ul>
<p>Complete-trace checking is still useful, especially for finding shallow bugs. The technique is used in industry, and inspires other, more sophisticated algorithmic techniques. But we need more than one tool in our bag of tricks, so let's keep developing the idea of only looking at 1 or 2 states at a time. </p>
<div id="admonition-original-paper" class="admonition admonish-note">
<div class="admonition-title">
<p>Original paper</p>
<p><a class="admonition-anchor-link" href="chapters/inductive/bsearch.html#admonition-original-paper"></a></p>
</div>
<div>
<p>If you're interested, you can read the original paper on using solvers to find traces of bounded length by <a href="https://www.cs.cmu.edu/~emc/papers/Books%20and%20Edited%20Volumes/Bounded%20Model%20Checking.pdf">Biere, et al.</a>.</p>
</div>
</div>
<p>To do that, we'll go back over what we did in the last section, but in more detail.</p>
<h3 id="step-1-initiation-or-base-case"><a class="header" href="#step-1-initiation-or-base-case">Step 1: Initiation or Base Case</a></h3>
<p>Let's break the problem down. What if we just consider reachability for traces of length <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>---that is, traces of only one state, an <code>initial</code> state?</p>
<p>This we can check in Forge just by asking for a state <code>s</code> satisfying <code>{initial[s] and wellformed[s] and not P[s]}.</code> There's no exponential blowup with trace length since the transition predicates are never even involved! If we see something like this:</p>
<p><img src="https://i.imgur.com/Aia9V0q.png" alt="" /></p>
<p>We know that at least the starting states are good. If instead there was a region of the starting states that overlapped the bad states, then we immediately know that the property isn't invariant.</p>
<h3 id="step-15-restrictions-spur-creativity"><a class="header" href="#step-15-restrictions-spur-creativity">Step 1.5: Restrictions Spur Creativity</a></h3>
<p>We can also check whether there are bad states within <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> transition. We're using the transition predicate (or predicates) now, but only <em>once</em>. Forge can also do this; we ask for a pair of states <code>s0</code>, <code>s1</code> satisfying <code>{initial[s0] and someTransition[s0, s1] and not P[s1]}</code> (where <code>someTransition</code> is my shorthand for allowing any transition predicate to work). </p>
<p>If Forge doesn't find any way for the second state to violate <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, it means we have a picture like this:</p>
<p><img src="https://i.imgur.com/NdA7RwF.png" alt="" /></p>
<p>Note that in general, there might be overlap (as shown) between the set of possible initial states and the set of possible second states. For example, imagine if we allowed a <code>doNothing</code> transition at any time—then the starting state could be reached in any number of steps.</p>
<p>We could continue to extend this idea to 2 transitions (3 states), 3 transitions (4 states), and so on. If we keep following this process, we'll arrive back at the fully trace-based approach. And anyway, to address the exponential-blowup problem of traces, we said that we would only ever look at 1 or 2 states. But how can we ever get something useful, that is, a result that isn't limited to trace length 1?</p>
<p>We can (often) use these small, efficient queries to show that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> holds at <em>any</em> finite length from a starting state. But how? By giving something up. In fact, we'll give up something apparently vital: we'll <em>stop caring whether the pre-state of the bad transition is reachable or not.</em></p>
<h3 id="step-2-consecution-or-inductive-case"><a class="header" href="#step-2-consecution-or-inductive-case">Step 2: Consecution or Inductive Case</a></h3>
<p>We'll ask Forge whether <code>{P[s0] and someTransition[s0, s1] and not P[s1]}</code> is satisfiable for <em>any</em> pair of states. Just so long as the pre-state satisfies <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> and the post-state doesn't. We're asking Forge if it can find a transition that looks like this:</p>
<p><img src="https://i.imgur.com/CWSjSrr.png" alt="" /></p>
<p>If the answer is <em>no</em>, then it is simply impossible (up to the bounds we gave Forge) for any transition predicate to stop property <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> from holding: if it holds in the pre-state, it <em>must</em> hold in the post-state. </p>
<p>But if that's true, and we know that all initial states satisfy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, then all states reachable in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> transition satisfy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> (by what we just checked). And if <em>that's</em> true, then all states reachable in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> transitions satisfy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> also (since all potential pre-states must satisfy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>). And so on: <em>any</em> state that's reachable in a finite number of transitions must satisfy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>. </p>
<p>If you've seen &quot;proof by induction&quot; before in another class, we've just applied the same idea here. Except, rather than using it to show that the sum of the numbers from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> (or some other toy algebraic example) we've just used it to prove that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is invariant in a system.</p>
<p>In Tic-Tac-Toe, we let property <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> be &quot;cheating states can't be reached with legal moves&quot;. In an operating system, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> might be &quot;two processes can never modify a block of memory simultaneously&quot;. In hardware, it might be &quot;only one device has access to write to the bus at any point&quot;. In a model of binary search, it might be &quot;if the target is in the array, it's located between the <code>low</code> and <code>high</code> indexes&quot;.</p>
<div id="admonition-a-cs-perspective" class="admonition admonish-note">
<div class="admonition-title">
<p>A CS Perspective</p>
<p><a class="admonition-anchor-link" href="chapters/inductive/bsearch.html#admonition-a-cs-perspective"></a></p>
</div>
<div>
<p>I think that showing a system preserves an invariant might be a far more relatable and immediately useful example of the induction principle than summation. That's not to dismiss mathematical induction! I quite like it (and it's useful for establishing some useful results related to Forge). But multiple perspectives enrich life.</p>
</div>
</div>
<p><strong>Exercise: Try it!</strong> Open up the binary search <a href="chapters/inductive/./binarysearch_template.frg">model starter template</a>. You should see a pair of tests labeled <code>initStep</code> and <code>inductiveStep</code> under a comment that says &quot;Exercise 1&quot;. Fill these in using the logic above, and run them. Do they both pass? Does one fail?</p>
<h3 id="what-if-forge-finds-a-counterexample"><a class="header" href="#what-if-forge-finds-a-counterexample">What if Forge finds a counterexample?</a></h3>
<p>What if Forge <em>does</em> find a transition that fails to preserve our property <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>? Does it mean that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is not an invariant of the system?</p>
<details>
<summary>Think, then click!</summary>
<p>No! It just means that <strong>the pre-state that Forge finds might not <em>itself</em> be reachable!</strong>  In that case, we'll say that while <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> might be an invariant, it's not <em>inductively invariant</em>.</p>
<p>So, this 2-states-at-a-time technique can be a great way to quickly show that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is invariant. But if it fails, we need to do more work!</p>
</details>
<p>We see this happen when we try to run the above checks for our binary-search model! The <code>inductiveStep</code> test fails, and we get a counterexample. </p>
<h3 id="fix-1-maybe-the-property-is-wrong"><a class="header" href="#fix-1-maybe-the-property-is-wrong">Fix 1: Maybe the Property is Wrong!</a></h3>
<p>Sometimes there are conditions about the world that we need in order for the system to work at all. For example, we already require the array to be sorted, or binary search breaks. Are there other requirements? </p>
<p>It turns out that there are. Here's one: <a href="https://research.google/blog/extra-extra-read-all-about-it-nearly-all-binary-searches-and-mergesorts-are-broken/">the classic way to write binary search is actually broken in most systems</a>. If I write <code>mid = (low + high) / 2</code>, and I'm working with machine integers (which have a maximum value), what happens if the array is large relative to the maximum integer in the system?</p>
<details>
<summary>Think, then click!</summary>
<p>On a 32-bit system, the maximum <code>int</code> value is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">294</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">967</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">295</span></span></span></span>, and any value over that &quot;wraps around&quot;. So if the array is just a couple billion elements long (easily reachable even in the early 2000's at Google scale), the value of <code>(high+low)</code> can overflow. For example: </p>
<pre><code>low = 2,500,000,000
high = 3,000,000,000
low + high = 5,500,000,000 - 4,294,967,295 = 1,205,032,705
</code></pre>
<p>But this index isn't between <code>low</code> and <code>high</code>, and so the algorithm breaks. In Forge, we can adjust the number of bits available, and see the problem much sooner. </p>
</details>
<p>We're not trying to <em>fix</em> this problem in the algorithm. This is a real bug. Our modeling found it (admittedly, 20 years after the linked blog post). So let's remember the issue, and proceed. If the array is small enough, is the algorithm correct? We'll add a <em>global assumption</em> that the array is not so large. We'll add that in the <code>safeArraySize</code> predicate, which we'll then use in the 2 checks. </p>
<p>How can we express what we want: that the array is not too large?</p>
<details>
<summary>Think, then click!</summary>
<p>The core challenge here is that we'll never have enough integers to actually count <code>#Int</code>. However, we <em>can</em> ask for the maximum integer---<code>max[Int]</code>. So we could say that <code>arr.lastIndex</code> is less than <code>divide[max[Int], 2]</code>. This might be a little conservative, but it guarantees that the array is never larger than half of the maximum integer, and so it works for our purposes here.</p>
</details>
</br>
<p><strong>Exercise</strong>: Try expressing this in the <code>safeArraySize</code> predicate, and adding it to the test that failed. Add a comment explaining why this is a requirement.</p>
<h3 id="fix-2-enriching-the-invariant"><a class="header" href="#fix-2-enriching-the-invariant">Fix 2: Enriching the Invariant</a></h3>
<p>Sometimes the property we're hoping to verify <em>is</em> invariant in the system, but it's <em>not</em> preserved by the system transitions when we look at them in isolation. This would mean that the pre-state in any counterexample isn't actually reachable. In the full-trace approach, we didn't have this problem, since the trace was rooted in an initial state. <strong>This is the tradeoff of the inductive approach!</strong> We gain a big performance boost, but sometimes we have to do more work to make progress.</p>
<p>Concretely, we'll need to <em>verify something stronger</em>. At the very least, if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is the pre-state of the counterexample we were given, we need to change our property to be (where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is the old property) &quot;<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> and the state isn't <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>&quot;. In practice, we try to add something more general that expresses the root cause of why <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> shouldn't be reachable.</p>
<p>The technique is sometimes called &quot;enriching the invariant&quot;. </p>
<p><strong>Exercise</strong>: Do you believe the counterexample you're getting is reachable? If not, what is it about the state that looks suspicious?</p>
<p><strong>Exercise</strong>: Now add new constraints to the <code>bsearchInvariant</code> predicate that exclude this narrow criterion. <em>Be careful not to exclude too much!</em> An over-constrained property can be easy to verify, but may not actually give many guarantees.</p>
<h2 id="but-can-we-trust-the-model"><a class="header" href="#but-can-we-trust-the-model">But Can We Trust The Model?</a></h2>
<p>Look again at the two checks we wrote. If <code>initial</code> were unsatisfiable, surely the Step 1 check would also be unsatisfiable (since it just adds <em>more</em> constraints). Similarly, unsatisfiable transition predicates would limit the power of Step 2 to find ways that the system could transition out of safety. If either of these bugs existed, Forge would find no initial bad states, and/or no bad transitions. It would look like the property was invariant, but really the check out pass because our model was overconstrained. </p>
<p>More concretely, Step 1 checks that <code>all s: State | initial[s] implies good[s]</code>. But if no <code>s</code> can possibly satisfy <code>initial</code>, then the overall constraint evaluates to true—no counterexamples are possible! This problem is called <em>vacuity</em> or <em>vacuous truth</em>, and it's a threat to modeling success. </p>
<div id="admonition-put-another-way" class="admonition admonish-note">
<div class="admonition-title">
<p>Put another way...</p>
<p><a class="admonition-anchor-link" href="chapters/inductive/bsearch.html#admonition-put-another-way"></a></p>
</div>
<div>
<p>Suppose I told you: &quot;All my billionaire friends love Logic for Systems&quot;. I have, as far as I know anyway, no billionaire friends. So is the sentence true or false? You might (quite reasonably) say that it shouldn't be either true or false, but some sort of third value that indicates inapplicability. There are logics that work that way, but they tend to either be complicated, or to complicate building tools using them. So Forge uses classical logic, where <code>A implies B</code> is equivalent to <code>(not A) or B</code>. </p>
<p>The result is: Forge would say that the sentence is true. After all, there's no billionaire friend of mine who <em>doesn't</em> love Logic for Systems...
~~</p>
<p><strong>Watch out! Pay attention!</strong>
This is a problem you might first hear about in a logic or philosophy textbook. So there's a risk you'll think vacuity is silly, or possibly a topic for debate among people who like drawing their As upside down and their Es backwards, and love writing formulas with lots of Greek letters in. <strong>Don't be fooled!</strong> Vacuity is a major problem even in industrial settings, because verification tools are literal-minded. </p>
<p><strong>TODO: insert industry links from EdStem ref'd in 2024</strong></p>
<p>At the very least, we'd better test that the left-hand-side of the implication can be satisfied. This isn't a guarantee of trustworthiness, but it's a start. And it's easy to check with Forge that some state can be <code>initial</code> or some transition can be executed:</p>
<pre><code class="language-forge">assert {some s: State | initial[s]} is sat
assert {some pre, post: State | transition[pre, post]} is sat
</code></pre>
<p>Make sure you're always testing vacuity. Errors like this are more common than you might think.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bsts-recursive-descent"><a class="header" href="#bsts-recursive-descent">BSTs: Recursive Descent</a></h1>
<p>When we last modeled <a href="chapters/bst/../bst/bst.html">binary search trees</a>, we defined what it meant to be a binary tree, and had two different candidates for the BST invariant. Now we'll return to BSTs and model the classic recursive <em>BST search</em> algorithm. Just like games of tic-tac-toe, a BST search can be represented as a sequence of states that evolve as the algorithm advances. </p>
<p>As a reminder, we had defined binary-tree nodes like this:</p>
<pre><code class="language-forge">sig Node {
  key: one Int,     -- every node has some key 
  left: lone Node,  -- every node has at most one left-child
  right: lone Node  -- every node has at most one right-child
}
</code></pre>
<p>Just like in the last example, we'll start by adding a sig for the state of the system. The &quot;system&quot; here is the recursive search, so it should have fields that are used in that context. Really, the only thing that changes during the recursive descent is the node currently being visited:</p>
<pre><code class="language-forge">-- Since a BST descent doesn't need to backtrack, the state can be fairly simple.
sig SearchState {
    current: lone Node -- the node currently being visited
}
</code></pre>
<p>Then we'll define a <code>one</code> sig for the overall search. As with tic-tac-toe, Forge will find instances that represent a single search, embodied by the <code>Search</code> atom and its fields:</p>
<pre><code class="language-forge">one sig Search {
    target: one Int, -- the target of the search (never changes)
    -- The first state and successor-state function for this trace
    initialState: one SearchState,
    nextState: pfunc SearchState -&gt; SearchState
}
</code></pre>
<p>What does an initial state of the search look like? We'd better be at the root of the tree! </p>
<pre><code class="language-forge">pred init[s: SearchState] {    
    isRoot[s.current]
}
</code></pre>
<p>Now for the more complicated part. How does a step of the recursive descent work? At any given node:</p>
<ul>
<li>First, it checks whether <code>current.key = target</code>. If yes, it's done.</li>
<li>It checks whether <code>current.key &lt; target</code>. If yes, it moves to the left child if it exists, and returns failure otherwise.</li>
<li>It checks whether <code>current.key &gt; target</code>. If yes, it moves to the right child if it exists, and returns failure otherwise.</li>
</ul>
<p>That's not so bad, but it feels like there are two different kinds of transition that our system might take. Let's give each of them their own predicates, just to avoid them getting tangled with each other: </p>
<ul>
<li><code>descendLeft</code> will apply if the target is to the left.</li>
<li><code>descendRight</code> will apply if the target is to the right.
If neither can apply, the algorithm is done: either the target has been found, or the search has &quot;hit bottom&quot; without finding the target.</li>
</ul>
<p>Let's start writing them, beginning with <code>descendLeft</code>. We'll follow the discipline of separating the <em>guard</em> and <em>action</em> of each transition <code>pred</code>:</p>
<pre><code class="language-forge">pred descendLeft[pre, post: SearchState] {
  -- GUARD 
  Search.target &lt; pre.current.key
  some pre.current.left
  -- ACTION
  post.current = pre.current.left
}
</code></pre>
<p>Because only the current node is a component of the search state, we only need to define the new current node in the action.</p>
<p><strong>Exercise:</strong> Write <code>descendRight</code> yourself. The structure should be very similar to <code>descendLeft</code>. </p>
<details>
<summary>Think, then click!</summary>
<p>You might write something like this:</p>
<pre><code class="language-forge">pred descendRight[pre, post: SearchState] {
  -- GUARD 
  Search.target &gt; pre.current.key
  some pre.current.right
  -- ACTION
  post.current = pre.current.right
}
</code></pre>
</details>
<hr />
<p>Let's do some basic validation:</p>
<pre><code class="language-forge">test expect {
    -- let's check that these two transitions are mutually-exclusive
    r_l_together: {some s: SearchState | {descendLeft[s] and descendRight[s]}} for 7 Node is unsat
    -- let's check that transitions are all possible to execute
    r_sat: {some s: SearchState | descendRight[s]} for 7 Node is sat
    l_sat: {some s: SearchState | descendLeft[s]} for 7 Node is sat
    -- initial state is satisfiable
    init_sat: {some s: SearchState | init[s]} for 7 Node is sat
}
</code></pre>
<hr />
<p>Now we'll combine these predicates into one that defines the entire recursive descent. The shape of this predicate is somewhat boilerplate; soon we'll see how to get rid of it entirely. For now, we'll just copy from the tic-tac-toe example and make small, local changes. Namely:</p>
<ul>
<li>we called the trace sig <code>Search</code>, not <code>Game</code>;</li>
<li>we called the state sig <code>SearchState</code>, not <code>Board</code>; and </li>
<li>we have two different transition predicates to include.</li>
</ul>
<pre><code class="language-forge">pred traces {
    -- the graph is well-formed to begin with
    binary_tree
    -- The trace starts with an initial state
    init[Search.initialState]
    no sprev: SearchState | Search.nextState[sprev] = Search.initialState
    -- Every transition is a valid move
    all s: SearchState | some Search.nextState[s] implies {
        descendLeft [s, Search.nextState[s]] or 
        descendRight[s, Search.nextState[s]]
    }
}
</code></pre>
<p>Let's run it!</p>
<pre><code class="language-forge">run {traces} for exactly 7 Node, 5 SearchState for {nextState is plinear}
</code></pre>
<p>The output may initially be overwhelming: by default, it will show <em>all</em> the atoms in the world and their relationships, including each <code>SearchState</code>. You could stay in the default visualizer and mitigate the problem a <em>little</em> by clicking on &quot;Theme&quot; and then &quot;Add Projection&quot; for <code>SearchState</code>. The problem is that this hides the <code>current</code> node indicator for the current state, since the current state becomes implicit. </p>
<p>Instead, let's use a custom visualization. There are multiple options included with this book:</p>
<ul>
<li><a href="chapters/bst/./bst.js"><code>bst.js</code></a>, which visualizes the tree itself, without any regard to the descent. This is useful for debugging the basic tree model and the invariants themselves.</li>
<li><a href="chapters/bst/./bst_descent.js"><code>bst_descent.js</code></a>, which visualizes the <em>descent</em> in one picture. </li>
<li>(Don't run this yet!) <code>bst_temporal.js</code>, which visualizes a Temporal Forge version of the model, which we'll get to soon.</li>
</ul>
<p>If we run <code>bst_descent.js</code> for this instance, it will draw the tree and highlight the path taken in the recursive descent. A node with the target key will have a thick border. A node that's visited in the descent will have a red border. So a correct descent should never show a node with a thick border that isn't red. </p>
<p><strong>TODO fill: how to run? Did we describe this already?</strong></p>
<p>This is easier to read, but also a little worrying: we see two nodes visited, and they aren't directly connected! </p>
<p><strong>Exercise:</strong> What's going on? (Hint: examine the table view. How many search states are there? Are they all in the trace?)</p>
<details>
<summary>Think, then click!</summary>
<p>The problem is that we allowed <code>SearchState</code> atoms to exist without being used in the trace. The visualizer script is highlighting a node that <em>any</em> <code>SearchState</code> uses. So we have two options: </p>
<ul>
<li>change the visualizer script to only look at states reachable from the first one; or</li>
<li>add a constraint that forces all <code>SearchState</code> atoms to be used. </li>
</ul>
<p>We'll go for the second fix, adding this line to the <code>traces</code> predicate:</p>
<pre><code class="language-forge">-- All SearchStates are used
all s: SearchState | { 
  s = Search.initialState or 
  reachable[s, Search.initialState, Search.nextState]
}
</code></pre>
</details>
<p>Ok, that's better, but we still aren't seeing a <em>complete</em> descent. To fix that, we'll say that, eventually, the descent either reaches bottom or a node with the target value:</p>
<pre><code class="language-alloy">run {
  binary_tree 
  traces
  some s: SearchState | s.current.key = Search.target or (no s.current.left and no s.current.right)
} for exactly 7 Node, 5 SearchState for {nextState is plinear}
</code></pre>
<p>That's more like it. But what about the invariants? We only said <code>binary_tree</code> had to hold, which means that the tree being searched isn't necessarily a binary <em>search</em> tree yet.</p>
<h3 id="trying-different-invariants"><a class="header" href="#trying-different-invariants">Trying Different Invariants</a></h3>
<p>In our <a href="chapters/bst/./bst.html">original BST model</a>, we'd sketched two different invariants:</p>
<p><strong>Version 1</strong> (<code>invariant_v1</code>): For all nodes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>:</p>
<ul>
<li>all left-descendants of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> have a key less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key; and </li>
<li>all right-descendants of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> have a key greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key.</li>
</ul>
<p><strong>Version 2</strong> (<code>invariant_v2</code>): For all nodes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>:</p>
<ul>
<li>the left child of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> (if any) has a key less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key; and </li>
<li>the right child of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> (if any) has a key greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>'s key.</li>
</ul>
<p>We were able to look at trees that met one invariant but not another, but now we can do something much more powerful: we can ask Forge to show us how the differing invariants affect the recursive descent on the tree! If an invariant is &quot;wrong&quot;, surely it will cause the descent to fail in some way. Since we've already modeled the descent, this should be easy. Let's try it for <code>invariant_v2</code>:</p>
<pre><code class="language-forge">run {
  binary_tree     -- it must be a binary tree
  all n: Node | invariant_v2[n]    -- additionally, the tree satisfies invariant version 1
  some n: Node | n.key = Search.target -- the target is present
  traces          -- do a search descent
  -- Finally, the trace finishes the search
  some s: SearchState | s.current.key = Search.target or no (s.current.left + s.current.right)
} for exactly 7 Node, 5 SearchState for {nextState is plinear}
</code></pre>
<p>This will show us instances of a descent for a tree following <code>invariant_v2</code>. To see descents for trees following the other invariant, just change <code>invariant_v2</code> to <code>invariant_v1</code>. If you look at a few instances for <code>invariant_v2</code>, you should notice that one of the invariants can make the descent fail: the tree contains the target, but it's never found. You'll see something like this: </p>
<img alt="a binary tree following invariant 2, where the recursive descent fails to find the target" src="chapters/bst/./bst_invar2_buggy.png" width=60%/>
<h3 id="verifying-bsts"><a class="header" href="#verifying-bsts">Verifying BSTs</a></h3>
<p>Notice what just happened. We built up our structural model to contain a collection of related features, such as:</p>
<ul>
<li>binary trees with numeric node values; </li>
<li>multiple possible invariants for these trees to follow; and </li>
<li>a recursive-descent algorithm on those binary trees.</li>
</ul>
<p>Before, we could only ask Forge to show us that the invariants were different, which wasn't very useful—at least not immediately. Then, in this section, we added a discrete event model of BST search atop the original, which gave us something more powerful: representations of how the different invariants might <em>impact</em> the search algorithm. We can even verify that <code>invariant_v1</code> is correct (for reasonably-sized example trees). </p>
<p><strong>Exercise:</strong> Do this now! Write either a <code>run</code> or <code>test expect</code> confirming that if <code>invariant_v1</code> holds for all nodes, then the recursive descent will be successful at finding a present target value. </p>
<details>
<summary>Think, then click!</summary>
<p>I'll write my version as a <code>run</code>, so we can better match the one above. </p>
<pre><code class="language-forge">run {
  binary_tree    
  all n: Node | invariant_v1[n]   
  some n: Node | n.key = Search.target -- the target is present
  traces     
  -- The trace finishes the search without finding the target
  some s: SearchState | no (s.current.left + s.current.right)
  no s: SearchState   | s.current.key = Search.target
} for exactly 7 Node, 5 SearchState for {nextState is plinear}
</code></pre>
</details>
<p><strong>Bonus Exercise:</strong> Do the numeric bounds in the commands above seem OK to you? Is there any situation you might be worried about, beyond example trees that are bigger than 7 nodes?</p>
<details>
<summary>Think, then click!</summary>
<p>Trees aren't always balanced. It's possible that there could be <code>7</code> nodes arranged like a linear list, with the target value at the bottom-most node. In this case, <code>5</code> states wouldn't be enough; Forge wouldn't ever even look for such a situation, because we said that the descent ended when it reached the bottom of the tree, and we lack the states to get there.</p>
<p>This is a great example of how carefully considering bounds and exploring the structural model before doing more complex verification is vital. To really be complete for 7-node trees, we would need up to 7 <code>SearchState</code> atoms as well.</p>
</details>
<h3 id="looking-ahead"><a class="header" href="#looking-ahead">Looking Ahead</a></h3>
<p>Of course, this is still a very simple model. Binary Search Trees are much less complicated than many other data structures, and even complex data structures are only part of a larger system. </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="validating-models"><a class="header" href="#validating-models">Validating Models</a></h1>
<p>As we start modeling more complex systems, models become more complex. The more complex the model is, the more important it is to test the model carefully. Just like in software testing, however, you can never be 100% sure that you have tested everything. Instead, you proceed using your experience and following some methodology. </p>
<p>Let's get some practice with this. Before we start modifying our locking algorithm model, we should think carefully---both about testing, but also about how the model reflects the real world. </p>
<h2 id="principle-1-are-you-testing-the-model-or-the-system"><a class="header" href="#principle-1-are-you-testing-the-model-or-the-system">Principle 1: Are you testing the <em>model</em>, or the <em>system</em>?</a></h2>
<p>When you write a test, it's important to know whether you're actually writing it to validate the model (i.e., check whether the model accurately reflects the system you're modeling) or to confirm some property you expect of the system (via a hopefully-good model). The difference is sometimes subtle, but important.</p>
<p>Here's an example. Back when we modeled <a href="chapters/validation/../bst/descent.html">recursive descent on binary-search trees</a>, we wrote a test like this:</p>
<pre><code>assert {some s: SearchState | {descendLeft[s] and descendRight[s]}} is unsat for 7 Node 
</code></pre>
<p>Is this testing the model, or testing the system?</p>
<details>
<summary>Think, then click!</summary>
<p>This is a test of the <em>model</em>. We're checking that these two transition predicates we wrote can't execute at the same time. If this wasn't true, we wouldn't be faithfully modeling the recursive descent, because it would mean that sometimes, the two branches of the algorithm's <code>if</code> conditional would execute in parallel. </p>
</details>
<p>We then wrote a check like this:</p>
<pre><code>pred bs_correct {
    all n: Node | {
        n.key = SearchState.target =&gt; 
          eventually SearchState.current = n }}
assert {binary_search_tree_v1 and searchTrace} 
  is sufficient for bs_correct for 5 Node
</code></pre>
<p>What is this testing?</p>
<details>
<summary>Think, then click!</summary>
<p>This is checking that, assuming our model is correct, the <em>system</em> gives us a property that we care about. When it passes, we gain knowledge about binary search trees—not so much about our model of them. </p>
<p>Of course, if it <em>failed</em> we'd learn that our model was wrong, but only because we know that BSTs work! And if it passes, it's still possible that the model is wrong. This is why, in practice, we test the model. For example, if <code>searchTrace</code> turned out to be unsatisfiable, that would make this property check pass for the wrong reasons. So we'll test:</p>
<pre><code>assert {searchTrace} is sat for 5 Node
</code></pre>
</details>
<h2 id="principle-2-test-both-inclusion-and-exclusion"><a class="header" href="#principle-2-test-both-inclusion-and-exclusion">Principle 2: Test both Inclusion and Exclusion</a></h2>
<p>Predicates are akin to boolean-valued functions. If I write a test like this:</p>
<pre><code>assert {some s: SearchState | descendLeft[s]} is sat for 5 Node
</code></pre>
<p>it is testing that some state can take the <code>descendLeft</code> transition. We call this a <em>test of inclusion</em> because it checks for something being included in what a predicate accepts. But there's no guarantee yet that <code>descendLeft</code> doesn't just accept everything! So we also write <em>tests of exclusion</em>, which investigate what the predicate does not accept:</p>
<pre><code>assert {some s: SearchState | {descendLeft[s] and descendRight[s]}} is unsat for 7 Node 
</code></pre>
<p>Whenever you write an <code>is necessary</code> or <code>is sufficient</code> assertion, it always is a test of <em>exclusion</em>. Why is that?</p>
<details>
<summary>Think, then click!</summary>
<p>Because <code>assert A is sufficient for B</code> means that it should be impossible to find a way to satisfy <code>A</code> but not satisfy <code>B</code>. That is, we can always rewrite the assertion as:</p>
<pre><code>assert {A and not B} is unsat
</code></pre>
</details>
<p>The direction of implication (i.e., whether we use <code>is necessary</code> or <code>is sufficient</code>) has no bearing on whether the test is for inclusion or exclusion! These two are simply <em>always</em> tests of exclusion, just like <code>is unsat</code>.</p>
<h2 id="takeaways-1"><a class="header" href="#takeaways-1">Takeaways</a></h2>
<p>It's very easy to fool ourselves when modeling. When we're writing tests for a piece of software, there are two major threats to consider: </p>
<ul>
<li>It's possible that the <em>software</em> is has bugs in it. We hope to discover this via testing.</li>
<li>It's also possible that <em>our tests</em> are wrong <a href="chapters/validation/../properties/pbt.html">or overfit</a>.</li>
</ul>
<p>But in the modeling context, there are even more ways that our intuition could be off. E.g.:</p>
<ul>
<li>It's possible that <em>the system</em> we're modeling has bugs in it. We hope to discover this via modeling, even if we're not working directly with an implementation.</li>
<li>It's possible that <em>our model</em> has bugs in it, and thus can't be relied upon to help us understand the system. </li>
<li>It's also possible that <em>our tests</em> are wrong... </li>
</ul>
<p>Add to this the fact that we are unlikely to be able to model all aspects of a system to their full depth. We can model a binary-tree descent or a locking algorithm, but that's no guarantee that a specific implementation will be correct. This is especially true <a href="https://www.pamelazave.com/chord-ccr.pdf">when the published algorithm is imprecise or underspecified</a>, leading to incorrect implementations.</p>
<p>Modeling is powerful. But it's not a cure-all, and its benefits don't come for free. </p>
<div id="admonition-be-clear" class="admonition admonish-tip">
<div class="admonition-title">
<p>Be clear.</p>
<p><a class="admonition-anchor-link" href="chapters/validation/validating_events.html#admonition-be-clear"></a></p>
</div>
<div>
<p>I like to clearly label my testing file to indicate where in the 2-by-2 grid an example, check or assertion lies: model vs. system, inclusion vs. exclusion. Often I'll even use separate files for the system vs. model distinction!</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="qa-event-systems"><a class="header" href="#qa-event-systems">Q&amp;A: Event Systems</a></h1>
<p><strong>TODO: consider advanced question: correspondence??? is there one between the array version and the tree version?</strong></p>
<h2 id="more-on-optimization-inst-syntax"><a class="header" href="#more-on-optimization-inst-syntax">More on Optimization: <code>inst</code> Syntax</a></h2>
<p>The syntax that you use in <code>example</code>s and to say <code>is linear</code> for a field (like you saw in the <a href="chapters/qna/../adder/rca.html">ripple-carry adder</a>) is more expressive than you've seen so far. Recall that Forge has <a href="chapters/qna/./static.html">two phases</a>: deliniating the allowed search space, and solving the constraints within that search space. This new syntax lets you define a <em>partial instance</em>, which affects the first phase to limit the possible instances the solver will consider.</p>
<p>You can even define a reusable partial instance using the <code>inst</code> command, and use it in the same place you'd use <code>{next is linear}</code> in a <code>run</code>, <code>assert</code>, etc. For example, we could pre-define the set of full adders in the <a href="chapters/qna/../adder/rca.html">ripple-carry adder</a> model, giving each an atom name:</p>
<pre><code class="language-alloy">inst fiveBits {
  FA = `FA0 + `FA1 + `FA2 + `FA3 + `FA4 + `FA5
} 
run {rca} for exactly 1 RCA for {fiveBits}
</code></pre>
<p>Because this defines the set of <code>FA</code> atoms that must exist, it does something quite similar to just saying <code>for exactly 5 FA</code>. If we then add entries for the <code>RCA</code>'s fields, we manually accomplish what <code>nextAdder is linear</code> would as well, while simultaneously making sure the first full adder in that ordering is what we see in <code>RCA.firstAdder</code>:</p>
<pre><code class="language-alloy">inst fiveBits {
  RCA = `RCA0 
  FA = `FA0 + `FA1 + `FA2 + `FA3 + `FA4 + `FA5
  -- Remember the back-tick mark here before atom names! 
  `RCA0.firstAdder = `FA0
  `RCA0.nextAdder = `FA0 -&gt; `FA1 + `FA1 -&gt; `FA2 + `FA2 -&gt; `FA3 + 
                    `FA3 -&gt; `FA4 + `FA4 -&gt; `FA5
} 
run {rca} for exactly 1 RCA for {fiveBits}
</code></pre>
<p>So far this is just a long-handed way of doing what we've already done. But partial instances are far more flexible. Remember the optimization we had to do in <a href="chapters/qna/../ttt/ttt_games.html">tic-tac-toe games</a>, where we reduced the bitwidth from <code>4</code> to <code>3</code>? Partial instances give us a much finer degree of control. Where <code>for 3 Int</code> still allows any integer between <code>-4</code> and <code>3</code> to be used, we can use a partial instance to <em>force</em> well-formedness, before the solver ever sees a constraint: </p>
<pre><code class="language-forge">inst ttt_indexes {
  Board = `Board0
  X = `X   O = `O
  Player = X + O
  board in Board -&gt; (0 + 1 + 2) -&gt; (0 + 1 + 2) -&gt; Player
}
</code></pre>
<p>This says that any entry in any board's <code>board</code> field can only use the values <code>0</code> through <code>2</code>, inclusive. It has an impact very similar to the <code>wellformed</code> pred we wrote, but can be much more efficient. (You'll learn more about why in the next chapter.)</p>
<p><strong>Exercise</strong>: Compare the statistical info for the original tic-tac-toe game run with and without this added partial instance information. Do you notice any changes? What do you think might be going on, here? </p>
<details>
<summary>Think, then click!</summary>
<p>The statistical information is reporting runtime, but also something else: the number of &quot;clauses&quot; and &quot;variables&quot;. It turns out these express how big the boolean constraint problem is before the solver gets it. Partial instances can reduce these, and thus make the problem easier for the solver. </p>
</details>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="modeling-boolean-logic-syntax-semantics-and-sets"><a class="header" href="#modeling-boolean-logic-syntax-semantics-and-sets">Modeling Boolean Logic (Syntax, Semantics, and Sets)</a></h1>
<p>In this chapter, we'll start writing a new model from scratch to meet 3 broad goals:</p>
<ul>
<li>expanding Forge's expressive power to support <em>sets</em> and <em>relations</em>;</li>
<li>modeling more recursive concepts in a language without recursion; and </li>
<li>modeling a <em>syntax</em> for a language, along with its <em>semantics</em>.</li>
</ul>
<p>You can find the completed models <a href="chapters/relations/./booleanLogic.frg">here</a>.</p>
<!-- ## In-class exercise

We'll warm up with an in-class exercise. I'd like everyone to take 5 minutes responding to this [request for feedback about Toadus Ponens](https://docs.google.com/forms/d/e/1FAIpQLSfv7p6PH1ZkXQuSc-29NmFRwDS5JQiDX-6cHdHehvabpfBE7g/viewform). Feedback here is actionable; e.g., we might be able to make Forge give an overall test report rather than stopping after the first test failure---something that came out of the feedback so far.   -->
<h2 id="modeling-boolean-formulas"><a class="header" href="#modeling-boolean-formulas">Modeling Boolean Formulas</a></h2>
<p>If you've spent time writing programs, then you've already spent a lot of time working with boolean formulas. E.g., if you're building a binary search tree in Java, you might write something like this to check the left-descent case:</p>
<pre><code class="language-java=">if(this.getLeftChild() != null &amp;&amp;
   this.getLeftChild().value &lt; goal) { 
    ... 
}
</code></pre>
<p>The conditional inside the <code>if</code> is a boolean formula with two <em>boolean variables</em> (also sometimes called <em>atomic propositions</em>) corresponding to <code>leftChild == null</code> and <code>leftChild.value &lt; goal</code>. A <code>!</code> (<code>not</code>) negates the equality check, and a single <code>&amp;&amp;</code> (and) combines the conditions. The syntax of the conditional forms a tree, with atoms for the two boolean variables, the <code>not</code> and the <code>and</code>:</p>
<center><img width="40%" src="chapters/relations/./Ifcond.png"/></center>
<!-- ```alloy
example leftBranchFormula is {} for {
  And = `And0
  Var = `VarNeqNull + `VarLTLeft
  Formula = And + Var
}
``` -->
<h2 id="modeling-boolean-formulas-1"><a class="header" href="#modeling-boolean-formulas-1">Modeling Boolean Formulas</a></h2>
<p>Let's define some types for formulas. Like we've done before when defining a hierarchy of types, we'll make an <code>abstract sig</code> to represent the collection of <em>all</em> kinds of formulas, and have child <code>sig</code>s that represent specific kinds:</p>
<pre><code class="language-alloy">-- Syntax: formulas
abstract sig Formula {}
sig Var extends Formula {} 
sig Not extends Formula {child: one Formula} 
sig Or extends Formula {o_left, o_right: one Formula}
sig And extends Formula {a_left, a_right: one Formula}
-- If we really wanted to, we could add `Implies`, `IFF`, etc. in the same way.
</code></pre>
<div id="admonition-field-names" class="admonition admonish-note">
<div class="admonition-title">
<p>Field names</p>
<p><a class="admonition-anchor-link" href="chapters/relations/modeling-booleans-1.html#admonition-field-names"></a></p>
</div>
<div>
<p>Forge doesn't allow re-use of field names between sigs. If you try, you'll get an error that says the name is already used. So we need to name the left and right children of the <code>And</code> and <code>Or</code> types differently. Hence the <code>o_</code> and <code>a_</code> prefixes.</p>
</div>
</div>
<h3 id="wellformedness-1"><a class="header" href="#wellformedness-1">Wellformedness</a></h3>
<p>As always, we need a notion of wellformedness. What would make a formula tree &quot;garbage&quot;? Well, if the syntax tree contained a cycle, the tree wouldn't be a tree, and the formula wouldn't be a formula! We'll write a <code>wellformed</code> predicate where an assertion like this will pass:</p>
<pre><code class="language-alloy">pred trivialLeftCycle { 
    some a: And | a.a_left = a
}
pred notWellformed { not wellformed }
assert trivialLeftCycle is sufficient for notWellformed
</code></pre>
<p><strong>(TODO: I don't like the need to create a secondary helper <code>notWellformed</code>. Discuss with SP.)</strong></p>
<p>Like in binary trees, there are multiple fields that a cycle could use. Then, we only needed to worry about <code>left</code> and <code>right</code>; here there are many more. Let's build a helper predicate that evaluates whether a formula is a smaller part of another:</p>
<pre><code class="language-alloy">-- IMPORTANT: remember to update this if adding new formula types!
pred subFormulaOf[sub: Formula, f: Formula] {
  reachable[sub, f, child, a_left, o_left, a_right, o_right]
}
</code></pre>
<p>At first, this might seem like a strange use of a helper. There's just one line, and all it does is call the <code>reachable</code> built-in predicate. However, we probably need to check for subformulas in multiple places in our model. And, we might anticipate a need to add more formula types (maybe we get around to adding <code>Implies</code>). Then we need to remember to add the fields of the new <code>sig</code> everywhere that <code>reachable</code> is used. And if we leave one out, we probably won't get an error. So making this helper is just good engineering practice; this way, we minimize the number of places that need the change. </p>
<pre><code class="language-alloy">pred wellformed {
  -- no cycles
  all f: Formula | not subFormulaOf[f, f]
}
</code></pre>
<div id="admonition-remember-what-wellformed-is-for" class="admonition admonish-warning">
<div class="admonition-title">
<p>Remember what <code>wellformed</code> is for</p>
<p><a class="admonition-anchor-link" href="chapters/relations/modeling-booleans-1.html#admonition-remember-what-wellformed-is-for"></a></p>
</div>
<div>
<p>Recall that we use wellformed to exclude &quot;garbage&quot; instances only, analogously to filtering an input generator in property-based testing. The stuff we might want to verify (or build a system to enforce) goes elsewhere—or else Forge will exclude any potental counterexamples.</p>
</div>
</div>
<p>We'll want to add <code>wellformed</code> to the first example we wrote, but it should still pass. Let's run the model and look at some formulas! We could just <code>run {wellformed}</code>, but that might be prone to giving uninteresting examples. Let's try identifying the root node in our <code>run</code> constraint, which would let us ask for something more complex:</p>
<pre><code class="language-alloy">run {
  wellformed
  some top: Formula | {
    all other: Formula | top != other =&gt; {
      subFormulaOf[other, top]
    }
  }
} for exactly 8 Formula
</code></pre>
<p>Try running this. You should see some example formula trees; we've modeled the <em>syntax</em> of boolean logic. </p>
<p><strong>Exercise:</strong> Write at least one more positive and one more negative test for <code>wellformed</code> in this model. </p>
<p><strong>Exercise:</strong> Why didn't we add a constraint to prevent nodes from having multiple parents? That is, why didn't we prevent an instance like this? (And, in light of that, is it really fair to call these &quot;trees&quot;?)</p>
<center><img width="40%" src="chapters/relations/./Dagformula.png"/></center>
<p><strong>TODO: add image</strong></p>
<details>
<summary>Think, then click!</summary>
<p>If we wanted to exlude &quot;sharing&quot; of child formulas, we'd need to allow multiple nodes to have the same meaning. E.g., if we had a variable <code>x</code>, we'd need to allow multiple <code>Var</code> atoms to represent <code>x</code>, which would greatly complicated the model and increase the size of its instances. Instead, we let one <code>Var</code> atom be re-used in multiple contexts. </p>
<p>So, while the instances aren't (strictly speaking) trees, they <em>represent</em> trees in an efficient way. </p>
</details>
<h2 id="the-meaning-of-boolean-circuits"><a class="header" href="#the-meaning-of-boolean-circuits">The <em>Meaning</em> Of Boolean Circuits</a></h2>
<p>What's the <em>meaning</em> of a formula? So far they're just bits of syntax in isolation; we haven't defined a way to understand them or interpret them. This distinction between syntax and its meaning is <em>really important</em>, and touches every aspect of computer science. Indeed, it deeply affects anywhere we use a language. </p>
<p>To see why, let's go back to that Java BST example, with the boolean conditional:</p>
<pre><code class="language-java=">if(this.getLeftChild() != null &amp;&amp; this.getLeftChild().value &lt; goal) { 
    ... 
}
</code></pre>
<p><strong>Exercise:</strong> Suppose that the <code>getLeftChild()</code> method increments a counter whenever it is called. Suppose the counter is <code>0</code> before this <code>if</code> statement runs. What will it be afterward?</p>
<details>
<summary>Think, then click!</summary>
<p>It depends! </p>
<ul>
<li>If the left-child is non-null, the counter will hold <code>2</code> afterward, because <code>getLeftChild()</code> will be called twice. </li>
<li>If the left-child is null, and we're working in a language like Java, which &quot;short circuits&quot; conditionals, the counter would be <code>1</code> since the second branch of the <code>&amp;&amp;</code> wouldn't execute.</li>
</ul>
<p>In another language, one that <em>didn't</em> have short-circuiting conditionals, the counter might be <code>2</code> in both cases. And in yet <em>another</em> language, where <code>getLeftChild()</code> might be cached and only called once, both counters might be <code>1</code>!</p>
</details>
<br/>
<h3 id="whats-the-point"><a class="header" href="#whats-the-point">What's the point?</a></h3>
<p>If we don't know the <em>meaning</em> of that <code>if</code> statement and the <code>and</code> within it, we don't actually know what will happen! Syntax can mislead us, especially if we have pre-existing intuitions. And if we want to reason about what a piece of syntax <em>does</em>, we need to understand what the syntax <em>means</em>. </p>
<p>Right now we're modeling boolean formulas. So let's understand the meaning of formulas; sometimes this is called their <em>semantics</em>. </p>
<p><strong>Exercise:</strong> What can I <em>do</em> with a formula? What kind of operations is it meant to enable? </p>
<details>
<summary>Think, then click!</summary>
<p>If I have a formula, I can plug in various values into its variables and read off the result: does the overall formula evaluate to true or false when given those values? This is what we want to encode in our model.</p>
<p>Let's think of a boolean formula like a function from <em>sets of variable values</em> to a <em>result boolean</em>. </p>
</details>
<br/>
<p>We'll need a way to represent &quot;sets of variable values&quot;. Sometimes these are called a &quot;valuation&quot;, so let's make a new <code>sig</code> for that. </p>
<pre><code class="language-alloy">sig Valuation {
  -- [HELP: what do we put here? Read on...]
}
</code></pre>
<p>We have to decide what fields a <code>Valuation</code> should have. Once we do that, we might start out by writing a <em>recursive</em> predicate or function, kind of like this pseudocode:</p>
<pre><code class="language-alloy">pred semantics[f: Formula, val: Valuation] {
  f instanceof Var =&gt; val sets the f var true
  f instanceof And =&gt; semantics[f.a_left, val] and semantics[f.a_right, val]
  ...
}
</code></pre>
<p><strong>This <em>won't work!</em></strong> Forge is not a recursive language; you won't be able to write a predicate that calls itself like this. So we've got to do something different. Let's move the recursion into the model itself, by adding a mock-boolean sig: </p>
<pre><code class="language-alloy">one sig Yes {}
</code></pre>
<p>and then adding a new field to our <code>Formula</code> sig (which we will, shortly, constrain to encode the semantics of formulas):</p>
<pre><code class="language-alloy">   satisfiedBy: pfunc Valuation -&gt; Yes
</code></pre>
<p>This <em>works</em> but it's a bit verbose and quite tangled. It'd be more clear to just say that every formula has a <em>set</em> of valuations that satisfy it. But so far we haven't been able to do that.</p>
<h4 id="language-change"><a class="header" href="#language-change">Language change!</a></h4>
<p>First, let's change our language to <code>#lang forge</code>. This gives us a language with more expressive power, but also some subtleties we'll need to address.</p>
<div id="admonition-relational-forge" class="admonition admonish-tip">
<div class="admonition-title">
<p>Relational Forge</p>
<p><a class="admonition-anchor-link" href="chapters/relations/modeling-booleans-1.html#admonition-relational-forge"></a></p>
</div>
<div>
<p>This language is called <strong>Relational Forge</strong>, for reasons that will become apparent. For now, when you see <code>#lang forge</code> rather than <code>#lang froglet</code>, expect us to say &quot;relational&quot;, and understand there's more expressivity there than Froglet gives you.</p>
</div>
</div>
<p>Now, we can write that every formula is satisfied by some <em>set</em> of valuations:</p>
<pre><code class="language-alloy">abstract sig Formula {
  -- Work around the lack of recursion by reifying satisfiability into a field.
  -- f.satisfiedBy contains an instance IFF that instance makes f true.
  -- [NEW] Relational Forge lets us create fields that contain _sets_ of values.
  satisfiedBy: set Valuation
}
</code></pre>
<p>We can now infer what field(s) <code>Valuation</code> should have. A <code>Valuation</code> isn't a formula, so it won't have a <code>satisfiedBy</code> field, but it does need to contain something. </p>
<p><strong>Exercise:</strong> What does a <code>Valuation</code> contain, and how does that translate to its field(s) in Forge?</p>
<details>
<summary>Think, then click!</summary>
<pre><code class="language-alloy">sig Valuation {
  trueVars: set Var
}
</code></pre>
</details>
<hr />
<p>Now we can encode the meaning of each formula as a predicate like this:</p>
<pre><code class="language-alloy">-- IMPORTANT: remember to update this if adding new fmla types!
-- Beware using this fake-recursion trick in general cases (e.g., graphs with cycles)
-- It's safe to use here because the data are tree shaped. 
pred semantics
{
  -- [NEW] set difference
  all f: Not | f.satisfiedBy = Valuation - f.child.satisfiedBy
  -- [NEW] set comprehension, membership
  all f: Var | f.satisfiedBy = {i: Valuation | f in i.trueVars}
  -- ...
}
</code></pre>
<p><strong>Exercise:</strong> We still need to say what <code>f.satisfiedBy</code> is for <code>Or</code> and <code>And</code> formulas. What should it be? (You might not yet know how to express it in Forge, but what should satisfy them, conceptually? Hint: think in terms of what satisfies their left and right subformulas.)</p>
<details>
<summary>Think, then click!</summary>
<p>We'd like <code>Or</code> to be satisfied when either of its children is satisfied. In contrast, <code>And</code> requires both of its children to be satisfied. We'll use <em>union</em> (<code>+</code>) and <em>intersection</em> (<code>&amp;</code>) for this.</p>
<pre><code class="language-forge">pred semantics
{
  -- [NEW] set difference
  all f: Not | f.satisfiedBy = Valuation - f.child.satisfiedBy
  -- [NEW] set comprehension, membership
  all f: Var | f.satisfiedBy = {i: Valuation | f in i.trueVars}
  -- [NEW] set union
  all f: Or  | f.satisfiedBy = f.o_left.satisfiedBy + f.o_right.satisfiedBy
  -- [NEW] set intersection
  all f: And | f.satisfiedBy = f.a_left.satisfiedBy &amp; f.a_right.satisfiedBy
}
</code></pre>
<p>In hindsight: yes, this is why you can't use <code>+</code> for integer addition in Froglet; we reserve the <code>+</code> operator to mean set union.</p>
</details>
<h3 id="is-that-all"><a class="header" href="#is-that-all">Is That All?</a></h3>
<p>No. In fact, there are some <em>Forge</em> semantics questions you might have. That's not a joke: are you sure that you know the <em>meaning</em> of <code>=</code> in Forge now? Suppose I started explaining Forge's set-operator semantics like so:</p>
<ul>
<li>Set union (<code>+</code>) in Forge produces a set that contains exactly those elements that are in one or both of the two arguments. </li>
<li>Set intersection (<code>&amp;</code>) in Forge produces a set that contains exactly those elements that are in both of the two arguments.</li>
<li>Set difference (<code>-</code>) in Forge produces a set that contains exactly those elements of the first argument that are not present in the second argument.</li>
<li>Set comprehension (<code>{...}</code>) produces a set containing exactly those elements from the domain that match the condition in the comprehension.</li>
</ul>
<p>That may sound OK at a high level, but you shouldn't let me get away with <em>just</em> saying that. </p>
<p><strong>Exercise:</strong> Why not?</p>
<details>
<summary>Think, then click!</summary>
<p>What does &quot;produces a set&quot; mean? And what happens if I use <code>+</code> (or other set operators) to combine a set and another kind of value? Am I even allowed to do that? If so, what values can I combine with sets? </p>
<p>This isn't a new question! It comes up in programming contexts, too. </p>
<ul>
<li>What happens when you add together a <code>float</code> and an <code>int</code> in Python? The result is automatically converted to a <code>float</code>. </li>
<li>What happens if you do the same in (say) OCaml? You'll get a type error unless you explicitly say to convert the <code>int</code> to a <code>float</code>. </li>
</ul>
<p>So, by analogy, which of these options does Forge use?</p>
</details>
<br/>
<p>In conversation, we're often dismissive of semantics. You'll hear people say, in an argument, &quot;That's just semantics!&quot; (to mean that the other person is being unnecessarily pedantic and quibbling about technicalities, rather than engaging). But when we're talking about how languages work, precise definitions <em>matter a lot</em>! </p>
<p><strong>In Relational Forge, <em>all</em> values are sets.</strong> A singleton value is just a set with one element, and <code>none</code> is the empty set. So <code>=</code> is <em>always</em> set equality in Relational Forge. From now on, we'll embrace that everything in Relational Forge is a set, but introduce the ideas that grow from that fact gradually, resolving potential confusions as we go.</p>
<div id="admonition-why-start-with-froglet" class="admonition admonish-note">
<div class="admonition-title">
<p>Why start with Froglet?</p>
<p><a class="admonition-anchor-link" href="chapters/relations/modeling-booleans-1.html#admonition-why-start-with-froglet"></a></p>
</div>
<div>
<p>The fact that all values in Relational Forge are sets means that <code>+</code>, <code>&amp;</code>, etc. and even <code>=</code> are always well-defined. However, our natural intuitions about how sets are different from objects can cause problems with learning Forge like this to start, and the learner's background is a major factor. Not everyone has had a discrete math class (or remembers their discrete math class). So, we start in a language where the power of sets is drastically reduced so that we can focus early on essential concepts like constraints and quantification.</p>
<p>On the other hand, sets are incredibly useful. Hence this chapter.</p>
</div>
</div>
<h4 id="returning-to-well-formedness"><a class="header" href="#returning-to-well-formedness">Returning to well-formedness</a></h4>
<p>Now we have a new kind of ill-formed formula: one where the <code>semantics</code> haven't been properly applied. So we enhance our <code>wellformed</code> predicate:</p>
<pre><code class="language-alloy">pred wellformed {
  -- no cycles
  all f: Formula | not subFormulaOf[f, f]
  -- the semantics of the logic apply
  semantics
}
</code></pre>
<h2 id="some-validation"><a class="header" href="#some-validation">Some Validation</a></h2>
<p>Here are some examples of things you might check in the model. Notice that some are:</p>
<ul>
<li>validation of the <em>model</em> (e.g., that it's possible to have instances that disagree on which formulas they satisfy); and others are </li>
<li>results about boolean logic that we might prove in a math course, like <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan's Laws</a>.</li>
</ul>
<h3 id="consistency-checks"><a class="header" href="#consistency-checks">Consistency Checks</a></h3>
<pre><code class="language-alloy">-- First, some tests for CONSISTENCY. We'll use test-expect/is-sat for these. 
test expect {
  nuancePossible: {
    wellformed
    -- [NEW] set difference in quantifier domain
    --   Exercise: why do we need the &quot;- Var&quot;?
    some f: Formula - Var | {
      some i: Valuation | i not in f.satisfiedBy
      some i: Valuation | i in f.satisfiedBy
    }    
  } for 5 Formula, 2 Valuation is sat  
  ---------------------------------
  doubleNegationPossible: {
    wellformed 
    some f: Not | {
      -- [NEW] set membership (but is it &quot;subset of&quot; or &quot;member of&quot;?)
      f.child in Not      
    }
  } for 3 Formula, 1 Valuation is sat  
} 
</code></pre>
<h3 id="properties-of-boolean-logic"><a class="header" href="#properties-of-boolean-logic">Properties of Boolean Logic</a></h3>
<pre><code class="language-alloy">-- What are some properties we'd like to check? 
-- We already know a double-negation is possible, so let's write a predicate for it
-- and use it in an assertion. Since it's satisfiable (above) we need not worry 
-- about vacuous truth for this assertion.
pred isDoubleNegationWF[f: Formula] { 
    f in Not  -- this is a Not
    f.child in Not -- that is a double negation
    wellformed
} 
pred equivalent[f1, f2: Formula] {
    -- Note that this predicate is always with respect to scopes/bounds. That is, &quot;equivalent&quot; 
    -- here isn't real logical equivalence, but rather whether there is a Valuation in a given 
    -- instance on which the two formulas disagree.
    f1.satisfiedBy = f2.satisfiedBy
}

assert all n: Not | isDoubleNegationWF[n] is sufficient for equivalent[n, n.child.child] 
  for 5 Formula, 4 Valuation is unsat    

-- de Morgan's law says that 
-- !(x and y) is equivalent to (!x or !y) and vice versa. Let's check it. 

-- First, we'll set up a general scenario with constraints. 
pred negatedAnd_orOfNotsWF[f1, f2: Formula] {
    wellformed
    
    -- f1 is !(x and y)
    f1 in Not 
    f1.child in And      
    -- f2 is (!x or !y)
    f2 in Or
    f2.o_left in Not
    f2.o_right in Not
    f2.o_left.child = f1.child.a_left
    f2.o_right.child = f1.child.a_right      
}

assert all f1, f2: Formula | 
  negatedAnd_orOfNotsWF[f1, f2] is sufficient for equivalent[f1, f2]
  for 8 Formula, 4 Valuation is unsat      

-- If we're going to trust that assertion passing, we need to confirm 
-- that the left-hand-side is satisfiable! 
test expect {
    negatedAnd_orOfNotsWF_sat: {
        some f1, f2: Formula | negatedAnd_orOfNotsWF[f1, f2]
    } for 8 Formula, 4 Valuation is sat
}
</code></pre>
<h2 id="looking-forward"><a class="header" href="#looking-forward">Looking Forward</a></h2>
<p>It turns out that sets are remarkably useful for describing relationships between objects in the world. We'll explore that further in the next sections.</p>
<!-- ```  
  ---------------------------------    
  andAssociativePossible: {
    -- ((X and Y) and Z) 
    --      ^ A1MID  ^ A1TOP
    -- (X and (Y and Z)
    --      ^ A2TOP  ^ A2MID
    wellformed
    some A1TOP, A2TOP, A1MID, A2MID : And {
      A1TOP.a_left = A1MID
      A2TOP.a_right = A2MID
      A1TOP.a_right = A2MID.a_right
      A1MID.a_left = A2TOP.a_left
      A1MID.a_right = A2MID.a_left
    }
  } for 8 Formula, 4 Valuation is sat 
  andAssociativeCheck: {
    -- ((X and Y) and Z) 
    --      ^ A1MID  ^ A1TOP
    -- (X and (Y and Z)
    --      ^ A2TOP  ^ A2MID
    wellformed
    some A1TOP, A2TOP, A1MID, A2MID : And {
      A1TOP.a_left = A1MID
      A2TOP.a_right = A2MID
      A1TOP.a_right = A2MID.a_right
      A1MID.a_left = A2TOP.a_left
      A1MID.a_right = A2MID.a_left
      A1TOP.satisfiedBy != A2TOP.satisfiedBy
    }
  } for 8 Formula, 4 Valuation is unsat 
} 
```
-->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="relations-and-reachability"><a class="header" href="#relations-and-reachability">Relations and Reachability</a></h1>
<!-- ~~~admonish note title="Brown CSCI 1710"

* Hopefully everyone has been making good progress with Curiosity Modeling! I'm seeing a lot of awesome questions on Ed and at hours. 
* Some of you are curious about how far you need to go to earn a check on the project. This is hard to give a precise answer to, because everyone's models will be different. However, I can say that we're looking for:
    * evidence that you explored your topic of choice;
    * evidence that you validated your model;
    * something you _got_ from the model (generating or solving puzzles, checking a property, or even just understanding a domain better).
* **There's a lab this week** that focuses on _sets_ and other _relational_ concepts. You'll be exploring automated memory management in Forge. This lab leads directly into the next homework, and is meant to give you useful insight into how these systems work.

~~~ -->
<p>Consider this <a href="chapters/relations/reach.frg">small Relational Forge model</a>:</p>
<pre><code class="language-alloy">#lang forge
sig Person {
    friends: set Person,
    followers: set Person
}
one sig Nim, Tim extends Person {}

pred wellformed {
    -- friends is symmetric (followers might not be)
    all disj p1, p2: Person | p1 in p2.friends implies p2 in p1.friends 
    -- you cannot follow or friend yourself
    all p: Person | p not in p.friends and p not in p.followers
}
run {wellformed} for exactly 8 Person
</code></pre>
<p>Let's run it, get a reasonably large instance, and try to figure out how to express some goals in the evaluator. </p>
<p><strong>EXERCISE</strong>: You'll be following along with each of these questions. Use the evaluator heavily---it's great for figuring out what different expressions evaluate to.</p>
<h4 id="expression-nims-followers"><a class="header" href="#expression-nims-followers">Expression: Nim's followers</a></h4>
<details>
<summary>Think, then click!</summary>
<p>This is just <code>Nim.followers</code>.</p>
</details>
<h4 id="formula-nim-is-reachable-from-tim-via-followers"><a class="header" href="#formula-nim-is-reachable-from-tim-via-followers">Formula: Nim is reachable from Tim via &quot;followers&quot;</a></h4>
<details>
<summary>Think, then click!</summary>
<p>We can use the <code>reachable</code> built-in: <code>reachable[Nim, Tim, followers]</code>.</p>
</details>
<h4 id="expression-nims-followers-followers"><a class="header" href="#expression-nims-followers-followers">Expression: Nim's followers' followers</a></h4>
<details>
<summary>Think, then click!</summary>
<p>Another application of the field! <code>Nim.followers.followers</code>.</p>
<p>But wait, what does this really mean? Since <code>Nim.followers</code> is a set, rather than a <code>Person</code>, should I be able to apply <code>.followers</code> to it? If we try this in the evaluator, it works, but we're no longer just doing a &quot;field access&quot;; something more must be going on. </p>
</details>
<h4 id="formula-nim-is-reachable-from-tim-via-the-inverse-of-followers-what-we-might-call-following"><a class="header" href="#formula-nim-is-reachable-from-tim-via-the-inverse-of-followers-what-we-might-call-following">Formula: Nim is reachable from Tim via the inverse of &quot;followers&quot; (what we might call &quot;following&quot;)?</a></h4>
<details>
<summary>Think, then click!</summary>
<p>Hmm. This seems harder. We don't have a field called <code>following</code>, and the <code>reachable</code> built-in takes fields! </p>
<p>...it does take fields, right? Or might it take something more flexible? Can we use <em>set operations</em> to adjust the potential edges that <code>reachable</code> looks at?</p>
</details>
<p>To figure that out, let's try something else.</p>
<h4 id="formula-nim-is-reachable-from-tim-via-followers-but-not-including-tims-friends"><a class="header" href="#formula-nim-is-reachable-from-tim-via-followers-but-not-including-tims-friends">Formula: Nim is reachable from Tim via followers, but not including Tim's friends?</a></h4>
<details>
<summary>Think, then click!</summary>
<p>We might try <code>reachable[Nim, Tim, (followers-Tim.friends)]</code> but this will produce an error. Why? Well, one reason we might give is:</p>
<blockquote>
<p>...because <code>followers</code> is a field but <code>Tim.friends</code> is a set.</p>
</blockquote>
<p>But is that the real answer? The error complains about &quot;arity&quot;: 2 vs 1. Let's type those two expressions into the evaluator and see what we get. For <code>followers</code>, we get a set of <em>pairs</em> of people. But <code>Tim.friends</code> is a set of <em>singletons</em>. </p>
</details>
<!-- ~~~admonish warning title="Evaluator Output" 
The evaluator prints expression values as parenthesized lists of lists. But don't be fooled! It's really printing a _set_ of _lists_. The order in which the inner lists print shouldn't matter.
~~~ -->
<div id="admonition-arity-relations-and-tuples" class="admonition admonish-tip">
<div class="admonition-title">
<p>Arity, Relations, and Tuples</p>
<p><a class="admonition-anchor-link" href="chapters/relations/reachability.html#admonition-arity-relations-and-tuples"></a></p>
</div>
<div>
<p><em>Arity</em> is another word for how wide the elements of a set are. Here, we'd say that <code>followers</code> has arity 2 since elements of <code>followers</code> are pairs of atoms. Similarly, <code>Tim.friends</code> has arity 1 since its elements are singletons. So Forge is pointing out that taking the set difference of these two makes no sense; their elements are shaped differently.</p>
<p>When we're talking about sets in this way, we sometimes call them <em>relations</em>. E.g., the <code>followers</code> field is a <em>binary relation</em> because it has arity 2. We'll call elements of relations <em>tuples</em>. E.g., if <code>Nim</code> follows <code>Tim</code>, the tuple <code>(Tim, Nim)</code> would be present in <code>followers</code>.</p>
</div>
</div>
<p>In Relational Forge, <code>reachable</code> doesn't take &quot;fields&quot;; it takes relations. Specifically, binary relations, which define the steps it can use to connect the two objects. That's the fact we'll use to solve the 2 problems above. </p>
<h4 id="attempt-2-formula-nim-is-reachable-from-tim-via-the-inverse-of-followers-what-we-might-call-following"><a class="header" href="#attempt-2-formula-nim-is-reachable-from-tim-via-the-inverse-of-followers-what-we-might-call-following">(Attempt 2) Formula: Nim is reachable from Tim via the inverse of &quot;followers&quot; (what we might call &quot;following&quot;)?</a></h4>
<p>Now that we know <code>followers</code> is a binary relation, we can imagine flipping it to get its inverse. How can we do that? Well, there are multiple ways! We could write a set-comprehension:</p>
<pre><code>{p1, p2: Person | p1 in p2.followers}
</code></pre>
<p>The order matters here! If <code>p1</code> is in <code>p2.followers</code>, then there is an entry in the relation that looks like <code>(p2, p1)</code>. We could make this more explicit by writing:</p>
<pre><code>{p1, p2: Person | p2-&gt;p1 in followers}
</code></pre>
<p>Now that we know <code>followers</code> is a set, this makes sense! The <em>product</em> (<code>-&gt;</code>) operator combines <code>p2</code> and <code>p1</code> into a binary tuple, which may (or may not) be in <code>followers</code>.</p>
<p>Forge provides an operator that does this directly for binary relations: transpose (<code>~</code>). So we could write instead:</p>
<pre><code>~followers
</code></pre>
<p>Which should you use? It's up to you! Regardless, we could now answer this question with:</p>
<pre><code class="language-alloy">reachable[Nim, Tim, ~followers]
</code></pre>
<h4 id="attempt-2-formula-nim-is-reachable-from-tim-via-followers-but-not-including-tims-friends"><a class="header" href="#attempt-2-formula-nim-is-reachable-from-tim-via-followers-but-not-including-tims-friends">(Attempt 2) Formula: Nim is reachable from Tim via followers, but not including Tim's friends?</a></h4>
<p>Everything is a set, so let's build the subset of <code>followers</code> that doesn't involve anyone in <code>Tim.friends</code>. We can't write <code>followers-(Tim.friends)</code>, since that's an arity mismatch. Somehow, we need to remove entries in <code>followers</code> involving one of Tim's friends <em>and anybody else</em>. </p>
<p>One way is to use the product operator to build the binary relation we want <code>reachable</code> to use. E.g.:</p>
<pre><code>reachable[Nim, Tim, followers-(Tim.friends-&gt;Person)]
</code></pre>
<div id="admonition-default" class="admonition admonish-tip">
<div>
<p>You may notice that we've now used <code>-&gt;</code> in what seems like 2 different ways. We used it to combine specific people, <code>p1</code> and <code>p2</code> above into a single tuple. But now we're using it to combine two <em>sets</em> into a <em>set</em> of tuples. This flexibility is a side effect of sets being the fundamental concept in Relational Forge:</p>
<ul>
<li>the product of <code>((Tim))</code> and <code>((Nim))</code> is <code>((Tim, Nim))</code>; </li>
<li>the product of <code>((Person1), (Person2))</code> and <code>((Person3), (Person4))</code> is <code>((Person1, Person3), (Person1, Person4), (Person2, Person3), (Person2, Person4))</code>. </li>
</ul>
<p>Formally, <code>-&gt;</code> is the cross-product operation on sets. </p>
<p>You'll see this apparently double-meaning when using <code>in</code> and <code>=</code>, too: singletons are single-element sets, where the element is a one-column tuple.</p>
</div>
</div>
<h2 id="what-is-dot-really"><a class="header" href="#what-is-dot-really">What is Dot, Really?</a></h2>
<p>In Relational Forge, the dot operator is called <em>relational join</em>. The expression <code>A.B</code> combines two arbitrary relations <code>A</code> and <code>B</code> by seeking out rows with common values in their rightmost (in <code>A</code>) and leftmost (in <code>B</code>) columns. Concretely, if <code>A</code> is an <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-ary relation, and <code>B</code> is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>-ary, then <code>A.B</code> equals the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>-ary relation:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∃</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord"> and </span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">}</span></span></span></span></span></p>
<p>That's a lot, so let's work through some examples. Suppose that we have the following relation for the <code>friend</code> field of <code>Person</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>column 1</th><th>column 2</th></tr></thead><tbody>
<tr><td><code>Tim</code></td><td><code>Person0</code></td></tr>
<tr><td><code>Tim</code></td><td><code>Person1</code></td></tr>
<tr><td><code>Person0</code></td><td><code>Person1</code></td></tr>
<tr><td><code>Person0</code></td><td><code>Tim</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Person0</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Person2</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Tim</code></td></tr>
<tr><td><code>Person2</code></td><td><code>Person1</code></td></tr>
<tr><td><code>Person2</code></td><td><code>Nim</code></td></tr>
<tr><td><code>Nim</code></td><td><code>Person2</code></td></tr>
</tbody></table>
</div>
<p>We know that join can often work like field access. So we'd expect <code>Tim.friend</code> to produce a set containing <code>Person0</code> and <code>Person1</code>. Why? Because we see <code>Tim</code> in the <em>left</em> column of 2 rows, and the <em>right</em> columns of those rows contain <code>Person0</code> and <code>Person1</code>. </p>
<p>But what about each of the following?</p>
<div id="admonition-try-the-evaluator" class="admonition admonish-tip">
<div class="admonition-title">
<p>Try the evaluator!</p>
<p><a class="admonition-anchor-link" href="chapters/relations/reachability.html#admonition-try-the-evaluator"></a></p>
</div>
<div>
<p>To build intuition for <code>.</code>, try expressions like this in the evaluator after reading the following examples.</p>
</div>
</div>
<h4 id="friendtim"><a class="header" href="#friendtim"><code>friend.Tim</code></a></h4>
<p>Here we run the same process that gave us a value for <code>Tim.friend</code>, but in reverse. Which rows do we see <code>Tim</code> in the <em>right</em> column? </p>
<center><img width="40%" src="chapters/relations/./Join2.png" style="background-color:white"/></center>
<p>Because <code>friend</code> is symmetric, it's the same: <code>friend.Tim</code> is the same as <code>Tim.friend</code>, a set containing <code>Person0</code> and <code>Person1</code>. </p>
<hr />
<h4 id="friendfriend"><a class="header" href="#friendfriend"><code>friend.friend</code></a></h4>
<p>Before trying to compute the value, first answer: </p>
<p><strong>Exercise:</strong> What is the arity of <code>friend.friend</code>?</p>
<details>
<summary>Think, then click!</summary>
<p>Well, <code>friend</code> has arity <code>2</code>, and a join subtracts one column from each side. So we expect <code>friend.friend</code> to have arity <code>1+1=2</code>. </p>
</details>
<p>Now, what's the value? Start by looking for matches. Here are some of them (the ones on <code>Person0</code>): </p>
<center><img width="40%" src="chapters/relations/./Join3.png" style="background-color:white"/></center>
<p>Continuing, we'll find matches on <code>Person1</code>, <code>Tim</code>, and others. Because some people have a lot of friends, the graph is getting difficult to read, but notice what's happening: we're identifying <em>matching pairs of rows</em> in each relation.</p>
<center><img width="40%" src="chapters/relations/./Join4.png" style="background-color:white"/></center>
<p>Finally, we generate a new row in the result for every pair of matching rows, deleting the inner columns we matched on: <code>Tim-&gt;Person1</code> is in the result because <code>Tim-&gt;Person0</code> is in <code>friends</code> (the left-hand side of the join) and <code>Person0-&gt;Person1</code> is in <code>friends</code> (the right-hand side of the join). We'll get one row for every match (but we won't keep duplicates):</p>
<div class="table-wrapper"><table><thead><tr><th>column 1</th><th>column 2</th></tr></thead><tbody>
<tr><td><code>Tim</code></td><td><code>Person1</code></td></tr>
<tr><td><code>Tim</code></td><td><code>Person2</code></td></tr>
<tr><td><code>Tim</code></td><td><code>Tim</code></td></tr>
<tr><td><code>Person0</code></td><td><code>Person0</code></td></tr>
<tr><td><code>Person0</code></td><td><code>Person1</code></td></tr>
<tr><td><code>Person0</code></td><td><code>Person2</code></td></tr>
<tr><td><code>Person0</code></td><td><code>Tim</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Person0</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Person1</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Tim</code></td></tr>
<tr><td><code>Person1</code></td><td><code>Nim</code></td></tr>
<tr><td><code>Person2</code></td><td><code>Person0</code></td></tr>
<tr><td><code>Person2</code></td><td><code>Person2</code></td></tr>
<tr><td><code>Person2</code></td><td><code>Tim</code></td></tr>
<tr><td><code>Nim</code></td><td><code>Nim</code></td></tr>
<tr><td><code>Nim</code></td><td><code>Person2</code></td></tr>
</tbody></table>
</div>
<p><strong>This is the set of <em>friend-of-friend</em> relationships.</strong> If we computed <code>friend.friend.friend</code>, we'd get the <em>friend-of-friend-of-friend</em> relationships, and so on.</p>
<p><strong>TODO: double-check this</strong></p>
<hr />
<p><strong>Exercise:</strong> What about <code>Tim.Tim</code>?</p>
<details>
<summary>Think, then click!</summary>
<p>This will give an error because the result has arity <code>0</code>. </p>
</details>
<h2 id="how-reachability-works"><a class="header" href="#how-reachability-works">How Reachability Works</a></h2>
<p>If we wanted to encode reachability without using the built-in <code>reachable</code> predicate, we could start by writing a helper predicate:</p>
<pre><code class="language-alloy">pred reachable2[to: Person, from: Person, via: Person -&gt; Person]: set Person {
    to in 
    from.via +
    from.via.via +
    from.via.via.via 
    -- ...and so on...
}
</code></pre>
<p>But we always have to stop writing somewhere. We could write the union out to 20 steps, and still we wouldn't catch some very long (length 21 or higher) paths. So we need some way to talk about <em>unbounded reachability</em>, or at least reachability up to a path length that's influenced by the problem bounds.</p>
<p>Forge's <code>reachable</code> built-in does this, but it's just a facade over a new relational operator: transitive closure (<code>^R</code>).</p>
<p>The <em>transitive closure</em> <code>^R</code> of a binary relation <code>R</code> is the <em>smallest</em> binary relation such that:</p>
<ul>
<li>if <code>x-&gt;y</code> is in <code>R</code>, then <code>x-&gt;y</code> is in <code>^R</code>; and</li>
<li>if <code>x-&gt;z</code> is in <code>R</code> and <code>z-&gt;y</code> is in <code>^R</code> then <code>x-&gt;y</code> is in <code>R</code>.</li>
</ul>
<p>That is, <code>^R</code> encodes exactly what we were trying to achieve above. The <code>reachable[to, from, f1, ...]</code> built-in is just syntactic sugar for:</p>
<pre><code class="language-alloy">    to in from.^(f1 + ...)
</code></pre>
<p>You might remember that <code>reachable</code> always evaluates to true if we give <code>none</code> as its first argument. This is because of the translation above: if <code>to</code> is the empty set, then it is a subset of anything. </p>
<!-- ~~~admonish tip title="Design Discussion"
You might wonder why we don't translate `reachable[to, from, f1, ...]` to something like `to in from.^(f1 + ...) and some to`. This would, after all, fix the problem of `none` being reachable from everything! The answer is that this fix might cause other confusion, and either way the ...
...
~~~ -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="more-sets-and-induction-mutual-exclusion"><a class="header" href="#more-sets-and-induction-mutual-exclusion">More Sets and Induction (Mutual Exclusion)</a></h1>
<p>If you have two independent threads of execution running concurrently, many subtle bugs can manifest. For instance, if both threads can write to the same region of memory, they might overlap their writes. A great example of this is simply incrementing a counter. In most computer systems, an operation like:</p>
<pre><code class="language-java">  counter = counter + 1;
</code></pre>
<p>is not atomic by itself. Thus, the following sequence of operations would be problematic:</p>
<ul>
<li>Thread 1: read the current value of <code>counter</code></li>
<li>Thread 2: read the current value of <code>counter</code></li>
<li>Thread 1: add <code>1</code> to that value</li>
<li>Thread 1: write the new value to <code>counter</code></li>
<li>Thread 2: add <code>1</code> to that value</li>
<li>Thread 2: write the new value to <code>counter</code>
because then the counter's value is only <code>1</code> higher than its original value.</li>
</ul>
<p>We often call the property that such traces can't exist <em>mutual exclusion</em>, and the piece of code that shouldn't ever be run by 2 threads at once the <em>critical section</em>.  Today we'll model a very simple approach to mutual-exclusion—which turns out <em>not</em> to work, but is a first step on the way to something that does.</p>
<p>The idea comes from how we as humans negotiate access to a shared resource like the spoken-communication channel in a meeting. If we want to talk, we raise our hand. </p>
<h3 id="a-simplified-mutual-exclusion-algorithm"><a class="header" href="#a-simplified-mutual-exclusion-algorithm">A Simplified Mutual-Exclusion Algorithm</a></h3>
<p>Consider the pseudocode below, and imagine it running on two separate threads of execution. I've marked <em>program locations</em> in square brackets---note how they correspond to the spaces in between lines of code executing.</p>
<p><strong>TODO: incorporate Pamela's comments on this; return to validation</strong></p>
<pre><code class="language-java">while(true) { 
    // [state: uninterested]
    this.flag = true;
    // [state: waiting]
    while(other.flag == true);    
    // [state: in-cs]    
    run_critical_section_code(); // does whatever; we don't care about details
    this.flag = false;    
}
</code></pre>
<p>Both processes will always continuously try to access the critical section. When they become interested, they set a public <code>flag</code> bit to true. Then, they don't enter until their counterpart's flag is false. When they're done executing the critical section, they lower their flag and restart. </p>
<p>Notice we aren't modeling the critical section itself. The exact nature of that code doesn't matter for our purposes; we just want to see whether both process can be at the <code>in-cs</code> location at once. If so, mutual exclusion fails!</p>
<h3 id="modeling"><a class="header" href="#modeling">Modeling</a></h3>
<p>Let's start with a simple model. We'll critique this model as the semester progresses, but this will be useful enough to get us started. </p>
<pre><code class="language-alloy">abstract sig Location {}
one sig Uninterested, Waiting, InCS extends Location {}

abstract sig Process {}
one sig ProcessA, ProcessB extends Process {}

sig State {
    loc: func Process -&gt; Location,
    flags: set Process
}
</code></pre>
<p>An initial state is one where all processes are uninterested, and no process has raised its flag:</p>
<pre><code class="language-alloy">pred init[s: State] {
    all p: Process | s.loc[p] = Uninterested
    no s.flags 
}
</code></pre>
<p>We then have three different transition predicates, each corresponding to one of the lines of code above, and a transition predicate <code>delta</code> that represents <em>any</em> currently-possible transition:</p>
<pre><code class="language-alloy">
pred raise[pre: State, p: Process, post: State] {
    pre.loc[p] = Uninterested
    post.loc[p] = Waiting
    post.flags = pre.flags + p
    all p2: Process - p | post.loc[p2] = pre.loc[p2]
}

pred enter[pre: State, p: Process, post: State] {
    pre.loc[p] = Waiting 
    pre.flags in p -- no other processes have their flag raised
    post.loc[p] = InCS    
    post.flags = pre.flags
    all p2: Process - p | post.loc[p2] = pre.loc[p2]
}

pred leave[pre: State, p: Process, post: State] {
    pre.loc[p] = InCS    
    post.loc[p] = Uninterested    
    post.flags = pre.flags - p
    all p2: Process - p | post.loc[p2] = pre.loc[p2]
}

-- the keyword &quot;transition&quot; is reserved
pred delta[pre: State, post: State] {
    some p: Process | 
        raise[pre, p, post] or
        enter[pre, p, post] or 
        leave[pre, p, post]
}
</code></pre>
<p>We won't create a <code>Trace</code> sig or <code>traces</code> predicate at all, because we're going to apply induction rather than trace generation. </p>
<h3 id="model-validation"><a class="header" href="#model-validation">Model Validation</a></h3>
<p>We should do some quick validation at this point. The most basic would be checking that each of our transitions is satisfiable:</p>
<pre><code class="language-alloy">test expect {
    canEnter: {        
        some p: Process, pre, post: State | enter[pre, p, post]        
    } is sat
    canRaise: {        
        some p: Process, pre, post: State | raise[pre, p, post]        
    } is sat    
    canLeave: {        
        some p: Process, pre, post: State | leave[pre, p, post]        
    } is sat    
}
</code></pre>
<p>In a real modeling situation, we would <em>absolutely</em> add more checks. Even here, we might regret not testing more...</p>
<h3 id="does-mutual-exclusion-hold"><a class="header" href="#does-mutual-exclusion-hold">Does Mutual Exclusion Hold?</a></h3>
<p>Before we run Forge, ask yourself whether the algorithm above guarantees mutual exclusion. (It certainly has another kind of error, but we'll get to that later. Focus on this one property for now.)</p>
<p>It seems reasonable that the property holds. But if we try to use the inductive approach to prove that:</p>
<pre><code class="language-alloy">pred good[s: State] {
    #{p: Process | s.loc[p] = InCS} &lt;= 1
}

pred startGoodTransition[s1, s2: State] {    
    good[s1]
    delta[s1,s2]
}
assert all s: State | init[s] is sufficient for good[s] for exactly 1 State
assert all pre, post: State | startGoodTransition[pre, post] is sufficient for good[post] for exactly 2 State
</code></pre>
<p>The inductive case <em>fails</em>. Let's see what the counterexample is:</p>
<pre><code class="language-alloy">    run {
      not {
        all pre, post: State | 
          delta[pre, post] and good[pre] implies good[post]
        }
    } for exactly 2 State
</code></pre>
<p>Yields, in the table view:</p>
<p><img src="https://i.imgur.com/tJsdyDV.png" alt="" /></p>
<p>Notice that neither process has raised its flag in either state. This seems suspicious, and might remind you of the binary-search model, where the <code>good</code> predicate wasn't strong enough to be inductive, but the counterexample Forge found wasn't actually reachable. This is another such situation.</p>
<h3 id="refresher-enriching-the-invariant"><a class="header" href="#refresher-enriching-the-invariant">Refresher: Enriching The Invariant</a></h3>
<p>This counterexample shows that the property we wrote <em>isn't inductive</em>. But it might still an invariant of the system—it's just that Forge has found an unreachable prestate. To prevent that, we'll add more conditions to the <code>good</code> predicate (recall: we call this <em>enriching the invariant</em>; it's a great demo of something apparently paradoxical: <em>proving something stronger can be easier</em>). Let's <em>also</em> say that, in order for a process to be in the critical section, its flag needs to be true:</p>
<pre><code class="language-alloy">pred good2[s: State] {
    -- enrichment: if in CS, flag must be raised
    all p: Process | s.loc[p] = InCS implies p in s.flags  
    -- original: mutual exclusion      
    #{p: Process | s.loc[p] = InCS} &lt;= 1        
}
</code></pre>
<p>We re-run this, and the inductive case still fails! Look closely at the counterexample. The problem now is that the flag <em>also</em> has to be raised if a process is <code>Waiting</code>.</p>
<pre><code class="language-alloy">pred good3[s: State] {
    -- enrichment: if in CS or Waiting, flag must be raised
    all p: Process | (s.loc[p] = InCS or s.loc[p] = Waiting) implies p in s.flags    
    -- original: mutual exclusion
    #{p: Process | s.loc[p] = InCS} &lt;= 1        
}
</code></pre>
<div id="admonition-what-are-changing" class="admonition admonish-tip">
<div class="admonition-title">
<p>What are changing?</p>
<p><a class="admonition-anchor-link" href="chapters/relations/sets-induction-mutex.html#admonition-what-are-changing"></a></p>
</div>
<div>
<p>Notice again that we're only strengthening the thing we're trying to prove---<em>not</em> altering the model itself in any way.</p>
</div>
</div>
<p>At this point, the inductive check passes. <strong>We've just shown that this algorithm satisfies mutual exclusion.</strong> It might not give us some other properties we want, but this one is guaranteed.</p>
<h3 id="validating-the-check"><a class="header" href="#validating-the-check">Validating the Check</a></h3>
<p>We should probably make sure the two proof steps (the base case and the inductive step) aren't passing vacuously:</p>
<pre><code class="language-alloy">test expect {
    baseCaseVacuity: {
        some s: State | init[s] and good1[s]
    } for exactly 1 State is sat
    
    inductiveCaseVacuity: {
        some pre, post: State | 
                delta[pre, post] and good3[pre]
    } for exactly 2 State is sat

}
</code></pre>
<p>Fortunately, these both pass. So far, so good. But does this algorithm do everything we want? </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="going-beyond-assertions"><a class="header" href="#going-beyond-assertions">Going Beyond Assertions</a></h1>
<p>In the <a href="chapters/relations/./sets-induction-mutex.html">last section</a>, we were modeling this simplified (and perhaps buggy) mutual-exclusion protocol: </p>
<pre><code>while(true) { 
     // [location: uninterested]
    this.flag = true;  // visible to other threads!
    //  [location: waiting]
    while(other.flag == true);    
    //  [location: in-cs] // &quot;critical section&quot;   
    this.flag = false;    
}
</code></pre>
<div id="admonition-thread-vs-process" class="admonition admonish-note">
<div class="admonition-title">
<p>Thread vs. Process</p>
<p><a class="admonition-anchor-link" href="chapters/relations/sets-beyond-assertions.html#admonition-thread-vs-process"></a></p>
</div>
<div>
<p>I'm going to use the terms &quot;process&quot; and &quot;thread&quot; interchangably for this model. The difference is vital when programming, but it's not important for our purposes today.</p>
</div>
</div>
<p><strong>Exercise:</strong> If there are 3 possible locations for each process, and 2 possible flag values for each process, how many possible states are there overall in the system (without considering reachability)?</p>
<details>
<summary>Think, then click!</summary>
<p>Every process has <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> possible states. If 2 processes are executing this loop, there are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">36</span></span></span></span> possible states overall in the system. (Of course, we hope that not all of them are reachable!)</p>
</details>
<p>Our mutual exclusion property, which says that at most one process can be running the critical section at a time, is a statement that 4 specific states are unreachable: the ones where both processes are in the critical-section location (with any possible combination of boolean flags).</p>
<p>That property wasn't &quot;inductive&quot;: Forge could find transitions with a good prestate that end in one of those 4 bad states. So we enriched the invariant to <em>also</em> say that any thread in the waiting or critical-section locations must also have a raised flag. This prevented Forge from using many prestates it could use before: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Wai</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, for example. </p>
<p>Now we're going to do two things:</p>
<ul>
<li>build intuition for how the above actually worked; and</li>
<li>talk about how we could approch verifying other, richer, kinds of property.</li>
</ul>
<h2 id="drawing-the-picture"><a class="header" href="#drawing-the-picture">Drawing The Picture</a></h2>
<p>I really don't want to draw 36 states along with all their corresponding transition arcs. But maybe I don't need to. Let's agree that there are, in principle, 36 states, but just draw the part of the system that's <em>reachable</em>. We'll start with the initial state: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> and abbrieviate location tags to make writing them convenient for us: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span></span></span></span> for &quot;uninterested&quot;, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> for &quot;critical section&quot;, and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> for &quot;waiting&quot;.</p>
<p><strong>TODO: redraw with &quot;un&quot; rather than &quot;dis&quot;</strong></p>
<p><img src="https://i.imgur.com/02KboGA.png" alt="" /></p>
<p>Fill in the rest of the reachable states and transitions; don't add unreachable states at all. You should find the picture is significantly smaller than it would be if we had drawn <em>all</em> states.</p>
<p><img src="https://i.imgur.com/PQraiC7.png" alt="" /></p>
<p>Keep going! In diagrams like this, where there are only 2 processes, I like to split the state and draw the transition arcs for each process moving separately in different directions. (We're assuming, for now, that only one process moves at a time, even though they are executing concurrently.)</p>
<p><img src="https://i.imgur.com/EPMcgrl.png" alt="" /></p>
<p>I've marked the inability of a process to make progress with an &quot;<strong>X</strong>&quot;; it's a transition that can't be taken.</p>
<p>By drawing the entire graph of reachable states, we can see that the &quot;bad&quot; states are not reachable. <strong>This protocol satisfies mutual exclusion</strong> (as Forge showed us in the last section).</p>
<h2 id="other-properties"><a class="header" href="#other-properties">Other Properties</a></h2>
<p>Just mutual exclusion isn't good enough! After all, a protocol that never gave access to the critical section would guarantee mutual exclusion. We need at least one other property, one that might turn out to be more complex. We'll get there in 2 steps.</p>
<h3 id="property-deadlock-freedom"><a class="header" href="#property-deadlock-freedom">Property: Deadlock Freedom</a></h3>
<p>If, at some point, <em>nobody</em> can make progress, then surely the protocol isn't working. Both processes would be waiting forever, unable to ever actually get work done. </p>
<p>A state where <em>no</em> process can transition is called a <em>deadlock state</em>. Verifying that a system is free of deadlocks is a common verification goal.</p>
<p><strong>Exercise:</strong> Does the system above satisfy deadlock-freedom? (You can check using the diagram we produced.)</p>
<details>
<p>No. The state <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> is reachable, but has no exit transitions: neither thread can make progress in that state. Once the system is there, it's stuck there. And we can see that just by doing a visual search of the sub-system for the reachable states.</p>
</details>
<p>This kind of verification problem---checking properties of a transition system---is called <em>model checking</em>. Interestingly, there are other kinds of verification tools that use this graph-search approach, rather than the logic- and solver-based approach that Forge uses; you'll hear these tools referred to as <em>explicit-state model checkers</em> and <em>symbolic model checkers</em> respectively.</p>
<p><strong>Exercise:</strong> How could we check for deadlocks using just the graph we drew and our eyes?</p>
<details>
<summary>Think, then click!</summary>
In the same way we looked for a failure of mutual exclusion. We seek a reachable state with _no_ transitions out. And in this case, we find such a state.
</details>
<p><strong>Exercise:</strong> How could we check for deadlock in Forge?</p>
<p>We could either try the inductive approach, or use the finite-trace method. In the former, we would express that a &quot;good&quot; state is one where some transition is enabled---that is, one where the guard portion of some transition evaluates to true.</p>
<p><strong>Exercise:</strong> Working from the graph you drew, how could we fix the problem?</p>
<p>We could add a transition from the deadlock state. Maybe we could allow the first thread to always take priority over the second:</p>
<p><img src="https://i.imgur.com/gyt75Bk.png" alt="" /></p>
<p>This might manifest in the code as an extra way to escape the <code>while</code> loop. Of course, if we prioritize the first thread, the second thread is going to be very unhappy with this fix! But, regardless, adding this transition technically fixes the deadlock problem, and this property will now pass as well.</p>
<h3 id="property-non-starvation"><a class="header" href="#property-non-starvation">Property: Non-Starvation</a></h3>
<p>Even if there are no deadlocks, it's still possible for one thread to be waiting forever. We'd prefer a system where it's impossible for one thread to be kept waiting while the other thread continues to completely hog the critical section. This property is called <em>non-starvation</em>; more formally, it says that every thread must <em>always</em> (at any point) <em>eventually</em> (at some point) get access to the resource.</p>
<p><strong>Exercise:</strong> How could we check non-starvation in this graph?</p>
<details>
<summary>Think, then click!</summary>
<p>Not by looking for a single &quot;bad state&quot;. That won't suffice.</p>
</details>
<h3 id="safety-versus-liveness-intuition"><a class="header" href="#safety-versus-liveness-intuition">Safety Versus Liveness: Intuition</a></h3>
<p>Notice the differences between these properties. In particular, consider what a <em>full counterexample trace</em> for each must look like, if we were inclined to produce one. </p>
<ul>
<li>For mutual-exclusion and (in this formulation) deadlock-freedom, a counterexample trace could be finite. After some number of transitions, we'd reach a state where a deadlock or failure of mutual-exclusion has occurred. At that point, it's impossible for the system to recover; we've found an issue and the trace has served its purpose.</li>
<li>For a failure of non-starvation, on the other hand, no finite trace can suffice. It's always possible that just ahead, the system will suddenly recover and prevent a thread from being starved. So here, we need some notion of an <em>infinite counterexample trace</em> such that some thread never, ever, gets access.</li>
</ul>
<p>The difference here is a fundamental distinction in verification. We call properties that have finite counterexamples <em>safety properties</em>, and properties with only infinite counterexamples <em>liveness properties</em>. </p>
<div id="admonition-definitions" class="admonition admonish-note">
<div class="admonition-title">
<p>Definitions</p>
<p><a class="admonition-anchor-link" href="chapters/relations/sets-beyond-assertions.html#admonition-definitions"></a></p>
</div>
<div>
<p>People often describe safety properties as &quot;something bad never happens&quot; and liveness properties as &quot;something good must happen&quot;. I don't like this wording, because it assumes an understanding of &quot;goodness&quot; and &quot;badness&quot;. Instead, think about what a counterexample needs to look like. Then, one kind of property really is fundamentally different from the other, without requiring a notion of &quot;good&quot; or &quot;bad&quot;.</p>
</div>
</div>
<p>You'll usually find that a liveness property is more computationally complex to check. This doesn't mean that verifying liveness properties is always slower. It's just that we, and Forge, usually have to bring some additional tricks to bear. <strong>In the context of a <em>finite</em> state system, searching for an infinite counterexample amounts to looking for a reachable <em>cycle</em> in the graph, rather than just a single bad state.</strong></p>
<hr />
<p>We'll take a short break in the next section to say more about how Forge works. Then we'll return to the problem of defining infinite counterexample traces.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bounds-and-booleans-how-forge-works"><a class="header" href="#bounds-and-booleans-how-forge-works">Bounds and Booleans: How Forge Works</a></h1>
<blockquote>
<p>&quot;The world is everything that is the case. The world is the totality of facts, not of things. The world is determined by the facts, and by these being all the facts.&quot;</p>
<p>Ludwig Wittgenstein (Tractatus Logico-philosophicus)</p>
</blockquote>
<h2 id="how-does-forge-work"><a class="header" href="#how-does-forge-work">How Does Forge Work?</a></h2>
<p>We've hinted about this a bit in the <a href="chapters/solvers/../qna/static.html">past</a>, but now we'll go a bit deeper into how Forge works.</p>
<p>Recall that every <code>run</code> (or <code>test</code>, or <code>example</code>) command defines a <em>search problem</em>: find some instance that satisfies the given constraints and is within the given bounds. When you click &quot;Run&quot;, Forge compiles this search problem into a <em>boolean satisfiability problem</em>, which it then gives to an external boolean solver package.</p>
<p>There are complications, though. The search problem Forge needs to solve is in terms of <em>atomic objects</em>: objects of particular types, which can go into sets and relations and so on. In contrast, a boolean problem is in terms of just boolean variables: <em>atomic truths</em> that can be combined with <code>and</code>, <code>or</code>, etc. Somehow, we need to bridge that gap from object to boolean.</p>
<h2 id="what-boolean-solvers-understand"><a class="header" href="#what-boolean-solvers-understand">What Boolean Solvers Understand</a></h2>
<p>As an example of where Forge needs to end up, here's an example of a real problem to pass to a boolean solver. It's in a standard format called DIMACS, and it describes a way to find a solution to the <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">4-queens puzzle</a>. There are many other ways to express this problem, but we'll focus on this one. What do you think it's saying, exactly?</p>
<details>
<summary>Click to expand the DIMACS problem definition</summary>
<pre><code>c DIMACS for 4 queens
c 
p cnf 16 84
1 2 3 4 0
-1 -2 0
-1 -3 0
-1 -4 0
-2 -3 0
-2 -4 0
-3 -4 0
5 6 7 8 0
-5 -6 0
-5 -7 0
-5 -8 0
-6 -7 0
-6 -8 0
-7 -8 0
9 10 11 12 0
-9 -10 0
-9 -11 0
-9 -12 0
-10 -11 0
-10 -12 0
-11 -12 0
13 14 15 16 0
-13 -14 0
-13 -15 0
-13 -16 0
-14 -15 0
-14 -16 0
-15 -16 0
1 5 9 13 0
-1 -5 0
-1 -9 0
-1 -13 0
-5 -9 0
-5 -13 0
-9 -13 0
2 6 10 14 0
-2 -6 0
-2 -10 0
-2 -14 0
-6 -10 0
-6 -14 0
-10 -14 0
3 7 11 15 0
-3 -7 0
-3 -11 0
-3 -15 0
-7 -11 0
-7 -15 0
-11 -15 0
4 8 12 16 0
-4 -8 0
-4 -12 0
-4 -16 0
-8 -12 0
-8 -16 0
-12 -16 0
-1 -6 0
-1 -11 0
-1 -16 0
-2 -7 0
-2 -12 0
-2 -5 0
-3 -8 0
-3 -6 0
-3 -9 0
-4 -7 0
-4 -10 0
-4 -13 0
-5 -10 0
-5 -15 0
-6 -11 0
-6 -16 0
-6 -9 0
-7 -12 0
-7 -10 0
-7 -13 0
-8 -11 0
-8 -14 0
-9 -14 0
-10 -15 0
-10 -13 0
-11 -16 0
-11 -14 0
-12 -15 0
</code></pre>
<details>
<hr />
<p>Even without parsing it with a computer, the format tells us a lot about what a purely boolean solver understands. Here are a few facts about DIMACS:</p>
<ul>
<li>Boolean variables in DIMACS are represented by integers greater than zero. </li>
<li>If <code>p</code> is a variable, then <code>not p</code> is represented as the integer <code>-p</code>. </li>
<li>Lines starting with a <code>c</code> are comments.</li>
<li>The line <code>p cnf 16 84</code> says there are 16 variables and 84 <em>clauses</em>. A clause is a set of variables (or negated variables) all combined with <code>or</code>. E.g., <code>4 8 12 -16 0</code> means <code>4 or 8 or 12 or (not 16)</code>. (The <code>0</code> is a line-terminator.)</li>
<li>To satisfy the input, every clause must be satisfied.</li>
</ul>
<p>A set of constraints expressed as a set of clauses, each of which must hold true, is said to be in <em>Conjunctive Normal Form</em> (CNF). Boolean solvers often expect input in CNF, for algorithmic reasons we'll soon see.</p>
<p>Now that you know how to read the input format, you might be able to see how the boolean constraints work to solve the 4-queens problem. Any ideas?</p>
<details>
<summary>Think, then click!</summary>
<p>There's one variable for every square on the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> squares. <code>1 2 3 4</code> says that there must be a queen somewhere on the first row. <code>-1 -2</code> says that if there is a queen at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span></span></span></span> there cannot also be a queen at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span>. And so on.</p>
</details>
<h2 id="the-world-is-that-which-is-the-case"><a class="header" href="#the-world-is-that-which-is-the-case">&quot;The world is that which is the case&quot;</a></h2>
<p>Consider this Forge model and corresponding <code>run</code> command:</p>
<pre><code class="language-alloy">abstract sig Person {
  followers: set Person
}
one sig Alice, Bob, Charlie extends Person {}
run {some followers} for exactly 3 Person 
</code></pre>
<p>How many potential instances are there? Note that there can only ever be exactly 3 people, since <code>Person</code> is <code>abstract</code>.</p>
<details>
<summary>Think, then click!</summary>
<p>There are always exactly 3 people, and the only relation that can vary is <code>followers</code>, which has 2 columns. That means <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> potential pairs of people, and the field contains a set of those. The set either contains or does not contain each pair. So there are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span> potential instances.</p>
</details>
<hr />
<p>Notice how we reached that number. There are 9 potential pairs of people. 9 potential follower relationships. 9 essential things that may, or may not, be the case in the world. Nothing else.</p>
<p>If you run Forge on this model, you'll see statistics like these:</p>
<pre><code>#vars: (size-variables 10); #primary: (size-primary 9); #clauses: (size-clauses 2)
Transl (ms): (time-translation 122); Solving (ms): (time-solving 1)
</code></pre>
<p>The timing may vary, but the other stats will be the same. The thing to focus on is: 9 <code>primary variables</code>. Primary variables correspond to these atomic truths, which in this case is just who follows who in our fixed 3-person world: the number of rows that are potentially in the <code>followers</code> relation.</p>
<p>Let's try increasing the size of the world:</p>
<pre><code class="language-alloy">run {some followers} for 4 Person
</code></pre>
<p>Now we have a 4th person---or rather, we <em>might</em> have a 4th person. When we run, Forge shows:</p>
<pre><code>#vars: (size-variables 27); #primary: (size-primary 17); #clauses: (size-clauses 18)
</code></pre>
<p>We've gone from 9 to 17 primary variables. Why? </p>
<details>
<summary>Think, then click!</summary>
<p>There is another <em>potential</em> <code>Person</code> in the world; the world may be either size 3 or 4. Whether or not this fourth person exists is 1 new Boolean variable. And since there are <em>4</em> potential people in the world, there are now <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> potential follower relationships. </p>
<p>This equals 17 variables.</p>
</details>
</br>
<p>This is how Forge translates statements about atoms into statements about booleans. </p>
<h2 id="intermediate-representation-lower-bounds-upper-bounds"><a class="header" href="#intermediate-representation-lower-bounds-upper-bounds">Intermediate Representation: Lower Bounds, Upper Bounds</a></h2>
<p>Not every potential boolean needs to actually be considered, however. You might <a href="chapters/solvers/../qna/events.html">remember</a> that annotations like <code>{next is linear}</code> or partial instances defined by <code>example</code> or <code>inst</code> further limit the set of variables before the boolean solver encounters them. To understand this better, let's increase the verbosity setting in Forge. This will let us look at what Forge produces as an intermediate problem description before converting to boolean logic.</p>
<pre><code class="language-alloy">option verbose 5
</code></pre>
<p>Let's focus on a few lines. First, you should see this somewhere:</p>
<pre><code>(univ 20)
</code></pre>
<p>This tells the compiler that there are 20 potential objects in the world. (Why 20? Because the default bitwidth is 4: that's 16 integers, plus 4 potential people.) These objects get assigned integer identifiers by the compiler. </p>
<div id="admonition-3-different-meanings" class="admonition admonish-warning">
<div class="admonition-title">
<p>3 different meanings</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/bounds_booleans_how_forge_works.html#admonition-3-different-meanings"></a></p>
</div>
<div>
<p>This is an unfortunate overlap in the backend solver engine's language: all <em>atoms</em>, including atoms of type <code>Int</code>, get assigned integers by the engine. Moreover, the boolean solver itself uses integer indexes for boolean variables. <strong>These are not the same thing!</strong></p>
</div>
</div>
<p>Next, the compiler gets provided a <em>lower</em> and <em>upper</em> bound for every relation in the model.</p>
<ul>
<li>The <em>lower</em> bound is a set of tuples that must always be in the relation.</li>
<li>The <em>upper</em> bound is a set of tuples that may be in the relation.</li>
</ul>
<p>For example, here are the bounds on <code>Int</code>:</p>
<pre><code>(r:Int [{(0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) (14) (15)} :: {(0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) (14) (15)}])
</code></pre>
<p>The lower bound comes first, then a <code>::</code>, then the upper bound. These singleton tuples containing <code>0</code> through <code>15</code> are actually the representatives of integers <code>-8</code> through <code>7</code>. This is an artifact of how the solver process works.</p>
<p>Here's the bound on <code>Person</code> and its three sub-<code>sig</code>s:</p>
<pre><code>(r:Person [{(16) (17) (18)} :: {(16) (17) (18) (19)}])
(r:Alice [{(16)} :: {(16)}])
(r:Bob [{(17)} :: {(17)}])
(r:Charlie [{(18)} :: {(18)}])
</code></pre>
<p>The lower bound on <code>Person</code> contains 3 object identifiers, because there must always be 3 distinct objects (representing our three <code>one</code> sigs). There's an object in the upper, but not the lower, bound, because that fourth person may or may not exist. <code>Alice</code>, <code>Bob</code>, and <code>Charlie</code> are exactly set to be those 3 different always-present objects.</p>
<p>Finally, let's look at a field's bounds:</p>
<pre><code>(r:followers [(-&gt; none none) :: {(16 16) (16 17) (16 18) (16 19) (17 16) (17 17) (17 18) (17 19) (18 16) (18 17) (18 18) (18 19) (19 16) (19 17) (19 18) (19 19)}])
</code></pre>
<p>The <code>followers</code> relation may be empty, and it may contain any of the 16 ordered pairs of potential <code>Person</code> objects.</p>
<p><em>Any tuple in the upper bound of a relation, that isn't also in the lower bound, gets assigned a boolean variable.</em></p>
<ul>
<li>If a tuple isn't in the upper bound, it can never exist in an instance---it would always be assigned false---and so we needn't assign a variable.</li>
<li>If a tuple is in the lower bound, it must always exist in an instance---it would always be assigned true---and so we can again omit a variable.</li>
</ul>
<h2 id="from-forge-constraints-to-boolean-constraints"><a class="header" href="#from-forge-constraints-to-boolean-constraints">From Forge Constraints to Boolean Constraints</a></h2>
<p>Once we know the set of Boolean variables we'll use, we can translate Forge constraints to purely Boolean ones via substitution. Here's an example of how a basic compiler, without optimizations, might work.  Suppose we have the constraint:</p>
<pre><code class="language-alloy">all p: Person | Alice in p.followers
</code></pre>
<p>There are no <code>all</code> quantifiers in Boolean logic. How can we get rid of it?</p>
<details>
<summary>Think, then click!</summary>
<p>An <code>all</code> is just a big <code>and</code> over the upper bound on <code>Person</code>. So we substitute (note here we're using <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">erso</span><span class="mord mathnormal">n</span><span class="mord">3</span></span></span></span> as if it were defined in our model, because it's a <em>potential</em> part of every instance):</p>
<pre><code class="language-alloy">Alice in Alice.followers
Alice in Bob.followers
Alice in Charlie.followers
(Person3 in Person) implies Alice in Person3.followers
</code></pre>
</details>
</br>
<p>There are similar rules for other operators: a <code>some</code> becomes a big <code>or</code>, a relational join becomes a <code>some</code>-quantified statement about the existence of a value to join on, which then becomes a big <code>or</code>, etc.</p>
<h2 id="example-optimization-skolemization"><a class="header" href="#example-optimization-skolemization">Example optimization: Skolemization</a></h2>
<p>Forge performs a process called <em>Skolemization</em>, named after the logician <a href="https://en.wikipedia.org/wiki/Thoralf_Skolem">Thoralf Skolem</a>, to convert specific <code>some</code> quantifiers into supplemental relations. </p>
<p>The idea is: to satisfy a <code>some</code> quantifier, some atom exists that can be plugged into the quantifier's variable <code>x</code> to make the child formula true. Skolemization reifies that object witness into the model as a new relational constant <code>$x</code>. This:</p>
<ul>
<li>makes debugging easier sometimes, since you can immediately <em>see</em> what might satisfy the quantifier constraint; and</li>
<li>sometimes aids in efficiency, especially in a &quot;target poor&quot; environment like an unsatisfiable problem. </li>
</ul>
<p>By convention, these variables are prefixed with a <code>$</code>. So if you see a relation labeled <code>$x</code>, it's a Skolem relation that points to a value for a <code>some</code> quantified variable <code>x</code>. The relation will grow wider for every <code>all</code> quantifier that wraps the <code>some</code> quantifier being Skolemized. To see why that happens, suppose that we have a constraint: <code>all p: Person | all b: Bank | hasAccount[p,b] implies some i: Int | bankBalance[p,b,i]</code>. This constraint says that if a person has a bank account at a certain bank, there's a balance entered for that account. That balance isn't constant! It's potentially different for every <code>Person</code>-<code>Bank</code> pairing. Thus, <code>$i</code> would have arity 3: 2 for the &quot;input&quot; and 1 for the &quot;output&quot;. </p>
<div id="admonition-skolem-depth" class="admonition admonish-tip">
<div class="admonition-title">
<p>Skolem Depth</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/bounds_booleans_how_forge_works.html#admonition-skolem-depth"></a></p>
</div>
<div>
<p>You can change how deeply <code>some</code> quantifiers will get Skolemized by using the <code>skolem_depth</code> <a href="chapters/solvers/../../docs/running-models/options.html">option</a> in Forge.</p>
</div>
</div>
<!-- (Forge adds the numeric suffix to help disambiguate variables with the same name.)
`$x_some32783` -->
<h2 id="symmetry-breaking"><a class="header" href="#symmetry-breaking">Symmetry Breaking</a></h2>
<p>Let's return to the original Followers model:</p>
<pre><code class="language-alloy">abstract sig Person {
  followers: set Person
}
one sig Alice, Bob, Charlie extends Person {}
run {some followers} for exactly 3 Person 
</code></pre>
<p>We decided it probably had <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span> instances. But does it <em>really</em>? Let's hit <code>Next</code> a few times, and count! Actually, that sounds like a lot of work. Let's simplify things a bit more, instead:</p>
<pre><code class="language-alloy">abstract sig Person {
  follower: one Person -- changed: replace `set` with `one` 
}
one sig Alice, Bob, Charlie extends Person {}
run {} for exactly 3 Person  -- changed: don't run any predicates
</code></pre>
<p>Now everybody has exactly one follower. There are still 9 potential tuples, but we're no longer storing <em>sets</em> of them for each <code>Person</code>. Put another way, every instance corresponds to an ordered triplet of <code>Person</code> objects (Alice's follower, Bob's follower, and Charlie's follower). There will be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">27</span></span></span></span> instances. And indeed, if we click &quot;Next&quot; 26 times, this is what we see. (Whew.) </p>
<p>Now suppose we didn't name the 3 people, but just had 3 anonymous <code>Person</code> objects:</p>
<pre><code class="language-alloy">sig Person {
  follower: one Person
}
run {} for exactly 3 Person  -- changed: no named people
</code></pre>
<p>The math is still the same: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">27</span></span></span></span> instances. But now we only get <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> before hitting the unsat indicator of &quot;no more instances&quot; in the visualizer.</p>
<p>What's going on?</p>
<p>Forge tries to avoid showing you the same instance multiple times. And, if objects are un-named and the constraints can never distinguish them, instances will be considered &quot;the same&quot; if you can arrive at one by renaming elements of the other. E.g., </p>
<pre><code>Person1 follows Person2
Person2 follows Person3
Person3 follows Person1
</code></pre>
<p>would be considered equivalent to:</p>
<pre><code>Person2 follows Person1
Person3 follows Person2
Person1 follows Person3
</code></pre>
<p>since the individual <code>Person</code> atoms are <em>anonymous</em> to the constraints, which cannot refer to atoms by name. We call these instances <em>isomorphic</em> to each other, and say that there is a <em>symmetry</em> between them.  Formally, Forge finds every instance &quot;up to isomorphism&quot;. This is useful for:</p>
<ul>
<li>increasing the quality of information you get from paging through instances; and</li>
<li>(sometimes) improving the runtime on problems, especally if solutions are very rare.</li>
</ul>
<p>This process isn't always perfect: some equivalent instances can sneak in. Removing <em>all</em> equivalent instances turns out to sometimes be even more expensive than solving the problem. So Forge provides a best-effort, low cost attempt based on a <em>budget</em> for adding additional constraints to the problem, specifically to eliminate symmetries.</p>
<p>You can adjust the budget for symmetry breaking via an option:</p>
<ul>
<li><code>option sb 0</code> turns off symmetry breaking; and</li>
<li><code>option sb 20</code> is the default.</li>
</ul>
<p>If we turn off symmetry-breaking, we'll get the expected number of instances in the above run: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">27</span></span></span></span>.</p>
<div id="admonition-symmetry-breaking--filtering" class="admonition admonish-note">
<div class="admonition-title">
<p>Symmetry Breaking != Filtering</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/bounds_booleans_how_forge_works.html#admonition-symmetry-breaking--filtering"></a></p>
</div>
<div>
<p>Forge doesn't just filter instances after they're generated; it <em>adds</em> extra constraints that try to rule out symmetric instances. These constraints are guaranteed to be satisfied by at least one element of every equivalence class of instances. There's a lot of research work on this area, e.g., <a href="https://kaiyuanw.github.io/papers/paper22-tacas20.pdf">this paper</a> from 2020.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="relational-forge-qa"><a class="header" href="#relational-forge-qa">Relational Forge Q&amp;A</a></h1>
<h2 id="the-truth-about-dot"><a class="header" href="#the-truth-about-dot">The Truth About Dot</a></h2>
<p>This part of the notes is meant to reinforce what we'd previously done with relational join in Forge. We'll cover some of this in class, but the rest is here for your reference.</p>
<p>Let's go back to the directed-graph model we used before:</p>
<pre><code class="language-alloy">#lang forge
sig Person {
    friends: set Person,
    followers: set Person
}
one sig Nim, Tim extends Person {}
pred wellformed {
    -- friendship is symmetric
    all disj p1, p2: Person | p1 in p2.friends implies p2 in p1.friends
    -- cannot follow or friend yourself
    all p: Person | p not in p.friends and p not in p.followers
}
run {wellformed} for exactly 5 Person

pred reachableIn1To7Hops[to: Person, from: Person, fld: Person-&gt;Person] {
    to in from.fld or
    to in from.fld.fld or
    to in from.fld.fld.fld or 
    to in from.fld.fld.fld.fld or
    to in from.fld.fld.fld.fld.fld or
    to in from.fld.fld.fld.fld.fld.fld or
    to in from.fld.fld.fld.fld.fld.fld.fld 
    --  ... and so on, for any finite number of hops
    --  this is what you use the transitive-closure operator (^) 
    --  or the reachable built-in predicate for.
}
</code></pre>
<p>We said that chaining field access with <code>.</code> allows us to compute reachability in a certain number of hops. That's how <code>reachableIn1To7Hops</code> works. </p>
<p>However, there's more to <code>.</code> than this.</p>
<h3 id="beyond-field-access"><a class="header" href="#beyond-field-access">Beyond Field Access</a></h3>
<p>Let's run this model, and open up the evaluator. I'll show the first instance Forge found using the table view:</p>
<p><img src="https://i.imgur.com/CXrslMn.png" alt="" /></p>
<p>We saw that <code>Tim.friends</code> produces the set of <code>Tim</code>'s friends, and that <code>Tim.friends.friends</code> produces the set of <code>Tim</code>'s friends' friends. But let's try something else. Enter this into the evaluator:</p>
<pre><code>friends.friends
</code></pre>
<p>This looks like a nonsense expression: there's no object to reference the <code>friends</code> field of. But it means something in Forge:</p>
<p><img src="https://i.imgur.com/2m2esUg.png" alt="" /></p>
<p>What do you notice about this result? Recall that this is just a parenthetical way to show a set of tuples: it's got <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">erso</span><span class="mord mathnormal">n</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">erso</span><span class="mord mathnormal">n</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> in it, and so on.</p>
<details>
<summary>Think, then click!</summary>
<p>This seems to be the binary relation (set of 2-element tuples) that describes the friend-of-friend relationship. Because we said that friendship is symmetric, everyone who has friends is a friend-of-a-friend of themselves. And so on.</p>
</details>
</br>
<p>The <code>.</code> operator in Forge isn't exactly field access. It behaves that way in Froglet, but now that we have sets in the language, it's more powerful. It lets us combine relations in a path-like way.</p>
<h3 id="relational-join"><a class="header" href="#relational-join">Relational Join</a></h3>
<p>Here's the precise definition of the <em>relational join</em> operator (<code>.</code>):</p>
<p>If <code>R</code> and <code>S</code> are relations (with <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> columns, respectively), then <code>R.S</code> is defined to be the set of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>-column tuples: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> and </span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></p>
<p>That is, whenever the inner columns of the two relations line up on some value, their join contains some tuple(s) that have the inner columns eliminated. </p>
<p>In a path-finding context, this is why <code>Tim.friends.friends.friends.friends</code> has one column, and all the intermediate steps have been removed: <code>Tim</code> has one column, and <code>friends</code> has 2 columns. <code>Tim.friends</code> is the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>-column relation of <code>Tim</code>'s friends. And so on: every time we join on another <code>friends</code>, 2 columns are removed.</p>
<p>Let's try this out in the evaluator:</p>
<p><img src="https://i.imgur.com/oeZWrIT.png" alt="" /></p>
<p><img src="https://i.imgur.com/B3Hyk8h.png" alt="" /></p>
<p>Does this mean that we can write something like <code>followers.Tim</code>? Yes; it denotes the set of everyone who has <code>Tim</code> as a follower:</p>
<p><img src="https://i.imgur.com/yVaYWoz.png" alt="" /></p>
<p>Note that this is very different from <code>Tim.followers</code>, which is the set of everyone who follows <code>Tim</code>:</p>
<p><img src="https://i.imgur.com/MKu2M29.png" alt="" /></p>
<h3 id="testing-our-definition"><a class="header" href="#testing-our-definition">Testing Our Definition</a></h3>
<p>We can use Forge to validate the above definition, for relations with fixed arity. So if we want to check the definition for pairs of <em>binary</em> relations, up to a bound of <code>10</code>, we'd run:</p>
<pre><code class="language-alloy">test expect {
    joinDefinitionForBinary: {
        friends.followers = 
        {p1, p2: Person | some x: Person | p1-&gt;x in friends and 
                                           x-&gt;p2 in followers}
    } for 10 Person is checked
}
</code></pre>
<p>Notice that we don't include <code>wellformed</code> here: if we did, we wouldn't be checking the definition for <em>all</em> possible graphs.</p>
<h3 id="whats-join-good-for"><a class="header" href="#whats-join-good-for">What's Join Good For?</a></h3>
<p>Here's an example. Suppose you're modeling something like Dijkstra's algorithm. You'd need a weighted directed graph, which might be something like this:</p>
<pre><code class="language-alloy">sig Node {
    edges: Node -&gt; Int
}
</code></pre>
<p>But then <code>edges</code> has three columns, and you won't be able to use either <code>reachable</code> or <code>^</code> on it directly. Instead, you can eliminate the rightmost column with join: <code>edges.Int</code>, and then use that expression as if it were a <code>set</code> field.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="liveness-and-lassos"><a class="header" href="#liveness-and-lassos">Liveness and Lassos</a></h1>
<p>Let's return to thinking about our <a href="chapters/temporal/../relations/sets-induction-mutex.html">mutual-exclusion</a> <a href="chapters/temporal/../relations/sets-beyond-assertions.html">model</a>. We had noticed that &quot;every thread, whenever it becomes interested in the critical section, will eventually get access&quot; is a different kind of property—one that requires an <em>infinite</em> counterexample to disprove about the system. We called this sort of property a <em>liveness property</em>.</p>
<p>In a finite-state system, checking a liveness property amounts to looking for a bad cycle: some trace, starting from an initial state, that loops back on itself. Since these traces don't always loop back to the first state, we'll often call these <em>lasso traces</em>, named after a loop of rope. Here's an example. Consider the (reachable states only) transition system we drew last time:</p>
<p><img src="https://i.imgur.com/EPMcgrl.png" alt="" /></p>
<p><strong>Exercise:</strong> Can you find a lasso trace that violates our liveness property?</p>
<details>
<summary>Think, then click!</summary>
Here's one of them: 
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>; then</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>; then</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>; then back to</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
<p>This lasso trace <em>does</em> just happen to loop back to its first state. It shows the second process executing forever, and the first process remains uninterested forever. </p>
<p>Is this good or bad? It depends on how we write the property, and what we mean when we write it. If we want to say that no process can <em>WAIT</em> forever, then maybe this is OK. (Or is it?)</p>
</details>
<h2 id="checking-liveness-in-forge-attempt-1"><a class="header" href="#checking-liveness-in-forge-attempt-1">Checking Liveness In Forge (Attempt 1)</a></h2>
<p>How could we encode this sort of check in Forge? We wouldn't be able to use the inductive method—at least not in the same way—because we're looking for a bad cycle, not a bad state. So let's use the full finite-trace approach we used to generate games of Tic-Tac-Toe, but expand it to search for a bad <em>cycle</em>.</p>
<h3 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h3>
<p>We'll add the same finite-trace infrastructure as before. This time we're able to use full Forge, so we can use the transpose (<code>~</code>) operator to say that the initial state has no predecessors.</p>
<pre><code class="language-alloy">one sig Trace {
    initialState: one State,
    nextState: pfunc State -&gt; State
}

pred trace {
    no Trace.initialState.~(Trace.nextState)
    init[Trace.initialState]
    all s: State | some Trace.nextState[s] implies {
        delta[s, Trace.nextState[s]]
}
pred lasso {
    trace
    all s: State | some Trace.nextState[s]
}
</code></pre>
<p>Let's test our <code>lasso</code> predicate to make sure it's satisfiable. And, because we're careful, let's make sure it's <em>not</em> satisfiable if we don't give the trace enough states to loop back on itself:</p>
<pre><code class="language-alloy">test expect {
  lassoVacuity: { lasso } is sat
  lassoVacuityNotEnough: { lasso } for 2 State is unsat
}
</code></pre>
<h3 id="beware"><a class="header" href="#beware">Beware...</a></h3>
<p>There is actually a hidden overconstraint bug in our <code>lasso</code> predicate. It's not so extreme as to make the predicate unsatisfiable---so the test above passes! </p>
<p><strong>Exercise:</strong> What's the problem?</p>
<details>
<summary>Think, then click!</summary>
<p>We said that the initial state has no predecessor. This will prevent the lasso from looping back to the start—it must always have some states before the cycle begins. If the bug we're looking for always manifests as a loop back to the starting state, we would be <strong>lulled into a false sense of success</strong> by Forge, because it would fail to find the counterexample.</p>
<p>In fact, this would be a problem in the current model, since the counterexample we'd like to find does loop back to the original state.</p>
</details>
</br>
<p><strong>Watch out for this kind of bug!</strong></p>
<p>This is why thinking through vacuity testing is important. It's also a reason why, maybe, we'd like to avoid having to write all this temporal boilerplate (and potentially introduce bugs when we make a mistake).</p>
<h3 id="identifying-a-bad-cycle"><a class="header" href="#identifying-a-bad-cycle">Identifying A Bad Cycle</a></h3>
<p>If we know that the trace is a lasso, we can write a predicate that identifies some process being starved. This isn't easy, though. To see why, look at this initial attempt, which says that our property fails if <code>ProcessA</code> never enters the critical section:</p>
<pre><code class="language-alloy">pred badLasso {
  lasso
  all s: State | s.loc[ProcessA] != InCS
}
test expect {
  checkNoStarvation: { badLasso } is unsat
}

</code></pre>
<p>This is <em>unsatisfiable</em>; the test passes. Could anything potentially be going wrong in our model, though?</p>
<p>We might first wonder, as we usually should, whether the test allocates enough states to reasonably find a counterexample. We've got 8 reachable states, so maybe we'd need 8 (or 9?) states in the test. That's true! There's something else wrong here, and it's more subtle. We'll need to address both of these problems to make progress. </p>
<p><strong>Exercise:</strong> What else is wrong?</p>
<details>
<summary>Think, then click!</summary>
<p>The <code>badLasso</code> predicate wouldn't hold true if the system allowed <code>ProcessA</code> to enter the critical section <em>once</em> (and only once). We want <code>ProcessA</code> to be able to get access (eventually) whenever it needs that access. That is, we need to say that the <em>loop</em> of the lasso contains no states where <code>ProcessA</code> is in the critical section, no matter what happens before the cycle starts.</p>
</details>
</br>
<p>That sounds like a lot of work: we'd need to identify the sub-sequence of states representing the cycle and properly apply the constraint to only those states. More importantly, it sounds really easy to get this wrong if we write it ourselves, at this low level of abstraction, because the specifics might change as the model evolves. </p>
<p>There's a better way. Forge has another language level—Temporal forge—that provides all of this automatically. </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="temporal-forge"><a class="header" href="#temporal-forge">Temporal Forge</a></h1>
<p>Temporal Forge works by adding additional operators to the language. You can still do everything you could before (with one exception that we'll get to) in Relational Forge, but you get new operators—new operators like <code>always</code> and <code>eventually</code>—that make describing properties and specifying systems easier. Moreover, these operators are standard in industrial model-checking tools.</p>
<!-- Livecode is [here](./mutex_temporal.frg). -->
<!-- ## Temporal Operators: Survey

I wonder if we could add notions of "always" and "eventually" and so on to Forge. That would help us avoid some of the errors that occur when we try to represent lasso traces manually.

~~~admonish note title="CSCI 1710"
Your class exercise today is to try out [this survey](https://docs.google.com/forms/d/e/1FAIpQLSf4nNtzjVhEv3daqZeySbsApoX9L2cwVts23qIzOlX6Ug8nug/viewform?usp=sf_link).  

We're asking whether a _specific trace_ satisfies a constraint that uses the new operators.
~~~ -->
<p>Temporal Forge takes away the need for you to explicitly model traces, and gives some convenient syntax for describing what can change over time. But there is something to watch out for: Temporal Forge <strong>forces the engine to only ever find lasso traces</strong>. It's very convenient if that's what you want, but <em>don't use it if you don't want a lasso trace</em>!</p>
<h2 id="example-integer-counter"><a class="header" href="#example-integer-counter">Example: Integer Counter</a></h2>
<p>Here's a quick example that motivates how Temporal Forge works, and some pitfalls that can occur when you use it. Suppose that we're modeling a system with a single integer counter:</p>
<pre><code class="language-forge">#lang forge/temporal

-- enable traces of up to length 10
option max_tracelength 10

one sig Counter {
  -- The value of the &quot;counter&quot; field may vary over time.
  var counter: one Int
}

run {
  -- Temporal-mode formulas are interpreted from an implicit current time. By default, 
  -- we're talking about the start of the trace. So, the counter starts at 0.
  Counter.counter = 0
  -- `always` means &quot;now and at every time in the future&quot;. The prime (') operator 
  -- says &quot;value in the next state&quot;. So this means that the counter is incremented 
  -- with every transition:
  always Counter.counter' = add[Counter.counter, 1]
} for 3 Int
</code></pre>
<p>First, notice that we didn't need to define the structure of a trace. We got that for free by using Temporal Forge, which only ever finds traces.</p>
<p>Second, this is <em>satisfiable</em>, as we might expect. But what happens if you change the bound on <code>Int</code> to <code>for 4 Int</code>? </p>
<p><strong>Exercise:</strong> Try it. What happens? Why do you think it did happen?</p>
<details>
<summary>Think, then click!</summary>
<p>It's unsatisfiable with the new bound. This is strange: usually when we increase the scope on a <code>sig</code>, without using the <code>exactly</code> keyword, we only ever make something <em>satisfiable</em> (because we're increasing the possible sizes of instance that Forge checks). </p>
<p>The problem is that, because <strong>only lasso traces are found</strong>, Forge can only satisfy this model by exploiting integer overflow. At <code>3 Int</code>, which supports values between <code>-4</code> and <code>3</code>, the counter progresses like this: <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, (overflow to) <code>-4</code>, <code>-3</code>, <code>-2</code>, <code>-1</code>, <code>0</code> and so on. We have 10 states to work with, which is enough to wrap around back to <code>0</code>. </p>
<p>In contrast, at <code>4 Int</code>, the values range from <code>-8</code> to <code>7</code>. Overflow will happen as normal, but only when moving from <code>7</code> to <code>-8</code>. The 10 states we have won't be enough to actually loop back around to <code>0</code>—and there <em>must</em> be a loop somewhere in a lasso trace. So Temporal Forge says that the model is unsatisfiable at trace length 10, <code>for 4 Int</code>. </p>
</details>
<h2 id="converting-to-temporal-forge"><a class="header" href="#converting-to-temporal-forge">Converting to Temporal Forge</a></h2>
<p>Let's convert the mutual-exclusion model into Temporal Forge. We'll add the necessary options first:</p>
<pre><code class="language-alloy">#lang forge/temporal

option max_tracelength 10
</code></pre>
<div id="admonition-option-names" class="admonition admonish-warning">
<div class="admonition-title">
<p>Option Names</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/temporal_operators.html#admonition-option-names"></a></p>
</div>
<div>
<p>Be sure to include the underscore! Misspellings like <code>maxtracelength</code> aren't a valid option name.</p>
</div>
</div>
<p>Now we'll update the data definitions. We no longer have a <code>State</code> sig. Or rather, we do, but we would only have one of them and let its fields vary with time. Because both the <code>flags</code> and <code>loc</code> fields change over time, we'll make both of them <code>var</code>, and we'll change the name of <code>State</code> to avoid confusion:</p>
<pre><code class="language-alloy">one sig World {
  var loc: func Thread -&gt; Location,
  var flags: set Thread
}
</code></pre>
<p>At any moment in time, every thread is in exactly one location. And, at any moment in time, each thread has either raised or lowered its flag. </p>
<p>Now for the predicates. In Temporal Forge, we don't have the ability to talk about specific pre- and post-states: the language handles the structure of traces for us. This means we have to change the types of our predicates. For <code>init</code>, we have:</p>
<pre><code class="language-alloy">-- No argument! Temporal mode is implicitly aware of time
pred init {
    all p: Process | World.loc[p] = Uninterested
    no World.flags 
}
</code></pre>
<p>The loss of a <code>State</code> <code>sig</code> is perhaps disorienting. How does Forge evaluate <code>init</code> without knowing which state we're looking at? <strong>In Temporal Forge, every constraint is evaluated not just in an instance, but in that instance at some <em>moment in time</em></strong>. You don't need to explicitly mention the moment. So the formula <code>no World.flags</code> is true exactly when, at the current time, there's no flags raised. Using <code>init</code> is like saying &quot;are we in an initial state <em>right now</em>?&quot;</p>
<p>Similarly, we'll need to change our transition predicates:</p>
<pre><code class="language-alloy">-- Only one argument; same reason as above
pred raise[p: Process] {
    // pre.loc[p] = Uninterested
    // post.loc[p] = Waiting
    // post.flags = pre.flags + p
    // all p2: Process - p | post.loc[p2] = pre.loc[p2]

    // GUARD
    World.loc[p] = Uninterested
    // ACTION
    World.loc'[p] = Waiting
    World.flags' = World.flags + p
    all p2: Process - p | World.loc'[p2] = World.loc[p2]
}
</code></pre>
<p>I've left the old version commented out so you can contrast the two. Again, the predicate is true subject to an implicit moment in time. <strong>The priming (') operator means &quot;this expression in the next state&quot;</strong>; so if <code>raise</code> holds at some point in time, it means there is a specific relationship between the current and next moments.</p>
<p>We'll convert the other predicates similarly, and then run the model:</p>
<pre><code class="language-alloy">run {
    -- start in an initial state
    init
    -- in every state of the lasso, the next state is defined by the transition predicate
    always {some t: Thread | raise[t] or enter[t] or leave[t]}
}
</code></pre>
<p>This is the general shape of things! There are still some potential problems remaining, but we'll get to them shortly. First, we need to talk about how to view a Temporal Forge instance.</p>
<h2 id="running-a-temporal-model"><a class="header" href="#running-a-temporal-model">Running A Temporal Model</a></h2>
<p>When we run, we get something that looks like this:</p>
<p><img src="https://i.imgur.com/LsN0gfB.png" alt="" /></p>
<h3 id="new-buttons"><a class="header" href="#new-buttons">New Buttons!</a></h3>
<p>In temporal mode, Sterling has 2 &quot;next&quot; buttons, rather than just one. </p>
<ul>
<li>The &quot;Next Trace&quot; button will hold all non-<code>var</code> relations constant, but ask for a new trace that varies the <code>var</code> relations. </li>
<li>The &quot;Next Config&quot; button forces the non-<code>var</code> relations to differ. 
Having different buttons for these two ideas is useful, since otherwise Forge is free to change the value of any relation, even if it's not what you want changed. </li>
</ul>
<h3 id="trace-minimap"><a class="header" href="#trace-minimap">Trace Minimap</a></h3>
<p>In Temporal Forge, Sterling shows a &quot;mini-map&quot; of the trace in the &quot;Time&quot; tab. You can see the number of states in the trace, as well as where the lasso loops back. </p>
<p><strong>It will always be a lasso, because Temporal Forge never finds anything but lassos.</strong></p>
<p>You can use the navigation arrows, or click on specific states to move the visualization to that state: </p>
<p><img src="https://i.imgur.com/KnLqfJm.png" alt="" /></p>
<p>Theming works as normal, as do custom visualizers (although read the documentation if you're writing your own visualizer; there are some small changes like using <code>instances</code> instead of <code>instance</code> to access data). </p>
<h3 id="so-whats-missing"><a class="header" href="#so-whats-missing">So what's missing?</a></h3>
<p><em>Do not</em> try to use <code>example</code> in temporal mode. The <code>example</code> and <code>inst</code> constructs define bounds for <em>all states at once</em> in Temporal forge. While <code>inst</code> can still be very useful for optimization, <code>example</code> will prevent anything it binds from ever changing in the trace, which isn't very useful for test cases. Instead, use constraints.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="linear-temporal-logic"><a class="header" href="#linear-temporal-logic">Linear Temporal Logic</a></h1>
<p>Formally, the temporal operators Forge provides come from a language called Linear Temporal Logic (or LTL). It's <em>temporal</em> because it has time-aware operators like <code>always</code> and <code>eventually</code>, and it's <em>linear</em> because it's interpreted over (infinite) linear traces. </p>
<div id="admonition-industrial-practice" class="admonition admonish-note">
<div class="admonition-title">
<p>Industrial Practice</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/temporal_operators_2.html#admonition-industrial-practice"></a></p>
</div>
<div>
<p>LTL is commonly used in industry. And even where it isn't used directly, many other temporal specification languages are either related to LTL (e.g., branching-time logics like CTL) or inspired by it (e.g., Lamport's <a href="https://lamport.azurewebsites.net/tla/tla.html"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">L</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span></span></span></span></span></span></span></span></a> and other more recent languages). There are a <em>lot</em> of industrial model-checking tools out there, using a lot of different languages, but learning LTL will help you build intuition for nearly all of them.</p>
<p>And, on the research side of things, there's a lot of temporal logic use as well. For example, <a href="https://nakulgopalan.github.io/docs/sequence-sequence-language.pdf">this paper</a> on using temporal logics in AI to specify robot behaviors.</p>
</div>
</div>
<h2 id="how-to-read-a-temporal-formula"><a class="header" href="#how-to-read-a-temporal-formula">How To Read A Temporal Formula</a></h2>
<p>Recall that:</p>
<ul>
<li>time is <em>implicit</em> in temporal mode, and </li>
<li>temporal mode only ever finds lasso traces. </li>
</ul>
<p>When you write a constraint in temporal mode, it's true with respect to an instance (which is always a lasso trace) <em>and a time index</em> into that trace. Thus the <code>init</code> predicate may be true, or not true, depending on which state you're looking at.</p>
<p>Evaluation always <em>starts</em> at the first state. This corresponds to the top-level <code>run</code> command or <code>test</code>. I didn't say &quot;the initial state&quot;, because if we've got a predicate that encodes &quot;initial state&quot;, it  won't be enforced unless we've told Forge to do so. This is why, usually, you'll start by putting: <code>init</code> (or whatever your initial-state predicate is named) in your top-level <code>run</code>. </p>
<p>As soon as temporal operators become involved, however, the &quot;evaluate in the first state&quot; rule starts to change because the current time index may change.</p>
<h2 id="moving-forward-in-time"><a class="header" href="#moving-forward-in-time">Moving Forward In Time</a></h2>
<p>You can refer to the <em>next</em> state (relative to the current one, whatever it is) by using the <code>next_state</code> operator. If I wanted to say that the <em>second</em> and <em>third</em> states would also need to be initial states, I'd write more in the top-level <code>run</code> block:</p>
<pre><code>init
next_state init
next_state next_state init
</code></pre>
<p>It's rare you'd do something like this in practice, but it's a good first demonstration of the operator.</p>
<p>```admonish note title=&quot;Why <code>next_state</code>?&quot;
The keyword is, admittedly, a little verbose. But it was the best of the various candidates at hand:</p>
<ul>
<li>In many settings, this LTL operator is usually called <code>X</code>, which is not very descriptive. (When I read <code>X</code>, I think &quot;variable&quot;!)</li>
<li>In Forge's parent language, Alloy 6, the operator is called <code>after</code>, but this can lead to some misconceptions since <code>A after B</code> might be misinterpreted as a binary operator, and Forge and Alloy both have implicit <code>and</code> via newlines, so <code>A after B</code> would actually mean <code>A and (after B)</code>. </li>
<li>I've heard <code>afterward</code> suggested, but that risks confusion with <code>always</code> or <code>eventually</code>.</li>
</ul>
<pre><code>
## Quantifying Over Time

What does it mean for something to `always` be true, or to `eventually` hold? These terms quantify over time: if something is `always` true, it's true at all time indexes (starting now). If something is `eventually` true, it's true at _some_ time index (possibly now). 

So if we wanted to say that every state in the trace transitions to its successor in accordance with our `move` predicate, we'd say: `always move`. In the last section, because we had multiple predicates, and each took an argument, we wrote:

```forge
always {some t: Thread | raise[t] or enter[t] or leave[t]}
</code></pre>
<h3 id="nesting-operators"><a class="header" href="#nesting-operators">Nesting Operators</a></h3>
<p>Just like you can nest <code>all</code> and <code>some</code>, you can nest <code>always</code> and <code>eventually</code>. We'll need to do this to express properties like non-starvation. In fact, let's think about how to express non-starvation now! </p>
<p>We had informally written non-starvation in our mutex model as something like &quot;once a process becomes interested, it eventually gets access&quot;. How would you write this using temporal operators, assuming that <code>interested</code> and <code>access</code> were predicates describing the process becoming interested and getting access respectively?</p>
<p><strong>Exercise:</strong> Try this!</p>
<details>
<summary>Think, then click for a possible solution.</summary>
<p>We might start with: <code>interested =&gt; eventually access</code>. That would be a reasonable start: if the process is interested, it eventually gets access. The problem is that the interest is measured <em>now</em>---that is, at whatever time index Forge is currently looking. </p>
</details>
<hr />
<p>Clearly we need to add some sort of temporal operator that prevents the above issue. Here's a possible candidate: <code>(eventually interested) =&gt; (eventually access)</code>. </p>
<p><strong>Exercise:</strong> What's wrong with this one?</p>
<details>
<summary>Think, then click!</summary>
<p>The problem here is that there's no connection between the time at which the left-hand side holds, and the time at which the right-hand side holds. To force that relationship (access <em>after</em> interest) we need to nest the two temporal quantifiers.</p>
</details>
<hr />
<p>How about <code>eventually (interested =&gt; (eventually access))</code>? </p>
<details>
<summary>Think, then click!</summary>
<p>This constraint isn't strong enough. Imagine a trace where the process never gets access, but is interested only (say) half the time. Then any of those disinterested states will satisfy the subformula <code>interested =&gt; (eventually access)</code>. </p>
<p>Why? Think about how an implication is satisfied. It can be satisfied if the right-hand side is true, but also if the left-hand side is false—in the case where no obligation needs to be incurred! So the implication above evaluates to <em>true</em> in any state where the process isn't interested. And using <code>eventually</code> means <em>any</em> single such state works...</p>
</details>
<hr />
<p>It seems like we need a different temporal operator! What if we combine <code>always</code> and <code>eventually</code>? </p>
<p><strong>Exercise:</strong> Give it a try.</p>
<details>
<summary>Think, then click!</summary>
<p>We'll say: <code>always {interested =&gt; eventually access}</code>. Now, no matter what time it is, if the process is interested, it has to eventually get access. </p>
<p>This sort of <code>always</code>-<code>eventually</code> pattern is good for (contingent) &quot;infinitely often&quot; properties, which is exactly what non-starvation is.</p>
</details>
<h2 id="lets-try-it-out"><a class="header" href="#lets-try-it-out">Let's Try It Out!</a></h2>
<p>I'm going to ask you to play the role of Forge. I've listed some temporal constraints below, and would like you to come up with some instances (lasso traces) that satisfy them. Don't use Forge unless you've already tried, and are stumped. </p>
<p>For all examples, you may come up with your own shape of the world. That is, you might pick a University (where a state is a semester, with courses offered and taken) or your experience waiting for an elevator in the CIT, or anything else from your life! I'll use <code>A</code>, <code>B</code> and <code>C</code> to denote arbitrary facts that might be true, or not true---your job is to plug in specifics, and then find a satisfying trace!</p>
<p>I'll use a lot of parentheses, to avoid confusion about operator precedence...</p>
<p><strong>Exercise:</strong> <code>eventually (always (A or B))</code></p>
<details>
<summary>Think, then click!</summary>
<p>Suppose <code>A</code> stands for weekday, and <code>B</code> for weekend. Then the normal progression of time satisfies the constraint: after some point (perhaps right now) it will always be either a weekday or a weekend.</p>
<p>I am probably abstracting out some important details here, like the heat-death of the universe. But that's not really the point. The point is that alternation between <code>A</code> and <code>B</code> is allowed---it's always <em>either</em> one or the other, or possibly even both.</p>
</details>
<hr />
<p><strong>Exercise:</strong> <code>always (eventually (X and (next_state Y)))</code></p>
<details>
<summary>Think, then click!</summary>
<p>Suppose <code>A</code> stands for &quot;Saturday&quot;, and <code>B</code> for &quot;Sunday&quot;. Then it's always true that, at <em>any point</em> in time, there is a Saturday-Sunday pair of days in the future. </p>
</details>
<hr />
<p><strong>Exercise:</strong> <code>always ((eventually X) or (always Y)))</code></p>
<details>
<summary>Think, then click!</summary>
<p>Suppose <code>A</code> stands for &quot;final exam or demo&quot;, and <code>B</code> for &quot;graduated&quot;. Then, at <em>any point</em> in time, either there's a final in your future <em>or</em> you've graduated (and stay graduated forever). </p>
<p>Note that this doesn't mean you can't take a final exam after graduating if you want to. Both sides of the <code>or</code> can be true. It just means that, at any point, if you haven't graduated permanently, you must eventually take an exam.</p>
</details>
<hr />
<h2 id="non-starvation-in-our-lock-model"><a class="header" href="#non-starvation-in-our-lock-model">Non-Starvation in our Lock Model</a></h2>
<p>A deadlock state is one where <em>no</em> outgoing transitions are possible. How can we write a test in Temporal Forge that tries to find a reachable deadlock state? There are two challenges:</p>
<ul>
<li>How do we phrase the constraint, in terms of the transition predicates we have to work with? </li>
<li>How do we even allow Forge to find a deadlock, given that temporal mode <em>only</em> ever finds lasso traces? (A deadlock in a lasso trace is impossible, since a deadlock prevents progress!)</li>
</ul>
<p>Let's solve the second challenge first, since it's more foundational.</p>
<h3 id="finding-deadlocks-via-lassos"><a class="header" href="#finding-deadlocks-via-lassos">Finding Deadlocks Via Lassos</a></h3>
<p>We could prevent this issue by allowing a <code>doNothing</code> transition from every state. Then from Forge's perspective there's no &quot;deadlock&quot;, and a lasso trace can be found. We can add such a transition easily enough: </p>
<pre><code class="language-alloy">pred doNothing {
    flags' = flags
    loc' = loc
}
run {
    init
    always { 
        (some p: Process | {raise[p] or enter[p] or leave[p]})
        or doNothing 
    }
}
</code></pre>
<p>But we have to do so carefully, or the fix will cause new problems. If we allow a <code>doNothing</code> transition to happen <em>anywhere</em>, then Forge can find traces when nothing ever happens. In that case, our liveness property is definitely going to fail, even if we were modeling a smarter algorithm. So we need to reduce the power of <code>doNothing</code> somehow. </p>
<p>Put another way: we started with an <em>overconstraint</em> bug: if only lassos can be found, then we can't find a trace exhibiting deadlock. Adding a powerful <code>doNothing</code> fixes the overconstraint but adds a new <em>underconstraint</em>, because we'll get a lot of garbage traces where the system can just pause arbitrarily (while the trace continues).</p>
<p>We saw this phenomenon earlier when we were modeling <a href="chapters/temporal/../ttt/ttt_games.html">tic-tac-toe games</a>, and wanted to work around the fact that the <code>is linear</code> annotation forces exact bounds. We can use the same ideas in the fix here.</p>
<h2 id="finding-deadlock"><a class="header" href="#finding-deadlock">Finding Deadlock</a></h2>
<p>Let's look at one of our transitions:</p>
<pre><code class="language-alloy">pred raise[p: Process] {
    // GUARD
    World.loc[p] = Disinterested
    // ACTION
    World.loc'[p] = Waiting
    World.flags' = World.flags + p
    all p2: Process - p | World.loc'[p2] = World.loc[p2]
}
</code></pre>
<p>Notice it's split into a &quot;guard&quot; and an &quot;action&quot;. If all the constraints in the guard are true, the transition <em>can</em> occur. Formally, we say that if all the guard constraints hold, then the transition is <em>enabled</em>. When should <code>doNothing</code> be enabled? When no other transition is. What if we made an &quot;enabled&quot; predicate for each of our other transitions? Then we could write: </p>
<pre><code class="language-alloy">pred doNothing {
    -- GUARD (nothing else can happen)
    not (some p: Process | enabledRaise[p]) 
    not (some p: Process | enabledEnter[p]) 
    not (some p: Process | enabledLeave[p]) 
    -- ACTION (no effect)
    flags' = flags
    loc' = loc
}
</code></pre>
<p>We won't create a separate <code>enabledDoNothing</code> predicate. But we will add <code>doNothing</code> to the set of possible moves:</p>
<pre><code class="language-alloy">always { 
    (some p: Process | {raise[p] or enter[p] or leave[p]})
    or doNothing 
}
</code></pre>
<p>And we'd also better create those 3 <code>enabled</code> predicates, too. E.g., we might write:</p>
<pre><code>pred raiseEnabled[t: Thread] {
    World.loc[t] = Uninterested 
}
</code></pre>
<p>which we would then use in the <code>raise</code> transition predicate.</p>
<p>Finally, we can write a check looking for deadlocks:</p>
<pre><code class="language-alloy">test expect {
    noDeadlocks_counterexample: {
        -- setup conditions
        init
        always { 
            (some p: Process | {raise[p] or enter[p] or leave[p]})
            or doNothing 
        }
        -- violation of the property
        not always {
            some p: Process |
                enabledRaise[p] or
                enabledEnter[p] or
                enabledLeave[p] 
        }
    } is sat
}
</code></pre>
<p>which fails. Why? The counterexample (at least, the one I got) is 3 states long. And in the final state, both processes are <code>Waiting</code>. Success! Or, at least, success in <strong>finding the deadlock</strong>. But how should we fix the algorithm? And how can we avoid confusion like this in the future?</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="obligations-and-the-past"><a class="header" href="#obligations-and-the-past">Obligations and The Past</a></h1>
<div id="admonition-temporal-forge-reminders" class="admonition admonish-tip">
<div class="admonition-title">
<p>Temporal Forge Reminders</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/obligations_past.html#admonition-temporal-forge-reminders"></a></p>
</div>
<div>
<ul>
<li>Remember the definition of &quot;configuration&quot;: the value of all relations that aren't marked <code>var</code>. Thus, if you click the Sterling button that asks for a <em>new configuration</em>, the solver will always find a new trace that varies on one or more of <em>those</em> relations. </li>
<li><em>Do not</em> try to use <code>example</code> in temporal mode. In fact, it's disabled; you'll get an error message. For reasons we'll get to soon (when we talk about how Forge works) <code>example</code> and <code>inst</code> both constrain <em>all states</em> in temporal mode, and so an example will prevent anything it binds from ever changing in the trace. This can still be useful for optimization, but isn't so great if you're trying to write an example where things change over time. Start using <code>assert</code> more often!</li>
</ul>
</div>
</div>
<!-- 

The in-class exercise is [here](https://docs.google.com/forms/d/e/1FAIpQLSemtfAG44sxqkRSS4imTcGC1LVwcHgJWOrgrHp3wXyLbuMAZw/viewform?usp=sf_link). The livecode is the same model we've been working on: the [locking algorithm](./mutex_temporal.frg), and the (new) [traffic lights example](./traffic.frg). -->
<div id="admonition-temporal-forge-documentation" class="admonition admonish-note">
<div class="admonition-title">
<p>Temporal Forge Documentation</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/obligations_past.html#admonition-temporal-forge-documentation"></a></p>
</div>
<div>
<p>Consult the <a href="https://csci1710.github.io/forge-documentation/electrum/electrum-overview.html">Forge documentation</a> if you want further clarification on temporal operators.</p>
</div>
</div>
<p>Suppose we've written a model where <code>stopped</code> and <code>green_light</code> are predicates that express our car is stopped, and the light is green. Now, maybe we want to write a constraint like, at the current moment in time, it's true that:</p>
<ul>
<li>the light must eventually turn green; and </li>
<li>the <code>stopped</code> predicate must hold true until the light turns green. </li>
</ul>
<p>We can write the first easily enough: <code>eventually green</code>. But what about the second? We might initially think about writing something like: <code>always {not green implies stopped}</code>. But this doesn't quite express what we want. </p>
<p><strong>Exercise:</strong> Why not?</p>
<details>
<summary>Think, then click!</summary>
<p>The formula <code>always {not green implies stopped}</code> says that at any single moment in time, if the light isn't green, our car is stopped. This isn't the same as &quot;the <code>stopped</code> predicate holds until the light turns green&quot;. For one thing, the latter applies <em>until</em> <code>green</code> happens, and after that there is no obligation remaining on <code>stopped</code> for the rest of the trace. </p>
</details>
<hr />
<p>In LTL, the <code>until</code> operator can be used to express a stronger sort of <code>eventually</code>. If I write <code>stopped until green_light</code>, it encodes the meaning above. This operator is a great way to phrase obligations that might hold only until some releasing condition occurs.</p>
<div id="admonition-strong-vs-weak-until" class="admonition admonish-tip">
<div class="admonition-title">
<p>Strong vs. Weak Until</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/obligations_past.html#admonition-strong-vs-weak-until"></a></p>
</div>
<div>
<p>Some logics include a &quot;weak&quot; <code>until</code> operator that doesn't actually enforce that the right-hand side ever holds, and so the left-hand side can just be true forever. But, for consistency with industrial specification languages (at least, most of those we're familiar with) Forge's <code>until</code> is &quot;strong&quot;: it requires the right-hand side hold <em>eventually</em>.</p>
</div>
</div>
<div id="admonition-the-car-doesnt-have-to-move" class="admonition admonish-warning">
<div class="admonition-title">
<p>The car doesn't have to move!</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/obligations_past.html#admonition-the-car-doesnt-have-to-move"></a></p>
</div>
<div>
<p>The <code>until</code> operator doesn't prevent its <em>left</em> side from being true after its right side is. E.g., <code>stopped until green_light</code> doesn't mean that the car has to move immediately (or indeed, ever) once the light is green. It just means that the light eventually turns green, and the car can't move until then.</p>
</div>
</div>
<h2 id="the-past-rarely-used-but-sometimes-useful"><a class="header" href="#the-past-rarely-used-but-sometimes-useful">The Past (Rarely Used, but Sometimes Useful)</a></h2>
<p>Forge also includes temporal operators corresponding to the <em>past</em>. This isn't standard in some LTL tools, but we include it for convenience. It turns out that past-time operators don't increase the expressive power of the language, but they do make it much easier and sometimes <em>much</em> more concise to write some constraints. Here are some examples:</p>
<h3 id="prev_state-init"><a class="header" href="#prev_state-init"><code>prev_state init</code></a></h3>
<p>This means that the <em>previous</em> state satisfied the initial-state predicate. <strong>Beware</strong>: traces are infinite in the forward direction, but <em>not</em> infinite in the backward direction. For any subformula <code>myPredicate</code>, <code>prev_state myPredicate</code> is <em>false</em> if the current state is the first state of the trace.</p>
<h3 id="past-time-always-and-eventually-historically-and-once"><a class="header" href="#past-time-always-and-eventually-historically-and-once">Past-Time <code>always</code> and <code>eventually</code>: <code>historically</code> and <code>once</code></a></h3>
<p>We can use <code>historically</code> to mean that something held in all past states and in the current one. I can write &quot;I've never been skydiving&quot; as <code>historically {not skydiving[Tim]}</code>. But if I go skydiving tomorrow, that formula won't be true tomorrow.</p>
<p>Likewise, <code>once</code> means that there was a time in the past (or currently) where something held. If I've been skydiving at all in my life, or if I'm skydiving right now, I could write <code>once {skydiving[Tim]}</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="peterson-lock-and-fairness"><a class="header" href="#peterson-lock-and-fairness">Peterson Lock and Fairness</a></h1>
<p>Let's finally <em>fix</em> <a href="chapters/temporal/../relations/sets-induction-mutex.html">the broken locking algorithm</a> <a href="chapters/temporal/../relations/sets-beyond-assertions.html">we modeled before</a>. We <a href="chapters/temporal/./liveness_and_lassos.html">decided</a> that it would be a bother to encode lasso traces manually in Relational Forge, but it seems like Temporal Forge might give us exactly what we need.</p>
<p>The final version of the model will be in <a href="chapters/temporal/./peterson.frg">peterson.frg</a>.</p>
<h2 id="fixing-deadlock"><a class="header" href="#fixing-deadlock">Fixing Deadlock</a></h2>
<p>Our little algorithm is 90% of the way to a <em>working</em> mutex called the <a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm">Peterson lock</a>.  The Peterson lock just adds one extra bit of state, and one transition to set that bit. In short, if our current algorithm is analogous to raising hands for access, the other bit added is like a &quot;no, you first&quot; when two people are trying to get through the door at the same time; that's exactly the sort of situation our both-flags-raised deadlock represented.</p>
<p><strong>TODO: add transition diagram here, and probably for lock1</strong></p>
<p>To represent which process (if any) has most recently said &quot;no, you go first&quot;, we'll add a <code>polite: lone Process</code> field to each <code>Process</code>. The algorithm now needs to take a step to set this value. It goes something like this (in pseudocode) after the process becomes interested:</p>
<pre><code>// location: uninterested 
this.flag = true
// location: halfway   (NEW)
polite = me         
// location: waiting 
while(other.flag == true || polite == me) {} // hold until their flag is lowered _or_ the other is being polite
// location: in CS 
run_critical_section_code(); // don't care details
this.flag = false
</code></pre>
<p>Because we're modeling individual operations executing, we'll need to add a new location to the state, which I'll call <code>Halfway</code>. We'll also need a new transition (and to change existing transitions in some places). The new transition might look something like this:</p>
<pre><code class="language-alloy">pred enabledNoYou[p: Process] {
    World.loc[p] = Halfway
}
pred noYou[p: Process] {
    -- GUARD
    enabledNoYou[p]
    -- ACTION
    World.loc'[p] = Waiting
    World.flags' = World.flags
    World.polite' = p
    all p2: Process - p | World.loc'[p2] = World.loc[p2]
}
</code></pre>
<p>We'll need a small edit in <code>raise</code>, to set </p>
<pre><code>World.loc'[p] = Halfway
</code></pre>
<p>instead of </p>
<pre><code>World.loc'[p] = Waiting
</code></pre>
<p>and a modification to the <code>enter</code> transition so that it's enabled if <em>either</em> nobody else has their flag raised <em>or</em> the current process isn't the one being polite anymore:</p>
<pre><code class="language-alloy">pred enabledEnter[p: Process] {
    World.loc[p] = Waiting 
    -- no other processes have their flag raised *OR* this process isn't the polite one
    (World.flags in p or World.polite != p)
}
</code></pre>
<p>Then we add the new transition to the overall transition predicate, to <code>doNothing</code>, to the deadlock check test—anywhere we previously enumerated possible transitions.</p>
<p>We also need to expand the frame conditions of all other transitions to keep <code>polite</code> constant if we aren't explicitly modifying it.</p>
<div id="admonition-watch-out" class="admonition admonish-warning">
<div class="admonition-title">
<p>Watch out!</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/fixing_lock_temporal.html#admonition-watch-out"></a></p>
</div>
<div>
<p>Beware of forgetting (or accidentally including) primes. This can lead to unsatisfiable results, since the constraints won't do what you expect between states. E.g., an accidental double-prime will mean &quot;in the state <em>after</em> next&quot;.</p>
</div>
</div>
<h3 id="lets-check-non-starvation"><a class="header" href="#lets-check-non-starvation">Let's Check Non-Starvation</a></h3>
<pre><code class="language-alloy">noStarvation: {
    lasso implies {
        all p: Process | {
            always {
                -- Beware saying &quot;p in World.flags&quot;. Why? Read on...
                p in World.flags =&gt;
                eventually World.loc[p] = InCS
            }
        }
    }
} is checked
</code></pre>
<p>This passes. Yay!</p>
<div id="admonition-should-we-be-suspicious" class="admonition admonish-tip">
<div class="admonition-title">
<p>Should we be suspicious?</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/fixing_lock_temporal.html#admonition-should-we-be-suspicious"></a></p>
</div>
<div>
<p>That was really easy. Everything seems to be working perfectly. Maybe we can stop early and go get ice cream. </p>
<p>But we should probably do some validation to make sure we haven't missed something. Here's a question: <em>is our domain model realistic enough to trust these results?</em></p>
</div>
</div>
<h2 id="abstraction-choices-we-made"><a class="header" href="#abstraction-choices-we-made">Abstraction Choices We Made</a></h2>
<p>We made a choice to model processes as always eventually <em>interested</em> in accessing the critical section. There's no option to remain uninterested, or even to terminate (as many processes do in real life). Suppose we allowed processes to become uninterested and go to sleep. How could this affect the correctness of our algorithm, or threaten our ability to verify the non-starvation property with the current model? </p>
<details>
<summary>Think, then click!</summary>
<p>The property might break because a process's flag is still raised as it is <em>leaving</em> the critical section, even if it never actually wants access again. So the implication is too strong. It is more correct to say <code>World.loc[p] = Waiting =&gt; ...</code> than <code>p in World.flags</code>, which is why we use it in the above. </p>
<p>But even the correct property will fail in this case: there's nothing that says one process can't completely dominate the overall system, locking its counterpart out. Suppose that <code>ProcessA</code> is <code>Waiting</code> and then <code>ProcessB</code> stops being interested. <em>If we modeled disinterest as a while loop</em>, perhaps using <code>doNothing</code> or a custom <code>stillDisinterested</code> transition, then <code>ProcessA</code> could follow that loop forever, leaving <code>ProcessB</code> enabled, but frozen, because our model only lets one process transition at a time.</p>
</details>
<p>Let's deal with that second problem now.</p>
<!-- In your next homework, you'll be _critiquing_ a set of properties and algorithms for managing an elevator. Channel your annoyance at the CIT elevators, here! Of course, none of our models encompass the complexity of the CIT elevators... -->
<h2 id="fairness"><a class="header" href="#fairness">Fairness</a></h2>
<p>In the real world, it's not just the process itself that says whether or not it runs forever; it's also up to the operating system's scheduler, the system's hardware, etc. Thus, non-starvation is contingent on some <strong>preconditions</strong> that the domain must provide. 
Without the scheduler being at least <em>somewhat</em> fair, even the best algorithm can guarantee very little. </p>
<p>Let's add the precondition, which we'll call &quot;fairness&quot;. Again, keep in mind that, in this context, fairness is <em>not a property our locking system must guarantee</em>. Rather, it's something our locking system needs from its environment. This is a common thing to see in verification and, for that matter, in all of computer science. To underscore this point, you might review the <a href="chapters/temporal/../bst/bst.html">binary search tree</a> invariant. Is the BST invariant a properties for the search to guarantee, or a precondition for its correctness? Of course, the status of a given property can shift depending on our perspective: if we're modeling the algorithm to <em>add</em> to the binary search tree, preserving the invariant is now very important.</p>
<div id="admonition-other-precondition-examples" class="admonition admonish-note">
<div class="admonition-title">
<p>Other precondition examples</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/fixing_lock_temporal.html#admonition-other-precondition-examples"></a></p>
</div>
<div>
<p>Is Dijkstra's algorithm always correct, on any weighted directed graph? Is RSA encryption absolutely secure, no matter how powerful or how lucky the adversary is?</p>
</div>
</div>
<h3 id="expressing-fairness"><a class="header" href="#expressing-fairness">Expressing Fairness</a></h3>
<p>There are many ways to phrasing fairness, and since we're making it an assumption about the world outside our algorithm, we'd really like to pick something that suffices for our needs, but <em>isn't any stronger than that.</em> Once we add the <code>weakFairness</code> predicate below as an assumption, the properties pass. </p>
<pre><code class="language-alloy">pred weakFairness {
    all p: Process | {
        (eventually always 
                (enabledRaise[p] or
                enabledEnter[p] or
                enabledLeave[p] or
                enabledNoYou[p])) 
        =&gt; 
        (always eventually (enter[p] or raise[p] or leave[p] or noYou[p]))        
    }
}
</code></pre>
<p>This may initially look a little strange. It still looks rather strange to me, years after learning it. It just happens that there are multiple ways to express fairness. Hillel Wayne has a <a href="https://www.hillelwayne.com/post/fairness/">great blog post</a> on the differences between them. (Unfortunately it's in a different modeling language, but the ideas come across well.) Regardless, &quot;weak&quot; fairness is sufficient for our needs! It says that if a process remains ready to move forward forever (possibly via a different transition per state), it must be allowed to proceed infinitely often.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="validation-in-a-temporal-setting"><a class="header" href="#validation-in-a-temporal-setting">Validation in a Temporal Setting</a></h1>
<p>We had previously discussed some <a href="chapters/temporal/../validation/validating_events.html">methodology for testing</a>. Now that we've started using Temporal Forge and begun modeling more robust systems, we should revisit the topic of validation. </p>
<p>We had two principles to follow before:</p>
<ul>
<li>Principle 1: Are you testing the <em>model</em>, or the <em>system</em>? </li>
<li>Principle 2: Test both Inclusion and Exclusion.</li>
</ul>
<p>Now we'll add 2 more considerations. </p>
<h2 id="principle-3-whats-the-domain-whats-the-system"><a class="header" href="#principle-3-whats-the-domain-whats-the-system">Principle 3: What's the Domain? What's the System?</a></h2>
<p>Systems don't run in isolation: there's usually an external environment that the system influences and is influenced by. Sometimes (but not always) this division is straightforward. In a model of networks, one might see:</p>
<ul>
<li>connectivity, packets, queues, etc. as the <em>domain model</em>; and </li>
<li>forwarding policies, router behavior, etc. as the <em>system</em>.</li>
</ul>
<p>When we're writing a model, it's useful to know when we're talking about the <em>system</em>, and when we're talking about the <em>domain</em> that the system is operating on. Let's look at the <a href="chapters/temporal/../temporal/fixing_lock_temporal.html">Peterson lock</a> in this light.</p>
<ul>
<li><strong>The domain has a set of behaviors it can perform.</strong> In this example, the threads represent the domain: programs running concurrently. As yet, there's no restriction on how the threads behave; the set of behaviors is enormous.</li>
<li><strong>The system restricts that set of behaviors.</strong> In this example, the Peterson lock is the system. Usually the system functions by putting limits and structure on otherwise unfettered behavior. (E.g., without a locking algorithm in place, threads would still run! They just might violate mutual exclusion.)</li>
<li>Because we usually have goals about how, exactly, the system constrains the domain, we often state <strong>requirements</strong> (i.e., properties about the system) in terms of how the domain behaves in the system's presence.</li>
<li>The domain has some state <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>, and the system has some state <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>. The domain cannot always &quot;see&quot; everything in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, and the system cannot always directly affect everything <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>. The variables on which they communicate (that is, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>) are called the <strong>interface</strong>. We'll strive to phrase our requirements for the system in terms of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>—in terms of what can be observed outside the details of the system. (Of course, our <strong>validation tests</strong> for the model itself may refer to whatever state is needed.)</li>
</ul>
<!-- When you add something to a model, it's good to have a rough sense of where it comes from. E.g., we added a `polite` field to turn our original lock into the Peterson lock. Is that state Is a piece of state visible in the domain?  of the domain, part of the system, or both? Does it represent an internal system state, which should probably not be involved in a requirement, but perhaps should be checked in model validation?

~~~admonish note title="Have we been disciplined about this so far?"
No we have not! And we may be about to encounter some problems because of that. 
~~~-->
<h2 id="principle-2-what-can-happen"><a class="header" href="#principle-2-what-can-happen">Principle 2: What Can Happen?</a></h2>
<p>Ask what behaviors might be important in the domain, but not necessarily always happen. These are sometimes referred to as <em>optional predicates</em>, because they may or may not hold. In real life, here are some optional predicates:</p>
<ul>
<li>we have class today;</li>
<li>it's raining today; </li>
<li>homework is due today; etc. </li>
</ul>
<p><strong>Exercise:</strong> What are some optional predicates about the domain in our locking algorithm model? </p>
<details>
<summary>Think, then click!</summary>
<p>We might see, but won't necessarily always see:</p>
<ul>
<li>different sequences of the threads taking steps forward;</li>
<li>threads that are both simultaneously interested;</li>
<li>threads that are uninterested; </li>
<li>etc.</li>
</ul>
<p>As the model includes more domain complexity, the set of optional predicates grows. </p>
</details>
<p>Notice that we wrote actual tests to confirm when these behaviors could (or couldn't) happen.</p>
<div id="admonition-for-next-time" class="admonition admonish-note">
<div class="admonition-title">
<p>For Next Time</p>
<p><a class="admonition-anchor-link" href="chapters/temporal/testing_temporal.html#admonition-for-next-time"></a></p>
</div>
<div>
<p>We'll consider questions of atomicity (how granular should transitions be?), and model a different variation of this lock.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="satisfiability-solving"><a class="header" href="#satisfiability-solving">Satisfiability Solving</a></h1>
<p>Suppose I asked you to solve a boolean constraint problem. Maybe it comes from Forge, and maybe it doesn't. Here's an example, in &quot;Java syntax&quot;:</p>
<pre><code>x1 and (x1 implies x2)
</code></pre>
<p>Is there a satisfying instance for this constraint? </p>
<ul>
<li>If yes, what is it, and how did you obtain it?</li>
<li>If no, how did you reach that conclusion?</li>
</ul>
<p>Here's another:</p>
<pre><code>(x1 or !x2) and (x1 or x2) and (x2 or !x1) and (!x2 or !x1)
</code></pre>
<p>Same question. Is there a satisfying instance for this constraint? </p>
<ul>
<li>If yes, what is it, and how did you obtain it?</li>
<li>If no, how did you reach that conclusion?</li>
</ul>
<h2 id="truth-tables"><a class="header" href="#truth-tables">Truth Tables</a></h2>
<p>We could build the table of all possibilities, and use it to search like so:</p>
<div class="table-wrapper"><table><thead><tr><th><code>x1</code></th><th><code>x2</code></th><th><code>(x1 implies x2)</code></th><th><code>x1 and (x1 implies x2)</code></th></tr></thead><tbody>
<tr><td>T</td><td>T</td><td>T</td><td><strong>T</strong></td></tr>
<tr><td>T</td><td>F</td><td>F</td><td>F</td></tr>
<tr><td>F</td><td>T</td><td>T</td><td>F</td></tr>
<tr><td>F</td><td>F</td><td>T</td><td>F</td></tr>
</tbody></table>
</div>
<p>We've found a solution! But we needed to build the entire set of possibilities to do so.</p>
<h2 id="can-we-do-better"><a class="header" href="#can-we-do-better">Can We Do Better?</a></h2>
<p>We <strong>don't actually know</strong> (at time of writing) whether it's possible to solve boolean satisfiability for arbitrary inputs without worst-case time exponential in the size of the input. This is one of the biggest unsolved questions, and certainly one of the most famous, in computer science. But we shouldn't let that discourage us. Plenty of problems are <em>worst</em> case exponential (or even more difficult) and we still solve them all the time.</p>
<div id="admonition-why-so-famous" class="admonition admonish-note">
<div class="admonition-title">
<p>Why so famous?</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/dpll.html#admonition-why-so-famous"></a></p>
</div>
<div>
<p>It turns out that if you can solve boolean SAT in polynomial worst-case time, you can also solve many other important problems in worst-case polynomial time. There are many such problems (e.g., graph coloring, longest simple path, bin packing, ...) but SAT is the most well-known. </p>
<p>If you take 1010, you'll learn more about the specifics.</p>
</div>
</div>
<h2 id="lets-try-anyway"><a class="header" href="#lets-try-anyway">Let's Try Anyway</a></h2>
<p>Maybe we can do better <em>sometimes</em>. Let's just start, and see where we get to. </p>
<div id="admonition-pseudocode" class="admonition admonish-warning">
<div class="admonition-title">
<p>Pseudocode</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/dpll.html#admonition-pseudocode"></a></p>
</div>
<div>
<p>The &quot;code&quot; in today's notes is <em>pseudocode</em>. The goal is to motivate the core ideas coming up, although you could certainly add a bit of extra detail to get runnable code.</p>
</div>
</div>
<h3 id="a-first-try"><a class="header" href="#a-first-try">A First Try</a></h3>
<p>Here's a solution that recursively tries all combinations. It's kind of like building the truth table, except that instead of creating the table (which always uses exponential <em>space</em>) it just explores all possibilities (always using exponential <em>time</em> but not exponential space). </p>
<pre><code class="language-python">def solve(formula: BooleanFormula) -&gt; bool:
    remaining = variables_in(formula) # get list of variables used in the formula
    if remaining.isEmpty(): 
        return simplify(formula)      # no variables left; simplify to true or false
    else:
        branch = remaining[0]                                     # guess based on first variable v
        true_result = solve(substitute(formula, branch, True))    # try v = true
        false_result = solve(substitute(formula, branch, False))  # try v = false
        return true_result || false_result                        # true if and only if _some_ guess worked
</code></pre>
<p>The function relies on three helpers, which we've left out for brevity:</p>
<ul>
<li><code>simplify</code>, which evaluates a formula with no variables. E.g., it turns <code>True and False</code> to just <code>True</code>.</li>
<li><code>substitute</code>, which replaces a variable with a concrete boolean value. E.g., calling <code>substitute(x1 and x2, x1, True)</code> would produce <code>True and x2</code>.</li>
<li><code>variables_in</code>, which returns the set of variables used in a formula.</li>
</ul>
<p>Again, this program doesn't actually build the <em>entire</em> table at any one time. It explores the entire set of possible instances, and so takes time worst-case exponential in the number of variables. But it doesn't need that much <em>space</em>, which is already an improvement. </p>
<p>However, its <em>best</em> case time is also exponential, which is rather disappointing. Surely we can do a lot better.</p>
<h3 id="maybe-luck-is-with-us"><a class="header" href="#maybe-luck-is-with-us">Maybe Luck Is With Us</a></h3>
<p>The issue with the last solution is that it <em>always</em> explores, even if it doesn't need to. Instead, how about we only check one value at a time. If we find a <code>True</code> result for one specific substitution, we're done!</p>
<pre><code class="language-python">def solve(formula: BooleanFormula) -&gt; bool:
    remaining = variables_in(formula)
    if remaining.isEmpty(): 
        return simplify(formula)
    else:
        branch = remaining[0]
        true_result = solve(substitute(formula, branch, True))
        if true_result:    # same as last version
            return True    # but allow early termination
        else: 
            false_result = solve(substitute(formula, branch, False))
            return false_result    
</code></pre>
<p>Now, suddenly, the best-case and the worst-case aren't the same. The solver could be <em>lucky</em>: consider a formula like <code>x1 and x2 and x3 and x4 and x5</code>. The above algorithm only needs 5 recursive calls to return <code>True</code>; the previous one would need <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>Of course, luck won't always be with us. Right? What's an example formula that would still need an exponential number of calls with the above code?</p>
<details>
<summary>Think, then click!</summary>
<p>How about: <code>!x1 and !x2 and !x3 and ...</code>? The first guess of <code>True</code> is always wrong for a formula like this.</p>
</details>
<h3 id="imposing-structure"><a class="header" href="#imposing-structure">Imposing Structure</a></h3>
<p>Let's look back at our first example: <code>x1 and (x1 implies x2)</code>. You may have taken advantage of some <em>structure</em> to figure out a satisfying instance for this formula. Namely, if we know that <code>x1</code> holds, then we can propagate that knowledge into <code>x1 implies x2</code> to <em>deduce</em> that <code>x2</code> must hold---without needing to guess and try a value. There's nothing like this deduction in either of our programs so far.</p>
<p>The trouble is: if we're given an arbitrary formula, it's hard to pick out that (say) <code>x1</code> is <em>definitely</em> true. But if we impose a little bit of structure on the input, it becomes easy in many cases. Let's do that now.</p>
<h2 id="conjunctive-normal-form"><a class="header" href="#conjunctive-normal-form">Conjunctive Normal Form</a></h2>
<p>First, three definitions:</p>
<p>A <em>literal</em> is a variable or its negation. E.g., <code>x1</code> and <code>!x1</code> are both literals, but <code>!!x1</code> and <code>x1 or x2</code> are not.</p>
<p>A <em>clause</em> is a set of literals combined with &quot;or&quot;; you may sometimes hear this called a <em>disjunction</em> of literals. Because we can always rewrite an &quot;or&quot; as implication (and vice versa) in classical boolean logic, a clause can be viewed as a number of different potential implications. </p>
<p>A formula is said to be in <em>conjunctive normal form</em> (CNF) if it comprises a set of clauses that are implicitly combined with &quot;and&quot;. We call it this because &quot;conjunction&quot; is just another name for &quot;and&quot;; a &quot;normal form&quot; is just a way of saying that a formula's shape follows a certain (often useful) structure.</p>
<p>If the input to our solver is in CNF, as the example formula <code>x1 and (x1 implies x2)</code> is (or rather, it would be if we'd wrote it equivalently as <code>x1 and (!x1 or x2)</code>), we can spot these opportunities to propagate knowledge quite quickly, just by searching for clauses of only one element. </p>
<p>A <em>unit clause</em> is a 1-element clause: a variable or its negation.</p>
<p>The <em>empty clause</em> is a 0-element clause, and is equivalent to <code>False</code>. Why is the empty clause equivalent to <code>False</code>?</p>
<details>
<summary>Think, then click!</summary>
<p>A clause is a big &quot;or&quot;, and an &quot;or&quot; gives a set of ways the formula could evaluate to <code>True</code>. But an empty clause gives <em>no</em> such options!</p>
</details>
</br>
<p><strong>From now on, we'll assume that we always have input in CNF.</strong> There's a trick to accomplish this, so let's keep focused on the solving, not on the conversion for now. </p>
<h3 id="a-powerful-idea-unit-propagation"><a class="header" href="#a-powerful-idea-unit-propagation">A Powerful Idea: Unit Propagation</a></h3>
<p>If our input was <code>x1 and (!x1 or x2)</code>, and we'd stored it as a set, that would be <code>{x1, (!x1 or x2)}</code>. We can check for unit clauses in time linear in the number of clauses. And if there is a unit clause, we can see whether there are opportunities to propagate that knowledge. This idea is called <em>unit propagation</em>.</p>
<p>But how does that actually <em>work</em>? Suppose we've identified a unit clause, in this case <code>x1</code>. Then, for every other clause <code>C</code> in the set, we can check whether:</p>
<ul>
<li>the clause <code>C</code> contains the same literal as the unit clause; </li>
<li>the clause contains the opposite literal as in the unit clause; or </li>
<li>neither of the above.</li>
</ul>
<p>In the third case, we probably can't do any propagation, because there's no connection between the clauses. But what do you think we can do in either of the first two cases?</p>
<details>
<summary>Think, then click!</summary>
<ul>
<li>Does the clause <code>C</code> contain the same literal as the unit clause?
<ul>
<li>If so, then <code>C</code> is <em>subsumed</em> by the unit clause: <code>C</code> must be satisfied given <code>x1</code> holds! Delete the entire clause <code>C</code>.</li>
</ul>
</li>
<li>Does the clause contain the opposite literal as in the unit clause?
<ul>
<li>If so, then the clause <code>C</code> cannot possibly be made true by that opposite literal. Delete that literal from <code>C</code>.</li>
</ul>
</li>
</ul>
</details>
</br>
<p><strong>Exercise</strong>: Here's a CNF formula. Solve it using unit propagation. </p>
<p><code>x1 and (x1 or x2 or x3) and (!x3 or x2 or !x4) and (!x2 or !x1) and x3</code></p>
<details>
<summary>Think, then click!</summary>
<p>First, we notice 2 unit clauses: <code>x1</code> and <code>x3</code>. Then:</p>
<ul>
<li>Propagate <code>x1</code>, which lets us remove a clause entirely, and simplify another: <code>x1 and (!x3 or x2 or !x4) and !x2 and x3</code>. But now we have a new unit clause, as a result of simplifying! </li>
<li>Propagating <code>x3</code> gives us: <code>x1 and (x2 or !x4) and !x2 and x3</code>. </li>
<li>Propagating <code>!x2</code> gives us <code>x1 and !x4 and !x2 and x3</code>. </li>
</ul>
<p>This is starting to look suspiciously like a boolean instance. <em>The unit clauses are assignments to boolean variables, and part of this process deduces new ones.</em></p>
</details>
</br>
<p><strong>Exercise</strong>: Here's a CNF formula. Solve it using unit propagation. </p>
<p><code>x1 and (x1 or x2 or x3) and (!x3 or x2 or !x4)</code></p>
<p>Notice this formula is a strict subset of the earlier one. Because the earlier one is satisfiable, so is this one! But does unit propagation alone suffice to discover the satisfiability?</p>
<details>
<summary>Think, then click!</summary>
<p>No. Unit propagating <code>x1</code> will produce <code>x1 and (!x3 or x2 or !x4)</code>, but we need some other way---besides <em>just</em> unit propagation---of breaking down the larger clause that remains.</p>
</details>
</br>
<p>Fortunately, if we mix unit propagation with our prior &quot;guessing&quot; algorithm, we make significant progress.</p>
<h3 id="adding-unit-propagation"><a class="header" href="#adding-unit-propagation">Adding Unit Propagation</a></h3>
<pre><code class="language-python">def solve(formula: Set[Clause]) -&gt; bool:
    
    # are there any unit clauses? if so, propagate them
    # keep doing so until there are no more changes
    # Beware: mutation can be a source of bugs here...
    old_formula, formula = propagate_unit_clauses(formula)
    while formula &lt;&gt; old_formula:
        old_formula, formula = propagate_unit_clauses(formula)
    
    # Did we produce the empty clause? (We might represent the e.c. as {} or [] etc.)
    if EmptyClause in formula:
        return False
    # Do we otherwise have only unit clauses remaining? (What could go wrong in this check?) 
    elif formula == units_in(formula):    
        return True
    else:
        branch = remaining[0]
        # no longer substitute; instead, _add_ a unit clause to represent the &quot;True&quot; guess
        true_result = solve(formula + {branch})
        if true_result: 
            return True
        else: 
            # no longer substitute; instead, _add_ a unit clause to represent the &quot;False&quot; guess
            false_result = solve(formula + {!branch})
            return false_result    
</code></pre>
<p>Again, the amount of information we get from unit propagation is subject to luck (or, rather, the dependencies between variables and clauses in the formula we're given). </p>
<div id="admonition-think-why-did-we-stop-substituting" class="admonition admonish-note">
<div class="admonition-title">
<p>Think: Why did we stop substituting?</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/dpll.html#admonition-think-why-did-we-stop-substituting"></a></p>
</div>
<div>
<p>In prior versions, we substituted <code>True</code> or <code>False</code> into the formula. Now, we're adding a unit clause to represent the guess instead. Why did we make this change? One reason is that it's easier to explicitly represent the flow of this algorithm via the addition of unit clauses, since half of it is about unit propagation. More reasons may appear as we continue.</p>
</div>
</div>
<p>This idea---a recursive, backtracking search paired with unit propagation---is the foundation of one of the most famous boolean solver algorithms: <strong>DPLL</strong> (named after the authors: Davis, Putnam, Logemann, and Loveland). DPLL still forms the core of how most modern SAT-solvers work (although there are more ideas and optimizations not yet incorporated, such as learning from failure and deciding which variable to branch on).</p>
<div id="admonition-pure-literal-elimination" class="admonition admonish-note">
<div class="admonition-title">
<p>Pure-literal elimination</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/dpll.html#admonition-pure-literal-elimination"></a></p>
</div>
<div>
<p>DPLL technically has one more feature: pure-literal elimination. I'm glossing over that here. It's technically interesting, but not central to where we are right now. The idea is: if a variable appears in only one &quot;polarity&quot; (that is, only positive or negative throughout all clauses) then if the clause set is satisfiable at all, it must be satisfiable by some instance that agrees with the polarity of that variable. So if we just want to find <em>a</em> satisfying instance, why not just set that variable's value right away?</p>
</div>
</div>
<h3 id="returning-more-than-a-boolean"><a class="header" href="#returning-more-than-a-boolean">Returning more than a boolean</a></h3>
<p>Returning just a boolean seems bad for the caller. After all, if Forge were using this solver, it would want the instance itself, not just that the instance exists. But there's another problem with returning a boolean: something related to testing. What is it?</p>
<details>
<summary>Think, then click!</summary>
<p>If we wanted to do property-based testing on the solver, returning <code>True</code> would force the testing predicate to <em>solve the problem again</em>. But if we returned an instance, the predicate would be much easier: just evaluate the formula in the instance, and see if it indeed satisfies the formula.</p>
</details>
</br>
<p>But how should we go about returning an instance, rather than <code>True</code>? To find out, let's actually look at the tree of recursive calls, and see what information we have, or could recover. Let's solve:</p>
<p><code>(!x1 or !x2) and (!x1 or !x3) and (x2 or x3)</code></p>
<p><img src="https://i.imgur.com/odianeQ.jpg" alt="" /></p>
<p>In that bottom left call, how do we conclude &quot;conflict?&quot; In the other bottom call, how do we conclude &quot;success&quot;?</p>
<details>
<summary>Think, then click!</summary>
<p>Because there's one more unit-propagation step in each case that I haven't drawn! Unit propagating <code>x3</code> when <code>!x3</code> is present will produce the empty clause: <code>False</code>. And similarly in the other case: unit propagating <code>x2</code> will eliminate the entire <code>x2 or x3</code> clause.</p>
</details>
</br>
<p>Notice that every time we make a recursive call, there's an implicit set of <em>assumptions</em> involved. That is, there's always a <em>partial instance</em> of previously-selected guesses in effect at any point. We can make this explicit by adding a parameter to the function, and returning the guesses that produce a success:</p>
<pre><code class="language-python"># Note new input and output types
def solve(formula: Set[Clause], assumptions: Set[Literal]) -&gt; Set[Literal]:    
    old_formula, formula = propagate_unit_clauses(formula)
    while formula &lt;&gt; old_formula:
        old_formula, formula = propagate_unit_clauses(formula)
        
    remaining = variables_in(formula)
    if remaining.isEmpty():
        if simplify(formula): 
            return assumptions
        else: 
            return False        
    else:
        branch = remaining[0]
        true_result = solve(formula + {branch}, assumptions + {branch : true})
        if true_result &lt;&gt; False: 
            return assumptions
        else: 
            false_result = solve(formula + {!branch}, assumptions + {branch : False})
            return false_result    
</code></pre>
<div id="admonition-hold-on" class="admonition admonish-warning">
<div class="admonition-title">
<p>Hold on...</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/dpll.html#admonition-hold-on"></a></p>
</div>
<div>
<p>Does this actually work? Let's think about testing. We can use PBT to test our solver! What do we need?</p>
<ul>
<li>A <em>generator</em> for clause sets;</li>
<li>A <em>predicate</em> that tests whether an instance satisfies a clause set.</li>
</ul>
<p>If we try this out, we may find a potential issue. Here's an example we might be concerned about (but notice how many contingencies are involved in generating it!):</p>
<pre><code>(x1 or x2)
(!x1 or x3) 
</code></pre>
<p>If our solver uses lexical order to decide what to branch on first, it's going to pick <code>x1</code> before the others. And if it tries <code>True</code> first, we'll end up unit-propagating to:</p>
<pre><code>x1 
x3 
</code></pre>
<p>because the first original clause is subsumed by <code>x1</code>, and the second can be unit-propagated into. Yet, if we only return the assumptions, rather than <em>all</em> derived unit clauses, we'll return <code>{x1: True}</code>, not <code>{x1: True, x3: True}</code>. Beware!</p>
</div>
</div>
<h3 id="total-or-partial-instances"><a class="header" href="#total-or-partial-instances">Total or Partial Instances?</a></h3>
<p>So far, our algorithm will avoid making assumptions if it doesn't need to. This is good from a performance perspective but bad if the caller expects a <em>total</em> instance that maps every variable to a boolean. But unit propagation can <em>delete</em> clauses, resulting in variables just disappearing from the problem. E.g., solving <code>x1 and (x1 or x5)</code>.</p>
<p>If our goal is to produce a <em>total</em> solver (and it usually is---Forge, for example, needs values for every possible tuple in every relation, even if they aren't constrained at all), we'll need to post-process the result and pick arbitrary values for variables that have no value in the assumption set. Traditionally, we'll make this easier on ourselves by passing a 3rd argument to the solver: the number of variables.</p>
<h2 id="heuristics-which-variables-which-values"><a class="header" href="#heuristics-which-variables-which-values">Heuristics: Which Variables? Which Values?</a></h2>
<p>There are a bunch of heuristics for picking variables to branch on, picking boolean values, etc. that are beyond the scope of this class. There is also a second brilliant idea that powers model solvers: <em>learning</em> from failure. In these solvers, reaching a conflict results in learning a &quot;conflict clause&quot; which is added to know the knowledge base, and the solver leverages this to backtrack further than one level of recursion if it's able.</p>
<p>If you're curious about how solvers are built, check out <a href="http://cs.brown.edu/courses/csci2951-o/">CSCI 2951-O</a>. </p>
<h2 id="converting-to-cnf"><a class="header" href="#converting-to-cnf">Converting to CNF</a></h2>
<p>How should we convert an arbitrary boolean formula to CNF? </p>
<h3 id="naive-approach-distributivity"><a class="header" href="#naive-approach-distributivity">Naive Approach: Distributivity</a></h3>
<p>We could start by using the distributive law: <code>x1 and (x2 or x3)</code> is equivalent to <code>(x1 or x2) and (x1 or x3)</code>.</p>
<p>So if we have:</p>
<p><code>(x1 and x2) or (x3 and x4)</code></p>
<p>We could convert it to CNF by applying the distributive law twice to get:</p>
<p><code>(x1 or x3) and (x1 or x4) and (x2 or x3) and (x2 and x4)</code></p>
<p>There's a fundamental problem here, though. What do you see?</p>
<details>
<summary>Think, then click!</summary>
<p>This process will increase formula size <em>exponentially</em> in the worst case. That's unacceptable. (Consider what happens if we keep adding terms to the above shape: making the inner <code>and</code> formulas bigger and adding more of them.)</p>
<p>This is again pretty disappointing: if there <em>is no</em> equivalent CNF available for some formulas that isn't exponentially bigger, how can we practically use the algorithm we just invented?</p>
</details>
<h3 id="the-tseitin-transformation"><a class="header" href="#the-tseitin-transformation">The Tseitin Transformation</a></h3>
<p>There's something else we could do. If we can't find an <em>equivalent</em> CNF, maybe we could make a trade-off. To help us on the way, here are a couple of definitions:</p>
<p>Two formulas A and B over some set of boolean variables V are said to be <em>logically equivalent</em> if they are satisfied by the exact same instances.</p>
<p>Two formulas A and B are said to be <em>equisatisfiable</em> when A is satisfiable if and only if B is satisfiable. Note that equisatisfiability doesn't require A and B to use the same variable sets; the instances can be over different variables. </p>
<div id="admonition-the-idea" class="admonition admonish-tip">
<div class="admonition-title">
<p>The Idea</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/dpll.html#admonition-the-idea"></a></p>
</div>
<div>
<p>Of course, mere equisatisfiability doesn't immediately guarantee any structural connection between the two formulas. For this to work, we need to be able to map a solution to problem <code>B</code> back to the original problem <code>A</code>. So maybe there's a way we could productively <em>add variables</em> to the original, retaining the meaning of the original variables, and still somehow avoid the exponential blowup in CNF conversion?</p>
</div>
</div>
<p>Let's look at that formula again: <code>(x1 and x2) or (x3 and x4)</code>. View it as a boolean circuit. </p>
<p><img src="https://i.imgur.com/fDHDyEe.png" alt="" /></p>
<p>What if we assigned a new variable for every internal node of the tree? We'd have <code>a1</code> and <code>a2</code> for the <code>and</code> nodes, and <code>o1</code> for the <code>or</code> node. The formula is true if and only if the <code>or</code> node is, so we'd have a unit clause: <code>o1</code> in the new formula. </p>
<p>But what makes <code>o1</code> true? Here's a definition in 3 constraints:</p>
<ul>
<li><code>a1 implies o1</code>,</li>
<li><code>a2 implies o1</code>, and</li>
<li><code>o1 implies (a1 or a2)</code>.</li>
</ul>
<p>We can rewrite these in CNF:</p>
<ul>
<li><code>!a1 or o1</code>,</li>
<li><code>!a2 or o1</code>, and</li>
<li><code>!o1 or a1 or a2</code>.</li>
</ul>
<p>The <code>and</code> nodes have similar definitions:</p>
<ul>
<li><code>(x1 and x2) implies a1</code></li>
<li><code>a1 implies (x1 and x2)</code></li>
<li><code>(x3 and x4) implies a2</code></li>
<li><code>a2 implies (x3 and x4)</code>
which can be rewritten:</li>
<li><code>!x1 or !x2 or a1</code></li>
<li><code>!a1 or x1</code></li>
<li><code>!a1 or x2</code></li>
<li><code>!x3 or !x4 or a2</code></li>
<li><code>!a2 or x3</code></li>
<li><code>!a2 or x4</code></li>
</ul>
<p>Together, these constraints are <em>equisatisfiable</em> with the original formula. </p>
<p>Moreover, they're something more than equisatisfiable. Just like we wanted, there's a useful relationship between the original variables and the new variables. We can always read off the values of <code>x1</code>, <code>x2</code>, <code>x3</code>, and <code>x4</code> in a solution to the new constraints and get a solution to the original constraints. The values of the newly added variables express values for the intermediate nodes of the boolean circuit.</p>
<p>And that's how Forge's translation layer works.</p>
<h2 id="example-of-a-real-solver"><a class="header" href="#example-of-a-real-solver">Example of a &quot;real&quot; solver</a></h2>
<p>You can see example code solving the N-queens problem via SAT <a href="chapters/solvers/./sat_demo/nqueens-glucose.py">here</a>. I'm using the <a href="https://github.com/audemard/glucose/releases/tag/4.2.1">parallel Glucose solver</a>, but you can plug in any solver you want; this Python script just builds a <a href="https://www21.in.tum.de/~lammich/2015_SS_Seminar_SAT/resources/dimacs-cnf.pdf">DIMACS standard</a> CNF file.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="resolution-proofs"><a class="header" href="#resolution-proofs">Resolution Proofs</a></h1>
<h2 id="context-proofs-vs-instances"><a class="header" href="#context-proofs-vs-instances">Context: Proofs vs. Instances</a></h2>
<p>Almost all of our work in this book so far has focused on <em>satisfiability</em>. We've put instances first: the things that either satisfy or dissatisfy a set of constraints. </p>
<p>But there's a second perspective, one that focuses on necessity, deduction, and contradiction—on justifying unsatisfiability with <em>proof</em>. This chapter is about exploring proofs in a way that's immediately applicable to what we already know. We'll cover a form of proof called <em>resolution</em>, and show how a basic version of a modern SAT solver can return a <em>proof</em> of unsatisfiability. This proof can then be processed to understand <em>why</em> a set of constraints is unsatisfiable. </p>
<p>We'll start simple, from CNF and unit propagation, and move on from there.</p>
<h2 id="a-chain-rule-for-cnf"><a class="header" href="#a-chain-rule-for-cnf">A Chain Rule For CNF</a></h2>
<p>Suppose I know two things:</p>
<ul>
<li>it's raining today; and</li>
<li>if it's raining today, we can't hold class outside.</li>
</ul>
<p>I might write this more mathematically as the set of known facts: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal">c</span><span class="mclose">}</span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> means &quot;rain&quot; and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> means &quot;class outside&quot;. </p>
<div id="admonition-symbols" class="admonition admonish-note">
<div class="admonition-title">
<p>Symbols</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/resolution.html#admonition-symbols"></a></p>
</div>
<div>
<p>Because the vast majority of the materials you might find on this topic are written using mathematical notation, I'm using <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span></span></span></span> for <code>implies</code> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span></span></span></span> for <code>not</code>. If you go reading elsewhere, you might also see <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span> for <code>and</code> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> for <code>or</code>.</p>
</div>
</div>
<p>Given this knowledge base, can we infer anything new? Yes! We know that if it's raining, we can't hold class outside. But we know it's raining, and therefore we can conclude that class needs to be indoors. This intuition is embodied formally as a logical <em>rule of inference</em> called <em>modus ponens</em>:</p>
<center>
<p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2694em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">A</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mrel mtight">⟹</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</p>                
</center>
<p>The horizontal bar in this notation divides the inputs to the rule from the outputs. For <em>any</em> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, if we know <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, and we know <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, we can use modus ponens to deduce <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</p>
<div id="admonition-does-this-remind-you-of-something" class="admonition admonish-tip">
<div class="admonition-title">
<p>Does this remind you of something?</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/resolution.html#admonition-does-this-remind-you-of-something"></a></p>
</div>
<div>
<p>Modus ponens is very closely related to unit propagation. Indeed, that connection is what we're going to leverage to get our solvers to output proofs.</p>
</div>
</div>
<p>I like to think of rules of inference as little enzymes that operate on formula syntax. Modus ponens recognizes a specific pattern of syntax in our knowledge base and <em>rewrites</em> that pattern into something new. We can check rules like this for validity using a truth table:</p>
<div class="table-wrapper"><table><thead><tr><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>In any world where both <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> are true, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> must be true.</p>
<div id="admonition-remember-that-implies-and-or-are-related" class="admonition admonish-warning">
<div class="admonition-title">
<p>Remember that <code>implies</code> and <code>or</code> are related!</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/resolution.html#admonition-remember-that-implies-and-or-are-related"></a></p>
</div>
<div>
<p>In classical logic (our setting for most of 1710), <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is equivalent to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">¬</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. Either <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is false (and thus no obligation is incurred), <em>or</em> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is true (satisfying the obligation whether or not it exists).</p>
</div>
</div>
<h3 id="beyond-modus-ponens"><a class="header" href="#beyond-modus-ponens">Beyond Modus Ponens</a></h3>
<p>Suppose we don't have something as straightforward as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal">c</span><span class="mclose">}</span></span></span></span> to work with. Maybe we only have:</p>
<ul>
<li>if it's raining today, we can't hold class outside; and</li>
<li>if Tim is carrying an umbrella, then it's raining today.</li>
</ul>
<p>That is, we have a pair of implications: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7194em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal">c</span><span class="mclose">}</span></span></span></span>. We cannot conclude that it's raining from this knowledge base, but we can still conclude something: that <em>if</em> Tim is carrying an umbrella, <em>then</em> we can't hold class outside. We've learned something new, but it remains contingent: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span><span class="mord mathnormal">c</span></span></span></span>.</p>
<p>This generalization of modus ponens lets us chain together implications to generate new ones:</p>
<center>
<p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2862em;vertical-align:-0.3618em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9244em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mrel mtight">⟹</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mrel mtight">⟹</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mrel mtight">⟹</span><span class="mspace mtight" style="margin-right:0.3253em;"></span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3618em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</p>                
</center>
<p>Like before, we can check it with a truth table. This time, there are 8 rows because there are 3 inputs to the rule:</p>
<div class="table-wrapper"><table><thead><tr><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></th><th><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p><strong>Note:</strong> This rule works no matter what form <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> take, but for our purposes we'll think of them as literals (i.e., variables or their negation).</p>
<h2 id="propositional-resolution"><a class="header" href="#propositional-resolution">Propositional Resolution</a></h2>
<p>The <em>resolution rule</em> is a further generalization of what we just discovered. Here's the idea: because we can view an &quot;or&quot; as an implication, we should be able to apply this idea of chaining implications to <em>clauses</em>.</p>
<p>First, let's agree on how to phrase clauses of more than 2 elements as implications. Suppose we have a clause <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. Recall that:</p>
<ul>
<li>a clause is a big &quot;or&quot; of literals;</li>
<li>a literal is either a variable or its negation; and </li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> is just another way of writing &quot;or&quot;.</li>
</ul>
<p>We might write <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> as an implication in a number of ways, e.g.:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>So if we have a large clause, there may be more ways of phrasing it as an implication than we'd want to write down. Instead, let's make this new rule something that works on clauses directly. </p>
<p>How would we recognize that two clauses can be combined like the above? Well, if we see something like these two clauses: </p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>; and </li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
then, if we wanted to, we could rewrite them as:</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>; and </li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
and then apply the rule above to get:</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.
We could then rewrite the implication back into a clause:</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
</ul>
<p>Notice what just happened. The two opposite literals have cancelled out, leaving us with a new clause containing <em>everything else</em> that was in the two original clauses.</p>
<center>
<p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mbin mtight">∨</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mbin mtight">∨</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mtight">¬</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">∨</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</p>                
</center>
<p>This is called the <em>binary propositional resolution rule</em>. It generalizes to something like this (where I've labeled literals in the two clauses with a superscript to tell them apart):</p>
<center>
<p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7258em;vertical-align:-0.5916em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1341em;"><span style="top:-2.6264em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em;"><span style="top:-2.1885em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em;"><span style="top:-2.1885em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight">...</span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight">...</span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mtight">¬</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mbin mtight">∨</span><span class="mord mtight">...</span><span class="mbin mtight">∨</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.214em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5916em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</p>                
</center>
<h3 id="resolution-proofs-1"><a class="header" href="#resolution-proofs-1">Resolution Proofs</a></h3>
<p>What is a proof? For our purposes today, it's a tree where:</p>
<ul>
<li>each leaf is a clause in some input CNF; and </li>
<li>each internal node is an application of the resolution rule to two other nodes.</li>
</ul>
<p>Here's an example resolution proof that shows the combination of a specific 4 clauses is contradictory:</p>
<p><img src="https://i.imgur.com/fEBkPm7.png" alt="" /></p>
<div id="admonition-proof-trees-are-data" class="admonition admonish-tip">
<div class="admonition-title">
<p>Proof trees are data!</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/resolution.html#admonition-proof-trees-are-data"></a></p>
</div>
<div>
<p>This tree is not a paragraph of text, and it isn't even a picture written on a sheet of paper. It is a <em>data structure</em>, a computational object, which we can process and manipulate in a program.</p>
</div>
</div>
<h3 id="soundness-and-completeness"><a class="header" href="#soundness-and-completeness">Soundness and Completeness</a></h3>
<p>Resolution is a <em>sound</em> proof system. Any correct resolution proof tree shows that its root follows unavoidably from its leaves.</p>
<p>Resolution is also <em>refutation complete</em>. For any unsatisfiable CNF, there exists a resolution proof tree whose leaves are taken from that CNF and whose root is the empty clause. </p>
<p>Resolution is <strong>not</strong> complete in general; it can't be used to derive <em>every</em> consequence of the input. There may be other consequences of the input CNF that resolution can't produce. For a trivial example of this, notice that we cannot use resolution to produce a tautology like <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> from an empty input, even though a tautology is always true.</p>
<h3 id="getting-some-practice"><a class="header" href="#getting-some-practice">Getting Some Practice</a></h3>
<p>Here's a CNF:</p>
<pre><code>(-1, 2, 3)
(1)
(-2, 4)
(-3, 5)
(-4, -2)
(-5, -3)
</code></pre>
<p>Can you prove that there's a contradiction here?</p>
<details>
<summary>Prove, then click!</summary>
<p>Let's just start applying the rule and generating everything we can...</p>
<p><img src="https://i.imgur.com/o9sNUzk.png" alt="" /></p>
<p>Wow, this is a lot of work! Notice two things:</p>
<ul>
<li>we're going to end up with the same kind of 4-clause contradiction pattern as in the prior example; </li>
<li>it would be nice to have a way to guide generation of the proof, rather than just generating <em>every clause we can</em>. An early form of DPLL did just that, but the full algorithm added the branching and backtracking. So, maybe there's a way to use the structure of DPLL to guide proof generation...</li>
</ul>
</details>
<br/>
<p>Notice that one of the resolution steps you used was, effectively, a unit propagation step. This should help motivate the idea that unit propagation (into a clause were the unit is negated) is a special case of resolution:</p>
<center>
<p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">...</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mtight">¬</span><span class="mord mathnormal mtight">A</span><span class="mbin mtight">∨</span><span class="mord mtight">...</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</p>                
</center>
<p>You might wonder: what about the other aspect of unit propagation---the removal of clauses entirely when they're subsumed by others? </p>
<details>
<summary>Think, then click!</summary>
<p>This is a fair question! Resolution doesn't account for subsumption because a proof is free to disregard clauses it doesn't need to use. So, while subsumption will be used in any practical solver, it's an <em>optimization</em>, not a critical component for guaranteeing refutation-completeness.</p>
</details>
<div id="admonition-one-variable-at-a-time" class="admonition admonish-warning">
<div class="admonition-title">
<p>One variable at a time!</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/resolution.html#admonition-one-variable-at-a-time"></a></p>
</div>
<div>
<p>Don't try to &quot;run resolution on multiple variables at once&quot;. To see why not, try resolving the following two clauses:</p>
<pre><code>(1, 2, 3)
(-1, -2, 4)
</code></pre>
<p>It might initially appear that these are a good candidate for resolution. However, notice what happens if we try to resolve on both <code>1</code> and <code>2</code> at the same time. We would get:</p>
<pre><code>(3, 4)
</code></pre>
<p>which is <em>not</em> a consequence of the input! In fact, we've mis-applied the resolution rule. The rule says that if we have <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> and we have <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> we can deduce <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>. These letters can correspond to any formula---but they have to match! If we pick (say) <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> for <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, then we need a clause that contains <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">¬</span><span class="mord mathnormal">A</span></span></span></span>, which is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, which is equivalent to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬2</span><span class="mclose">)</span></span></span></span>. That's not possible to see in clause; a clause has to be a big &quot;or&quot; of literals only. So we simply cannot run resolution in this way. </p>
<p>Following the rule correctly, if we only resolve on one variable, we'd get something like this:</p>
<pre><code>(2, -2, 3, 4)
</code></pre>
<p>which is always true, and thus usless in our proof, but at least not unsound. So remember:</p>
<ul>
<li>always resolve on <em>one variable at a time</em>; and</li>
<li>if resolution produces a result that's tautologous, you can just ignore it.</li>
</ul>
</div>
</div>
<h2 id="learning-from-conflicts"><a class="header" href="#learning-from-conflicts">Learning From Conflicts</a></h2>
<p>Let's return to that CNF from before:</p>
<pre><code>(-1, 2, 3)
(1)
(-2, 4)
(-3, 5)
(-4, -2)
(-5, -3)
</code></pre>
<p>Instead of trying to build a <em>proof</em>, let's look at what a DPLL implementation might do when given this input.</p>
<div id="admonition-do-you-have-a-dpll-implementation" class="admonition admonish-tip">
<div class="admonition-title">
<p>Do you have a DPLL implementation?</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/resolution.html#admonition-do-you-have-a-dpll-implementation"></a></p>
</div>
<div>
<p>Depending on the context in which you're reading this book, you may be working on an assignment that implements DPLL. If that's the case, you should follow along in your own code as we proceed with this example. Your own implementation may be slightly different, of course.</p>
</div>
</div>
<ul>
<li>Called on: <code>[(-1, 2, 3), (1), (-2, 4), (-3, 5), (-4, -2), (-5, -3)]</code></li>
<li>Unit-propagate <code>(1)</code> into <code>(-1, 2, 3)</code> to get <code>(2, 3)</code></li>
<li>There's no more unit-propagation to do, so we need to branch. We know the value of <code>1</code>, so let's branch on <code>2</code> and try <code>True</code> first.</li>
<li>Called on: <code>[(2), (2, 3), (1), (-2, 4), (-3, 5), (-4, -2), (-5, -3)]</code></li>
<li>Unit-propagate <code>(2)</code> into <code>(-2, 4)</code> to get <code>(4)</code>.</li>
<li>Remove <code>(2, 3)</code>, as it is subsumed by <code>(2)</code>.</li>
<li>Unit-propagate <code>(4)</code> into <code>(-4, -2)</code> to get <code>(-2)</code>.</li>
<li>Remove <code>(-2, 4)</code>, as it is subsumed by <code>(4)</code>.</li>
<li>Unit-propagate <code>(-2)</code> into <code>(2)</code> to get the empty clause. </li>
</ul>
<p>Upon deriving the empty clause, we've found a contradiction. <em>Some part</em> of the assumptions we've made so far (here, only that <code>2</code> is <code>True</code>) contradicts the input CNF.</p>
<p>Because the assumptions we made to reach a contradiction are not a productive path, we could learn a new clause that applies <code>or</code> to the negation of each assumption made: one of those variables must be set differently in order to find a satisfying instance. </p>
<p>But there might be many assumptions in general, so it would be good to do some sort of fast blame analysis: learning a new clause with 5 literals is a lot better than learning a new clause with 20 literals!</p>
<p>Here's the idea, in two steps: </p>
<ul>
<li>We're going to record the unit-propagation steps the solver makes, and use those to derive a resolution proof that the input CNF <em>plus some of the current assumptions</em> lead to the empty clause. </li>
<li>We'll then reduce that proof into a &quot;conflict clause&quot;. This is one of the key ideas behind a modern improvement to DPLL: CDCL, or Conflict Driven Clause Learning. We won't talk about all the tricks that CDCL uses here, nor will you have to implement them. If you're curious for more, consider shopping CSCI 2951-O. For now, it suffices to be aware that <strong>reasoning about <em>why</em> a conflict has been reached can be useful for improving performance, too.</strong></li>
</ul>
<p>In the above case, what did we actually use to derive the empty clause? Let's work <em>backwards</em>. We'll try to produce a linear proof where the leaves are input clauses or assumptions, and the internal nodes are unit-propagation steps (remember that these are just a restricted kind of resolution). We ended with:</p>
<ul>
<li>Unit-propagate <code>(-2)</code> into <code>(2)</code> to get the empty clause. </li>
</ul>
<p>The <code>(2)</code> was an assumption. The <code>(-2)</code> was derived:</p>
<ul>
<li>Unit-propagate <code>(4)</code> into <code>(-4, -2)</code> to get <code>(-2)</code>.</li>
</ul>
<p>The <code>(-4, -2)</code> was an input clause. The <code>(4)</code> was derived:</p>
<ul>
<li>Unit-propagate <code>(2)</code> into <code>(-2, 4)</code> to get <code>(4)</code>.</li>
</ul>
<p>The <code>(-2, 4)</code> was an input clause. The <code>(2)</code> was an assumption.</p>
<p>Now we're done; we have a proof:</p>
<p><img src="https://i.imgur.com/H6iqwAf.png" alt="" /></p>
<p>Using only those two input clauses, we know that assuming <code>(2)</code> won't be productive, and (because we have a proof) we can explain why. And, crucially, because the proof is a data structure, we can manipulate it if we need to.</p>
<h2 id="explaining-unsatisfiable-results"><a class="header" href="#explaining-unsatisfiable-results">Explaining Unsatisfiable Results</a></h2>
<p>This is promising: we have a <em>piece</em> of the overall proof of unsatisfiability that we want. But we can't use it alone as a proof that the <em>input</em> is unsatisfiable: the proof currently has an assumption <code>(2)</code> in it. We'd like to convert this proof into one that derives <code>(-2)</code>---the negation of the assumption responsible---from <em>just</em> the input. </p>
<p>Let's rewrite the proof we generated before. We'll <em>remove</em> assumptions from the tree and recompute the result of every resolution step, resulting in a proof of something weaker that isn't contingent on any assumptions. To do this, we'll recursively walk the tree, treating inputs as the base case and resolution steps as the recursive case. In the end, we should get something like this:</p>
<p><img src="https://i.imgur.com/oAjYL8V.png" alt="" /></p>
<p>Notice that we need to re-run resolution <em>after processing each node's children</em> to produce the new result for that node. This suggests some of the structure we'll need:</p>
<ul>
<li>If one child is an assiumption, then &quot;promote&quot; the other child and use that value, without re-running resolution. (<strong>Think: Why is this safe to this? It has to do with the way DPLL makes guesses.</strong>) </li>
<li>Otherwise, recur on children first, then re-run resolution on the new child nodes, then return a new node with the new value. </li>
</ul>
<h3 id="combining-sub-proofs"><a class="header" href="#combining-sub-proofs">Combining sub-proofs</a></h3>
<p>Suppose you ran DPLL on the false branch (assuming <code>(-2)</code>) next. Since the overall input is unsatisfiable, you'd get back a proof of <code>(2)</code> from the inputs. And, given a proof tree for <code>(-2)</code> and a proof tree for <code>(2)</code>, how could you combine them to show that the overall CNF is unsatisfiable? </p>
<details>
<summary>Think, then click!</summary>
<p>Just combine them with a resolution step! If you have a tree rooted in <code>(2)</code> and another tree rooted in <code>(-2)</code>, you'd produce a new resolution step node with those trees as its children, deriving the empty clause.</p>
</details>
<h3 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h3>
<p>This should illustrate <strong>the power of being able to treat proofs as just another data structure</strong>. Resolution proofs are just trees. Because they are trees, we can manipulate them programatically. We just transformed a proof of the empty clause via assumptions into a proof of something else, without assumptions.</p>
<h2 id="property-based-testing-the-unsatisfiable-case"><a class="header" href="#property-based-testing-the-unsatisfiable-case">Property-Based Testing (the unsatisfiable case)</a></h2>
<p>Given one of these resolution proofs of unsatisfiability for an input CNF, you can now apply PBT to your solver's <code>False</code> results, because they are no longer <em>just</em> <code>False</code>.</p>
<p>What properties would you want to hold? </p>
<details>
<summary>Think, then click!</summary>
<p>For the tree to prove that the input is unsatisfiable, you'd need to check:</p>
<ul>
<li>the internal nodes of the tree are valid resolution steps;</li>
<li>the leaves of the tree are taken only from the input clauses; and</li>
<li>the root of the tree is the empty clause.</li>
</ul>
</details>
<!-- ## Pre-Registration!

Pre-registration is upon us soon! Some related courses include the following. I'll restrict myself to those about, or closely related to logic, formal methods, or programming languages, and which can count for the CSCI concentration as of the present version of the [Handbook](https://cs.brown.edu/degrees/undergrad/concentrating-in-cs/concentration-handbook/).

* CSCI 1010 (theory of computation)
* CSCI 1600 (real-time and embedded software)
* CSCI 1730 (programming languages)
* CSCI 1951X (formal proof and verification)
* PHIL 1630 (mathematical logic)
* PHIL 1880 (advanced deductive logic) 
* PHIL 1855 (modal logic)

There are many other great courses---some of which I might argue should also count as upper-level courses for the CSCI concentration, or which are only taught in the Spring semester. For instance, PHIL 1885 covers incompleteness and would be an interesting counterpoint to a more CSCI-focused course on computability.
 -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="satisfiability-modulo-theories-smt"><a class="header" href="#satisfiability-modulo-theories-smt">Satisfiability Modulo Theories (SMT)</a></h1>
<p><a href="chapters/solvers/./z3demo.py">Livecode link</a></p>
<p>Boolean solvers are powerful, but not very expressive. If you want to use them to solve a problem involving (e.g.)  arithmetic, you need to encode that idea with booleans. Forge does this with a technique called &quot;bit-blasting&quot;: one boolean variable per bit in a fixed bitwidth, along with formulas that build boolean adders, multipliers, etc. as needed. This works well for small examples, but can quickly run into performance issues—and if you need actual mathematical integers (to say nothing of real numbers!) you're out of luck.</p>
<p>An SMT solver is a SAT solver that can handle various domain-specific concepts beyond boolean logic. Hence &quot;modulo theories&quot;, where &quot;modulo&quot; means &quot;with respect to&quot;. SMT solvers solve satisfiability, but with the addition of (say) the theory of linear integer arithmetic or the theory of strings.</p>
<p>From a certain point of view, Forge is an &quot;SMT&quot; solver, because it includes concepts like relations and bit-vector integers. But this isn't usually how people understand the term these days. </p>
<p>SMT solvers can be either &quot;eager&quot; or &quot;lazy&quot;. An eager solver translates all the domain-specific constraints to boolean logic and then uses a boolean solver engine. That is Forge's approach. In contrast, a lazy solver actually implements domain-specific algorithms and integrates those with a purely-boolean solver core. Most modern SMT solvers tend to be lazy, and so they can benefit from clever domain algorithms. </p>
<div id="admonition-theories" class="admonition admonish-note">
<div class="admonition-title">
<p>Theories</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/smt.html#admonition-theories"></a></p>
</div>
<div>
<p>In the logic community, <em>theory</em> is just another word for set of constraints. So when we say &quot;the theory of linear integer arithmetic&quot; we mean the axioms that define the domain of linear integer arithmetic.</p>
</div>
</div>
<p>Here are some common domains that SMT solvers tend to support:</p>
<ul>
<li>uninterpreted functions with equality;</li>
<li>integer arithmetic (linear nearly always, non-linear sometimes);</li>
<li>real arithmetic;</li>
<li>lists and algebraic datatypes;</li>
<li>strings;</li>
<li>bit vectors;</li>
<li>arrays; and</li>
<li>datatypes.</li>
</ul>
<p>Of course, there are many others implemented in various solvers. The solver we'll use this week supports many of these, but not all.</p>
<h3 id="a-key-difference-universal-quantifiers"><a class="header" href="#a-key-difference-universal-quantifiers">A Key Difference: Universal Quantifiers</a></h3>
<p>Most modern SMT solvers don't have &quot;bounds&quot; in the same way Forge does. You can declare a datatype that's bounded in size, but the engine doesn't process that in the same way that Forge does. And the addition of domains like mathematical integers or lists means that the set of possible objects is infinite. This complicates universal (<code>all</code>) quantification.</p>
<p>What does it mean to say &quot;For all <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> of type <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> is true?&quot; In Forge, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> always has an upper bound, and so the quantifier can always be converted to a big, but finite, &quot;<code>and</code>&quot; constraint. But suppose the type is actual <em>mathematical integers</em>? There are infinitely many integers, which means the solver can't convert the quantifier to a (finite) boolean constraint. This is such an important factor in designing SMT solvers that SMT literature often refers to universal quantification as just &quot;quantification&quot;. </p>
<div id="admonition-universal-quantification" class="admonition admonish-warning">
<div class="admonition-title">
<p>Universal quantification</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/smt.html#admonition-universal-quantification"></a></p>
</div>
<div>
<p><strong>For now</strong>, try to avoid universal quantification in SMT if you can. You can't always avoid it, but make sure you really need it to express your goals.</p>
</div>
</div>
<p>Universal quantifiction isn't the only issue. Even without it, the domain-specific algorithms the solver uses might not be guaranteed to terminate. (This is a consequence of the fact that some of the problems SMT solvers can express are <em>undecidable</em>, which means it is impossible to produce an always-correct, always-terminating algorithm to solve the general problem.) Because of this, the solver is always working under a timeout. If the solver times out, it will give a new result type, other than &quot;sat&quot; and &quot;unsat&quot;: &quot;<em>unknown</em>&quot;.</p>
<h2 id="the-z3-solver"><a class="header" href="#the-z3-solver">The Z3 Solver</a></h2>
<p>Let's first step through some of the new things we can express with an SMT solver.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>We'll be using the Python bindings for the Z3 solver, available <a href="https://pypi.org/project/z3-solver/">here</a>. You can also install via <code>pip</code>:</p>
<p><code>pip3 install z3-solver</code></p>
<p>To update to the latest version of the solver, you can run:</p>
<p><code>pip3 install z3-solver --upgrade</code></p>
<p>Another great solver is <a href="https://cvc5.github.io">CVC5</a>. Although we won't use it in class, it supports some things that Z3 doesn't (and vice versa). For instance: relations!</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>We've still got the boolean-logic capabilities of a normal SAT solver:</p>
<pre><code class="language-python">def demoBool():
        # Create a new solver
        s = Solver()

        # declare some boolean *solver* variables
        p, q = Bools('p q')         
        
        s.add(Or(p, q))
        if s.check() == sat:        
            print(s.model()) # remember, &quot;model&quot; ~= &quot;instance&quot; here 
        
        # (Think: how would we get a different instance?)

        # getting at pieces of a model for programmatic use
        print(s.model().evaluate(p)) # can pass a formula              
</code></pre>
<p>When we run this, we get:</p>
<pre><code>[p = True, q = False]
True
</code></pre>
<div id="admonition-terminology-model" class="admonition admonish-warning">
<div class="admonition-title">
<p>Terminology: model</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/smt.html#admonition-terminology-model"></a></p>
</div>
<div>
<p>Different communities use different terminology. In this book, we use the word <em>model</em> to describe the definitions and constraints you use to model a system, just like an automotive engineer might build a computer model of a car. This is generally what the software-engineering community means by the word. </p>
<p>The logic community, on the other hand, uses <em>model</em> to mean the same thing that we call an <em>instance</em> in Forge: the valuation that either satisfies or dissatisfies a set of constraints.  There are good historical reasons for this, but for now, just be aware that Z3 will use the word &quot;model&quot; like a logician, not a software engineer.</p>
</div>
</div>
<h3 id="uninterpreted-functions-and-integer-inequalities"><a class="header" href="#uninterpreted-functions-and-integer-inequalities">Uninterpreted Functions And Integer Inequalities</a></h3>
<p>If a symbol (function, relation, constant, ...) is <em>interpreted</em>, then its meaning is encoded via constraints built into the solver. In Forge, we'd say that:</p>
<ul>
<li><code>add</code> is an interpreted function, since Forge assigns it a meaning innately; but</li>
<li>relations you add as sig fields are uninterpreted, since without constraints you add yourself, Forge treats their values as arbitrary.</li>
</ul>
<div id="admonition-error-rendering-admonishment" class="admonition admonish-bug">
<div class="admonition-title">
<p>Error rendering admonishment</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/smt.html#admonition-error-rendering-admonishment"></a></p>
</div>
<div>
<p>Failed with:</p>
<pre><code class="language-log">TOML parsing error: TOML parse error at line 1, column 9
  |
1 | warning 
  |         ^
expected `.`, `=`

</code></pre>
<p>Original markdown input:</p>
<pre><code class="language-markdown">~~~admonish warning title=Functions, not relations&quot; 
With some exceptions, SMT solvers usually focus on functions, not relations. This is another reason for Froglet to be about functions: they're more useful as a foundation in other tools!
~~~
</code></pre>
</div>
</div>
<p>Here is a Z3 function that demonstrates the difference between interpreted and uninterpreted functions:</p>
<pre><code class="language-python">def demoUninterpreted():
    s = Solver()
    # Solver variables: Ints and an uninterpreted functions 
    a, b = Ints('a b')  
    f = Function('f', IntSort(), IntSort())

    s.add(And(b &gt; a, f(b) &lt; f(a)))        
    if s.check() == sat:        
        print(s.model()) 
        print(s.model().evaluate(f(a)))
        print(s.model().evaluate(f(b)))
        print(s.model().evaluate(f(1000000)))
</code></pre>
<p>When we run this, we get:</p>
<pre><code>[b = 1, a = 0, f = [0 -&gt; 0, else -&gt; -1]]
0
-1
-1
</code></pre>
<p>Notice how the solver is reporting the function. It's not a table like it would be in Forge, but something much more like an if-then-else.</p>
<h3 id="numbers-integers-vs-reals"><a class="header" href="#numbers-integers-vs-reals">Numbers: Integers vs. Reals</a></h3>
<p>Let's try something that involves arithmetic, and also explore how the solver handles real numbers vs. integers. Here's a small example of how numbers work in Z3:</p>
<pre><code class="language-python">def demoReals():
    s = Solver()
    x = Real('x') 
    s.add(x*x &gt; 4)
    s.add(x*x &lt; 9)
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)
</code></pre>
<p>When we run this, we get an answer. But if we change the <code>Real</code> to <code>Int</code>, we won't because there is no integer between 2 and 3. </p>
<h3 id="factoring"><a class="header" href="#factoring">Factoring</a></h3>
<p>Here's another example: factoring polynomials. </p>
<p>We could use a universal quantifier here, but perhaps we don't need one. How we frame the problem can drastically affect how Z3 performs—in cases like this, the solver can often automatically handle the quantifier. But not always.</p>
<pre><code class="language-python">def demoFactoringIntWithUniversal():
    s = Solver()

    # (x - 2)(x + 2) = x^2 - 4
    # Suppose we know the RHS and want to find an *equivalent formula* LHS. 
    # We will solve for the roots:
    # (x - ROOT1)(x + ROOT2) = x^2 - 4

    xi, r1i, r2i = Ints('x root1 root2') # int vars

    # Note: don't use xi ** 2 -- gives unsat?
    s.add(ForAll(xi, (xi + r1i) * (xi + r2i) == (xi * xi) - 4  ))
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)

    s.reset()   

    # Try another one: 
    # (x + 123)(x - 321) = x^2 - 198x - 39483
    s.add(ForAll(xi, (xi + r1i) * (xi + r2i) 
                     == (xi * xi) + (198 * xi) - 39483))
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)
    # Note how fast, even with numbers up to almost 40k. Power of theory solver.

def demoFactoringReals():
    s = Solver()
    x, r1, r2 = Reals('x root1 root2') # real number vars
    # ^ As before, solve for r1, r2 because they are unbound in outer constraints
    #   x is quantified over and therefore not a var to &quot;solve&quot; for

    # (x + ???)(x + ???) = x^2 - 198x - 39484         
    s.add(ForAll(x, (x + r1) * (x + r2) 
                     == (x * x) + (198 * x) - 39484))
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)
</code></pre>
<h3 id="unsatisfiable-cores"><a class="header" href="#unsatisfiable-cores">Unsatisfiable Cores</a></h3>
<p>Let's try the same problem, but with a polynomial without any real roots. We should expect unsat (and indeed that's what we get). But can we get more than &quot;unsat&quot; out of the solver?</p>
<pre><code class="language-python">def demoFactoringRealsUnsat():
    s = Solver()

    # Here's how to start using cores in Z3 if you want, but
    # see the docs -- it's a bit more annoying because you need to create 
    # new boolean variables etc.

    s.set(unsat_core=True) # there are so many options, at many different levels

    x, r1, r2 = Reals('x root1 root2') # real number vars

    # Note e.g., x^2 - 2x + 5 has no real roots (b^2 - 4ac negative)
    # To enable core extraction, we need to name every top-level constraint we want to blame
    s.assert_and_track(ForAll(x, (x + r1) * (x + r2) 
                             == (x * x) - (2 * x) + 5), 'constr1')

    result = s.check() 
    if result == sat:
        print(s.model())    
    else: 
        print(result)
        # Note: it's a method of the solver, not the result. 
        print(s.unsat_core())         
</code></pre>
<h3 id="another-demo-n-queens"><a class="header" href="#another-demo-n-queens">Another Demo: N-Queens</a></h3>
<pre><code class="language-python">   def nQueens(numQ):
        s = Solver()
        # Model board as 2d list of booleans. Note the list is *Python*, booleans are *Solver*
        cells = [ [ z3.Bool(&quot;cell_{i}{j}&quot;.format(i=i,j=j)) 
                    for j in range(0, numQ)] 
                    for i in range(0, numQ) ]
        #print(cells)
        
        # a queen on every row
        queenEveryRow = And([Or([cells[i][j] for j in range(0, numQ)]) for i in range(0, numQ)])
        #print(queenEveryRow) # for demo only
        s.add(queenEveryRow)

        # for every i,j, if queen present there, implies no queen at various other places
        # Recall: queens can move vertically, horizontally, and diagonally.
        # &quot;Threaten&quot; means that a queen could capture another in 1 move. 
        queenThreats = And([Implies(cells[i][j], # Prefix notaton: (And x y) means &quot;x and y&quot;.
                                    And([Not(cells[i][k]) for k in range(0, numQ) if k != j] +
                                        [Not(cells[k][j]) for k in range(0, numQ) if k != i] +
                                        # Break up diagonals and don't try to be too smart about iteration
                                        [Not(cells[i+o][j+o]) for o in range(1, numQ) if (i+o &lt; numQ and j+o &lt; numQ) ] +
                                        [Not(cells[i-o][j-o]) for o in range(1, numQ) if (i-o &gt;= 0 and j-o &gt;= 0) ] +
                                        # flipped diagonals
                                        [Not(cells[i-o][j+o]) for o in range(1, numQ) if (i-o &gt;= 0 and j+o &lt; numQ) ] +
                                        [Not(cells[i+o][j-o]) for o in range(1, numQ) if (i+o &lt; numQ and j-o &gt;= 0) ]
                                        ))
                           for j in range(0, numQ)
                           for i in range(0, numQ)])
        #print(queenThreats) # for demo only
        s.add(queenThreats)

        if s.check() == sat:
            for i in range(0, numQ):
                print(' '.join([&quot;Q&quot; if s.model().evaluate(cells[i][j]) else &quot;_&quot; for j in range(0, numQ) ]))
        else: 
            print(&quot;unsat&quot;)

if __name__ == &quot;__main__&quot;:
    nQueens(4)
</code></pre>
<h2 id="whats-going-on-in-the-solver"><a class="header" href="#whats-going-on-in-the-solver">What's Going On In The Solver?</a></h2>
<p>Modern SMT-solvers tend to be <em>lazy</em> (a technical term): they use a base boolean solver, and call out to domain-specific algorithms (&quot;theory solvers&quot;) when needed. This is how Z3 manages to be so fast at algebraic reasoning.</p>
<p>But what shape of constraints do these theory-solvers accept? And how does an SMT solver manage to provide that? Let's look at one potential theory: systems of linear inequalities.</p>
<h3 id="an-example-theory-solver-linear-inequalities"><a class="header" href="#an-example-theory-solver-linear-inequalities">An Example Theory-Solver: Linear Inequalities</a></h3>
<p>If I gave you a system of linear inequalities, like this:</p>
<pre><code>x + y &lt; 3
x &lt; 2y
</code></pre>
<p>Could you find a solution? Probably (at least, if you Googled or had an old algebra textbook to hand). Or, if you're like me, you might <a href="https://www.wolframalpha.com/input?i=plot++x+%2B+y+%3C+3+and+x+%3C+2y">enter it into Wolfram Alpha</a>:</p>
<p><img src="https://i.imgur.com/NAETuFr.png" alt="" /></p>
<p>But suppose we added a bunch of boolean operators into the mix. Now what? You can't solve a &quot;system&quot; if the input involves &quot;or&quot;. </p>
<p>SMT solvers use a technique to separate out the boolean portion of a problem from the theory-specific portion. For example, if I wrote: <code>x &gt; 3 or y &gt; 5</code>, the solver will convert this to a <em>boolean skeleton</em>, replacing all the theory terms with boolean variables: <code>T1 or T2</code>, where <code>T1</code> means <code>x &gt; 3</code> and <code>T2</code> means <code>y &gt; 5</code>.  It can now find an assignment to that boolean skeleton with a normal SAT-solver. And every assignment is implicitly conjunctive: there's no &quot;or&quot;s left! </p>
<p>Suppose the solver finds <code>T1=True, T2=True</code>. Then we have the system:</p>
<pre><code>x &gt; 3
y &gt; 5
</code></pre>
<p>If, instead, the solver found <code>T1=False, T2=True</code>, we'd have the system:</p>
<pre><code>x &lt;= 3
y &gt; 5
</code></pre>
<p>Notice that each of these solutions to the boolean skeleton provide a system of inequalities that we could solve with algebra. We'll call this the <em>theory solver</em>; it can solve very restricted kinds of problem (like linear inequalities), but solve them intelligently.</p>
<p>This idea lets us implement a very basic SMT solver by following these 3 steps:</p>
<ul>
<li>(1) get another instance that satisfies the boolean skeleton; and then</li>
<li>(2) solve the resulting system with algebra. </li>
<li>(3) If the result of (2) is unsat, or another solution is desired, restart from (1).</li>
</ul>
<p>Modern SMT solvers have more integration between the boolean and theory solvers, but that's outside the scope of this course.</p>
<h3 id="another-example-theory-solver-uninterpreted-functions-with-equality"><a class="header" href="#another-example-theory-solver-uninterpreted-functions-with-equality">Another Example Theory-Solver: Uninterpreted Functions With Equality</a></h3>
<p>Here are some constraints:</p>
<pre><code>! ( f(f(f(a))) != a or f(a) = a ) 
f(f(f(f(f(a))))) = a or f(f(a)) != f(f(f(f(a))))
</code></pre>
<p>Are these constraints satisfiable? Does there exist some value of <code>a</code> and <code>f</code> such that these constraints are satisfied?</p>
<p>As before, we'll convert these to a boolean skeleton:</p>
<pre><code>!(T1 or T2)
T3 or T4
</code></pre>
<h3 id="an-unproductive-assignment"><a class="header" href="#an-unproductive-assignment">An Unproductive Assignment</a></h3>
<p>This CNF is satisfied by the assignment <code>T1=False, T2=False, T3=True, T4=False</code>, which gives us the theory problem:</p>
<pre><code>f3(a) = a
f(a) != a
f5(a) = a
f2(a) = f4(a)
</code></pre>
<p>(I won't even need that fourth constraint to show this skeleton-assignment won't work.)</p>
<p>This system of equalities can be solved via an algorithm called <em>congruence closure</em>. It goes something like this. First, collect all the terms involved in equalities and make</p>
<p><img src="https://i.imgur.com/BKRgQH7.png" alt="" /></p>
<p>Now draw undirected edges between the terms that the positive equality constraints force to be equivalent. Since we're being told that <code>f3(a) = a</code>, we'd draw an edge between those nodes. And similarly between <code>f5(a)</code> and <code>a</code>:</p>
<p><img src="https://i.imgur.com/FnX80hb.png" alt="" /></p>
<p>But equality is transitive! So we have learned that <code>f5(a)</code> and <code>f3(a)</code> are equivalent. (This is the &quot;closure&quot; part of the algorithm's name.)</p>
<p>From there, what else can we infer? Well, if <code>f3(a)</code> is the same as <code>a</code>, we can substitute <code>a</code> for <code>f(f(f(a)))</code> inside <code>f(f(f(f(f(a)))))</code>, giving us that <code>f(f(a))</code> (which we're calling <code>f2(a)</code> for brevity) is equivalent to <code>a</code> as well, since <code>f5(a) = a</code>. And since equality is transitive, <code>f2(a)</code> equals all the other things that equal <code>a</code>.</p>
<p><img src="https://i.imgur.com/NweNJdR.png" alt="" /></p>
<p>And if <code>f2(a) = a</code>, we can substitute <code>a</code> for <code>f(f(a))</code> within <code>f(f(f(a)))</code>, to get <code>f(a) = a</code>. </p>
<p>But this contradicts the negative equality constraint <code>f(a) != a</code>. So we've found a contradiction.</p>
<p><img src="https://i.imgur.com/6s7Rv6N.png" alt="" /></p>
<p>Now we've invented a second theory solver. The more of these we have, the more domains the solver can handle intelligently. (A natural question is: will all of these solvers work well together? The answer is not always, but we won't need to worry about that this semester.)</p>
<h3 id="a-productive-assignment"><a class="header" href="#a-productive-assignment">A Productive Assignment</a></h3>
<p>Another way of solving the boolean skeleton is with the assignment <code>T1=False, T2=False, T3=False, T4=True</code>, which gives us the theory problem:</p>
<pre><code>f3(a) = a
f(a) != a
f5(a) != a
f2(a) != f4(a)
</code></pre>
<p>We'd proceed similarly. But this time we don't have many unavoidable equalities between terms: <code>f3(a)</code> is linked with <code>a</code>, and we could say that <code>f6(a) = a</code> via substitution---if we cared about <code>f6(a)</code>. But it's not necessary for any of the inequalities to be violated. </p>
<h2 id="return-to-decidability"><a class="header" href="#return-to-decidability">Return to Decidability</a></h2>
<p>There's a famous unsolved problem in number theory called <a href="https://en.wikipedia.org/wiki/Goldbach%27s_conjecture">Goldbach's conjecture</a>. It states:</p>
<blockquote>
<p>Every integer greater than 2 can be written as the sum of three primes.</p>
</blockquote>
<div id="admonition-1-isnt-prime" class="admonition admonish-warning">
<div class="admonition-title">
<p>1 isn't prime!</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/smt.html#admonition-1-isnt-prime"></a></p>
</div>
<div>
<p>We generally consider 1 to be a non-prime number nowadays. But in the original formulation of this conjecture, it was meant to be. There are some alternative formulations in the article linked above, e.g., that <em>every even natural number greater than two is the sum of two primes</em>.</p>
</div>
</div>
<p>This is simple to state, and it's straightforward to express to Z3 or other SMT solvers. Yet, <strong>we don't know</strong> (at time of writing) whether or not the conjecture holds for <em>all</em> integers greater than 2. Mathematicians have looked for small (and not so small) counterexamples, and haven't found one yet. </p>
<p>That illustrates a big problem. To know whether Goldbach's conjecture is <em>false</em>, we just need to find an integer greater than 2 that cannot be written as the sum of 3 primes. Here's an algorithm for disproving the conjecture:</p>
<pre><code class="language-python">    for i in Integers:
        for p1, p2, p3 in PrimesUpTo(i):
            if i = p1 + p2 + p3: 
                continue;
        return i;
</code></pre>
<p>If Goldbach's conjecture is wrong, this computation will eventually terminate and give us the counterexample.</p>
<p>But what about the other direction? What if the conjecture is actually true? Then this computation never terminates, and never gives us an answer. We never learn that the conjecture is true, because we're never done searching for counterexamples. </p>
<p>Now, just because this specific algorithm isn't great doesn't mean that a better one might not exist. Maybe it's possible to be very smart, and search in a way that will terminate with <em>either</em> true or false. </p>
<p>Except that it's not <em>always</em> possible. CSCI 1010 talks about this a lot more, but I want to give you a bit of a taste of the ideas now that we're nearing the end of 1710.</p>
<h2 id="undecidability"><a class="header" href="#undecidability">Undecidability</a></h2>
<p>I want to tell you a story---with only <em>some</em> embellishment. </p>
<p>First, some context. How do we count things? Does <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span></span></span></span></span> have the same number of elements as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span>? What about <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> vs. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">}</span></span></span></span>? If we're comparing infinite sets, then it seems reasonable to say that they have the same size if we can make a bijection between them: a 1-1 mapping. </p>
<p>But then, counter-intuitively, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">}</span></span></span></span> are the same size. Why? Here's the idea, which is often called <em>Hilbert's Hotel</em>: suppose you work at the front desk of a hotel with a room for every natural number. And, that night, every room is occupied. A new guest arrives. Can you find room for them?</p>
<details>
<summary>Think, then click!</summary>
Yes! Here's how. For every room <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, tell that guest to move into room <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. You'll never run out of rooms, and room 0 will be free for the new guest. Every guest will need to do a finite amount of work, but assuming we can send this message to everyone at once, it works out.
<p><img src="https://i.imgur.com/vLlsryz.png" alt="" /></p>
</details>
<p>So, it's the late 1800's. Hilbert's Hotel (and related ideas) have excited the mathematical world. Indeed, can we use this trick to show that <em>every</em> infinite set is the same size? Are all infinities one, in a philosophical sense?</p>
<p>At this time, there was a non-famous but moderately successful mathematician named Georg Cantor. He was in his 40's when he made a groundbreaking discovery---contradicting the conventional wisdom (thanks, Hardy) that young mathematicians do all the interesting work. <strong>Cantor proved that the power set of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>, that is, the set of subsets of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>, must be strictly larger than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</strong></p>
<p>There is pandemonium. There is massive controversy. But, later mathematicians said that his ideas came 100 years before the community was ready for them. Hilbert himself actually said, later, that &quot;No one shall drive us from the paradise Cantor has created for us.&quot;</p>
<p>How did Cantor prove this? By contradiction. Assume you're given a bijection between a set <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> and its power set. Now, this bijection can be thought of as an infinite table, with subsets of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as rows and elements of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as columns. The cells contain booleans: true if the subset contains the element, and false if it doesn't. </p>
<div class="table-wrapper"><table><thead><tr><th>Set</th><th>0</th><th>1</th><th>...</th></tr></thead><tbody>
<tr><td>{}</td><td>N</td><td>N</td><td>...</td></tr>
<tr><td>{0}</td><td>Y</td><td>N</td><td>...</td></tr>
<tr><td>{0, 1}</td><td>Y</td><td>Y</td><td>...</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
</tbody></table>
</div>
<p>Cantor showed that there must <em>always</em> be a subset of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> that <em>isn't</em> represented as a row in the table. That is, such a bijection cannot exist. Even with the very permissive definition of &quot;same size&quot; we use for infinite sets, there are <em>still</em> more subsets of the natural numbers than there are natural numbers.</p>
<p>What is the subset that can't be represented as a row in the table?</p>
<details>
<summary>Think, then click!</summary>
<p>Read off the diagonal from the top-left onward, and invert each boolean. In the table above, the set would contain both 0 and 1 (because those first two rows do not contain them, respectively) and so on.</p>
<p>This technique is called &quot;Cantor diagonalization&quot;. </p>
</details>
<p>Why does this matter to <em>US</em>? Let me ask you two questions:</p>
<p><strong>QUESTION 1</strong>: How many syntactically-valid Java program source files are there?</p>
<details>
<summary>Think, then click!</summary>
<p>There are infinitely many. But let's be more precise. A the source code of a program is a <em>finite</em> text file. The size may be unbounded, but each specific file is finite. And the alphabet used for each character is also finite (let's say between 0 and 255, although that isn't always entirely accurate). </p>
<p>Thus, we can think of a program source file as a finite sequence of numbers between 0 and 255. This is the same as representing a natural number in base 256. There are as many Java program source files as there are natural numbers. </p>
</details>
<p><strong>QUESTION 2</strong>: How many mathematical functions from non-negative integer inputs to <code>bool</code> outputs are there, assuming your language has unbounded integers?</p>
<details>
<summary>Think, then click!</summary>
<p>Each such function returns true or false for any given non-negative integer. In effect, it is defining a specific set of these. There are as many such mathematical functions as there are sets of natural numbers. </p>
</details>
<p>What is our conclusion? </p>
<p>Try as you might, it is impossible to express all functions of these in any programming language where program texts are finite. So we know that programs in any language must be unable to express <em>some</em> things (indeed, most things). But is there anything that <strong>no</strong> language can express? Maybe all the things that are inexpressible are things that nobody actually needs or cares about. That would be comforting.</p>
<p>Unfortunately, there are <em>plenty</em> of important ideas that can't be expressed in any finite program. If you're curious about this, you might investigate CSCI 1010. I'm also happy to talk more about it offline. The following (very rough!) notes are meant to sketch one of the most famous problems in this area.</p>
<h3 id="another-story-outline"><a class="header" href="#another-story-outline">Another Story (OUTLINE)</a></h3>
<p>It's the early 1900's. Hilbert and others: <em>IS MATHEMATICS MECHANIZABLE</em>?</p>
<p>In 30's: Church, Turing, Godel: &quot;No. At least not completely.&quot; </p>
<p>Why? A few reasons. Here's a challenge. Write for me a program <code>h(f, v)</code> that accepts two arguments:</p>
<ul>
<li>another program; and</li>
<li>an input to that program.</li>
</ul>
<p>It must:</p>
<ul>
<li>always terminate; </li>
<li>return true IFF f(v) terminates in finite time;</li>
<li>return false IFF f(v) does not terminate in finite time</li>
</ul>
<p>Suppose <code>h</code> exists, and can be embodied in our language. Then consider this program.</p>
<pre><code>def g(x):
  if h(g, x): # AM I GOING TO HALT? (remember h always terminates)
    while(1); # NUH UH IM NOT!
  else:       
    return;   # HAHAHAHAHA YES I AM
</code></pre>
<p>Argh! Assuming that our halting function h is a program itself: CANNOT EXIST! This is called the &quot;halting problem&quot;.</p>
<p>Exercise: what consequences for us? OK to be philosophical, uncertain.</p>
<p>&quot;Undecidability&quot;</p>
<p><img src="https://i.imgur.com/1VISrAR.png" alt="" /></p>
<h3 id="what-does-this-have-to-do-with-smt"><a class="header" href="#what-does-this-have-to-do-with-smt">What Does This Have To Do With SMT?</a></h3>
<p>Gödel also proved that number theory is undecidable: if you've got the natural numbers, multiplication, and addition, it is impossible to write an algorithm that answers <em>arbitrary</em> questions about number theory in an <em>always correct</em> way, in <em>finite</em> time.</p>
<p>There are also tricks you'll learn in 1010 that let you say &quot;Well, if I could solve arbitrary questions about number theory, then I could turn the halting problem into a question about number theory!&quot;</p>
<p>There's so much more I'd like to talk about, but this lecture is already pretty disorganized, so I'm not going to plan on saying more today.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cegis-and-synthesis"><a class="header" href="#cegis-and-synthesis">CEGIS and Synthesis</a></h1>
<!-- Note for next year: see board layout in lecture capture. 
     This was likely more effective than trying to do this in Forge as the notes suggest.
 -->
<h2 id="counterexample-guided-inductive-synthesis-cegis"><a class="header" href="#counterexample-guided-inductive-synthesis-cegis">CounterExample Guided Inductive Synthesis (CEGIS)</a></h2>
<div id="admonition-pseudocode" class="admonition admonish-warning">
<div class="admonition-title">
<p>Pseudocode</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/cegis.html#admonition-pseudocode"></a></p>
</div>
<div>
<p>Many of the Forge expressions shown in this section will be demonstrative only, and won't actually run. You'll see why as we progress, but be warned!</p>
</div>
</div>
<p>Consider modeling <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal's</a> or <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim–Jarník's</a> approach to finding a minimum spanning tree on a weighted graph. In principle, we should be able to use Forge to reason about these algorithms, right? </p>
<p>Well, it's complicated.</p>
<h2 id="sketching-a-model"><a class="header" href="#sketching-a-model">Sketching a Model</a></h2>
<p>How might we start? We'd probably have the usual <code>sig Node</code> with a field <code>edges: pfunc Node -&gt; Int</code> to model the weighted edges. Then we would write some predicates like:</p>
<ul>
<li><code>wellformedgraph</code> (a well-formedness predicate to force the graphs to be weighted, directed, etc.); </li>
<li><code>isSpanningTree[t]</code> (a domain predicate describing the conditions for <code>t</code> to be a spanning tree); and</li>
<li><code>runPrimComplete</code> (a predicate that produces a complete execution of Prim's algorithm on the underlying graph).
along with some helper predicates, and so on. </li>
</ul>
<p>There are a few questions we might want to ask about MSTs in general, and not all of them involve the algorithm. For example, we could tell Forge to:</p>
<ul>
<li>Find a counter-example to correctness for Prim's algorithm (i.e., falsify &quot;Prim's always produces a minimal spanning tree). </li>
<li>Find a minimal spanning tree for a graph, independent of any algorithm model. 
These questions have a different character, even though they may seem similar. </li>
</ul>
<!-- * Find a valid MST that Prim's algorithm cannot produce.  -->
<h2 id="question-1-verify-or-falsify-prims-algorithm"><a class="header" href="#question-1-verify-or-falsify-prims-algorithm">Question 1: Verify or Falsify Prim's Algorithm</a></h2>
<p>We've set up this kind of analysis before. We'll just say:</p>
<pre><code class="language-alloy">one sig Helper { t2: set Node -&gt; Node -&gt; Int }
run {
  runPrimComplete    
  isSpanningTree[t2] // `isSpanningTree` doesn't need any quantifiers.
  weight[t2] &lt; weight[lastState.t] // lastState representing the Prim's model trace
}
</code></pre>
<p>Notice that we didn't need any universal quantification to talk about the counterexample. Instead, we could just say &quot;Prim's found some MST. Try to find a cheaper MST&quot;. </p>
<h2 id="question-2-finding-an-arbitrary-mst"><a class="header" href="#question-2-finding-an-arbitrary-mst">Question 2: Finding an arbitrary MST</a></h2>
<p>What does it mean to find a <em>minimum spanning tree</em> for an undirected, weighted graph <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>? It must be a set of edges <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, such that:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>;</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> forms a tree;</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> spans <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> (i.e., <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> contains at least one edge connected to every vertex in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>); and</li>
<li>for all other sets of edges <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> satisfies the previous 3 criteria, then the total weight of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> must be no less than the total weight of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> (i.e., <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> is a <em>minimal</em> weight spanning tree).</li>
</ul>
<p>Checking the final criterion requires higher-order universal quantification. We'd need to write something like this (don't try it!):</p>
<pre><code class="language-alloy">some t: set Node-&gt;Node |
  isSpanningTree[t]
  all t2: set Node-&gt;Node | 
    isSpanningTree[t2] implies weight[t2] &gt;= weight[t]
</code></pre>
<p>Forge can eliminate the outer <code>some</code> quantifier via Skolemization: turn it into a new relation to solve for. But it can't do that for the inner <code>all</code> quantifier. How many possible edge sets are there? If there are 5 possible <code>Node</code> objects, then there are 25 possible edges between those objects, and thus <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">25</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">33554432</span></span></span></span> possible edge sets. </p>
<p>The exponent will vary depending on the modeling goals. If you can exclude all self-loops, for example, it will be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span>. Technically, Forge probably could produce a big <code>and</code> formula with 33 million children, this approach doesn't scale. So the solver engine won't even try: it will stop running if given such a constraint.</p>
<p>We need a different way to attack this problem.</p>
<h3 id="an-alternative-formula"><a class="header" href="#an-alternative-formula">An Alternative Formula</a></h3>
<p>Suppose that, instead of the above shape, we had a specific edge set <code>t</code> handed to us, with the claim that <code>t</code> was a minimal spanning tree. Well, we could try to falsify <code>t</code>'s minimality:</p>
<pre><code class="language-alloy">  // ... definition of t is given to us ...

  // Search for a counter-example to `t` being a MST
  one sig Helper { t2: set Node -&gt; Node -&gt; Int }    
  run { 
    isSpanningTree[t2]
    weight[t2] &lt; weight[t]
  }
</code></pre>
<p>That is, suppose we had a <em>candidate</em> solution <code>t</code>, and we want to search for <em>better</em> solution. This is fine: Forge can handle higher-order <code>some</code>. So we can use Forge to check a candidate solution.</p>
<h3 id="an-idea"><a class="header" href="#an-idea">An Idea</a></h3>
<p>The fact that Forge can verify a candidate MST suggests an iterative approach. We'll start by finding a candidate spanning tree. It can be any spanning tree. Call its weight <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>. Then try to find something better, a spanning tree with length less than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>. </p>
<ul>
<li>If we find something better, we can add a constraint that says to only find candidates of weight <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> or less, and then continue. (We could use the counterexample itself as the new candidate. But in general, this won't always work, so we'll ignore the option.)</li>
<li>If we don't find something better, the candidate is actually a MST. </li>
</ul>
<p>Since Forge is a Racket library, you can use this technique via loop in Racket. This works for any solver that lets you make iterated queries. Since Z3py is a Python library, you can use this technique in Z3 as well. If you need to backtrack (usually you don't, with this technique), use the <code>pop</code> and <code>push</code> functions in Z3py.</p>
<h3 id="more-complicated-learning"><a class="header" href="#more-complicated-learning">More Complicated Learning</a></h3>
<p>This technique is pretty specialized, though. It relies on:</p>
<ul>
<li>having a metric for <em>goodness</em> (here, total edge weight); and</li>
<li>a well-defined and easily checkable precondition for candidacy (here, the notion of being a spanning tree). </li>
</ul>
<p>Not all higher-order universal constraints exhibit these nice properties, and others which aren't higher-order can still benefit from this idea. </p>
<p>Here's a classical example from formal methods: program synthesis. Suppose we were trying to <a href="http://www.csl.sri.com/users/tiwari/papers/pldi2011-bitvector.pdf">synthesize a program (see this link for the full work)</a> that takes a machine integer as input, and outputs the number of <code>1</code> bits in that number. We might express the goal roughly as:</p>
<pre><code class="language-alloy">some p: program |  
  all i: Int | 
    p[i] = countBitsInInteger[i] // assume we have this helper
</code></pre>
<p>We might proceed as follows:</p>
<ul>
<li>Generate a candidate program, any candidate program. Call it <code>p</code>. </li>
<li>Check it by seeing if <code>some i: Int | p[i] != countBitsInInteger[i]</code> is satisfiable. 
<ul>
<li>If no, we've found a good program.</li>
<li>If yes, there's an integer <code>i</code> that the current program doesn't work for. instantiate the formula <code>p[i] = countBitsInInteger[i]</code> with the concrete value, add it to our constraints, and repeat. This doesn't rule out a <em>lot</em> of the search space, but it does prevent the exact same problem from arising again in future candidates. </li>
</ul>
</li>
</ul>
<p>This broad technique is called CounterExample Guided Inductive Synthesis (or CEGIS). It and related ideas are used heavily in synthesis tools. Similar ideas are also used inside SMT solvers to help eliminate universal quantifiers.</p>
<p>Sophisticated versions of CEGIS will try to infer root causes for failure rather than just learning, essentially, &quot;...yes, but make it work for <code>i</code>, too.&quot; This tends to be what makes the technique scale well: the more focused a cause you can learn, the more of the search space you can rule out with each iteration. </p>
<div id="admonition-inductive" class="admonition admonish-note">
<div class="admonition-title">
<p>Inductive</p>
<p><a class="admonition-anchor-link" href="chapters/solvers/cegis.html#admonition-inductive"></a></p>
</div>
<div>
<p>If you've used proof by induction before, note that the use of &quot;inductive&quot; here is different! Inductive synthesis learns by example; in essence, automating <a href="https://en.wikipedia.org/wiki/Inductive_reasoning">inductive reasoning</a>, which is not the same thing as the inductive principle in mathematics.</p>
</div>
</div>
<p>For more information, I suggest skimming the paper linked above about synthesizing bit-vector manipulation programs, or <a href="https://people.csail.mit.edu/asolar/papers/thesis.pdf">Armando Solar-Lezama's PhD thesis</a>, where the idea was introduced.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
