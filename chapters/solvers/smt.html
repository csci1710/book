<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Satisfiability Modulo Theories (SMT) - Logic for Systems: Lightweight Formal Methods for Everybody</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../././mdbook-admonish.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">
        <link rel="stylesheet" href="../.././custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../welcome.html">How to Read this book</a></li><li class="chapter-item affix "><li class="part-title">Preamble: Beyond Testing</li><li class="chapter-item "><a href="../../chapters/manifesto/job.html">What good is this book?</a></li><li class="chapter-item "><a href="../../chapters/manifesto/manifesto.html">Logic for Systems</a></li><li class="chapter-item "><a href="../../chapters/properties/pbt.html">From Tests to Properties</a></li><li class="chapter-item affix "><li class="part-title">Modeling Static Scenarios</li><li class="chapter-item "><a href="../../chapters/ttt/ttt.html">Tic-Tac-Toe</a></li><li class="chapter-item "><a href="../../chapters/bst/bst.html">Binary Search Trees</a></li><li class="chapter-item "><a href="../../chapters/adder/rca.html">Ripple-Carry Adder</a></li><li class="chapter-item "><a href="../../chapters/qna/static.html">Q&A: Static Modeling</a></li><li class="chapter-item affix "><li class="part-title">Discrete Event Systems</li><li class="chapter-item "><a href="../../chapters/ttt/ttt_games.html">Transitions, Traces, and Verification</a></li><li class="chapter-item "><a href="../../chapters/inductive/bsearch.html">Counterexamples to Induction</a></li><li class="chapter-item "><a href="../../chapters/bst/descent.html">BSTs: Recursive Descent</a></li><li class="chapter-item "><a href="../../chapters/validation/validating_events.html">Validating Models</a></li><li class="chapter-item "><a href="../../chapters/qna/events.html">Q&A: Event Systems</a></li><li class="chapter-item affix "><li class="part-title">Modeling Relationships</li><li class="chapter-item "><a href="../../chapters/relations/modeling-booleans-1.html">Relational Forge, Modeling Logic</a></li><li class="chapter-item "><a href="../../chapters/relations/reachability.html">Transitive Closure</a></li><li class="chapter-item "><a href="../../chapters/relations/sets-induction-mutex.html">Modeling Mutual Exclusion</a></li><li class="chapter-item "><a href="../../chapters/relations/sets-beyond-assertions.html">Going Beyond Assertions</a></li><li class="chapter-item "><a href="../../chapters/solvers/bounds_booleans_how_forge_works.html">How does Forge Work?</a></li><li class="chapter-item "><a href="../../chapters/qna/relations.html">Q&A: Relations</a></li><li class="chapter-item affix "><li class="part-title">Temporal Specification</li><li class="chapter-item "><a href="../../chapters/temporal/liveness_and_lassos.html">Liveness and Lassos</a></li><li class="chapter-item "><a href="../../chapters/temporal/temporal_operators.html">Temporal Forge</a></li><li class="chapter-item "><a href="../../chapters/temporal/temporal_operators_2.html">Linear Temporal Logic</a></li><li class="chapter-item "><a href="../../chapters/temporal/obligations_past.html">Obligations and the Past</a></li><li class="chapter-item "><a href="../../chapters/temporal/fixing_lock_temporal.html">Mutual Exclusion, Revisited</a></li><li class="chapter-item "><a href="../../chapters/temporal/testing_temporal.html">Testing Temporally</a></li><li class="chapter-item affix "><li class="part-title">Boolean Solver Algorithms</li><li class="chapter-item "><a href="../../chapters/solvers/dpll.html">Boolean SAT (DPLL)</a></li><li class="chapter-item "><a href="../../chapters/solvers/resolution.html">Witnessing Unsat: Propositional resolution</a></li><li class="chapter-item affix "><li class="part-title">Beyond SAT</li><li class="chapter-item expanded "><a href="../../chapters/solvers/smt.html" class="active">Satisfiability Modulo Theories (SMT)</a></li><li class="chapter-item "><a href="../../chapters/solvers/cegis.html">Learning with Solvers: CEGIS</a></li><li class="chapter-item affix "><li class="part-title">Case Studies and Further Reading</li><li class="chapter-item "><div>Modeling Raft in Anger</div></li><li class="chapter-item "><div>Forge: Comparing Prim's and Dijkstra's Algorithms</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Logic for Systems: Lightweight Formal Methods for Everybody</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="satisfiability-modulo-theories-smt"><a class="header" href="#satisfiability-modulo-theories-smt">Satisfiability Modulo Theories (SMT)</a></h1>
<p><a href="./z3demo.py">Livecode link</a></p>
<p>Boolean solvers are powerful, but not very expressive. If you want to use them to solve a problem involving (e.g.)  arithmetic, you need to encode that idea with booleans. Forge does this with a technique called &quot;bit-blasting&quot;: one boolean variable per bit in a fixed bitwidth, along with formulas that build boolean adders, multipliers, etc. as needed. This works well for small examples, but can quickly run into performance issues—and if you need actual mathematical integers (to say nothing of real numbers!) you're out of luck.</p>
<p>An SMT solver is a SAT solver that can handle various domain-specific concepts beyond boolean logic. Hence &quot;modulo theories&quot;, where &quot;modulo&quot; means &quot;with respect to&quot;. SMT solvers solve satisfiability, but with the addition of (say) the theory of linear integer arithmetic or the theory of strings.</p>
<p>From a certain point of view, Forge is an &quot;SMT&quot; solver, because it includes concepts like relations and bit-vector integers. But this isn't usually how people understand the term these days. </p>
<p>SMT solvers can be either &quot;eager&quot; or &quot;lazy&quot;. An eager solver translates all the domain-specific constraints to boolean logic and then uses a boolean solver engine. That is Forge's approach. In contrast, a lazy solver actually implements domain-specific algorithms and integrates those with a purely-boolean solver core. Most modern SMT solvers tend to be lazy, and so they can benefit from clever domain algorithms. </p>
<div id="admonition-theories" class="admonition admonish-note">
<div class="admonition-title">
<p>Theories</p>
<p><a class="admonition-anchor-link" href="#admonition-theories"></a></p>
</div>
<div>
<p>In the logic community, <em>theory</em> is just another word for set of constraints. So when we say &quot;the theory of linear integer arithmetic&quot; we mean the axioms that define the domain of linear integer arithmetic.</p>
</div>
</div>
<p>Here are some common domains that SMT solvers tend to support:</p>
<ul>
<li>uninterpreted functions with equality;</li>
<li>integer arithmetic (linear nearly always, non-linear sometimes);</li>
<li>real arithmetic;</li>
<li>lists and algebraic datatypes;</li>
<li>strings;</li>
<li>bit vectors;</li>
<li>arrays; and</li>
<li>datatypes.</li>
</ul>
<p>Of course, there are many others implemented in various solvers. The solver we'll use this week supports many of these, but not all.</p>
<h3 id="a-key-difference-universal-quantifiers"><a class="header" href="#a-key-difference-universal-quantifiers">A Key Difference: Universal Quantifiers</a></h3>
<p>Most modern SMT solvers don't have &quot;bounds&quot; in the same way Forge does. You can declare a datatype that's bounded in size, but the engine doesn't process that in the same way that Forge does. And the addition of domains like mathematical integers or lists means that the set of possible objects is infinite. This complicates universal (<code>all</code>) quantification.</p>
<p>What does it mean to say &quot;For all <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> of type <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> is true?&quot; In Forge, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> always has an upper bound, and so the quantifier can always be converted to a big, but finite, &quot;<code>and</code>&quot; constraint. But suppose the type is actual <em>mathematical integers</em>? There are infinitely many integers, which means the solver can't convert the quantifier to a (finite) boolean constraint. This is such an important factor in designing SMT solvers that SMT literature often refers to universal quantification as just &quot;quantification&quot;. </p>
<div id="admonition-universal-quantification" class="admonition admonish-warning">
<div class="admonition-title">
<p>Universal quantification</p>
<p><a class="admonition-anchor-link" href="#admonition-universal-quantification"></a></p>
</div>
<div>
<p><strong>For now</strong>, try to avoid universal quantification in SMT if you can. You can't always avoid it, but make sure you really need it to express your goals.</p>
</div>
</div>
<p>Universal quantifiction isn't the only issue. Even without it, the domain-specific algorithms the solver uses might not be guaranteed to terminate. (This is a consequence of the fact that some of the problems SMT solvers can express are <em>undecidable</em>, which means it is impossible to produce an always-correct, always-terminating algorithm to solve the general problem.) Because of this, the solver is always working under a timeout. If the solver times out, it will give a new result type, other than &quot;sat&quot; and &quot;unsat&quot;: &quot;<em>unknown</em>&quot;.</p>
<h2 id="the-z3-solver"><a class="header" href="#the-z3-solver">The Z3 Solver</a></h2>
<p>Let's first step through some of the new things we can express with an SMT solver.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>We'll be using the Python bindings for the Z3 solver, available <a href="https://pypi.org/project/z3-solver/">here</a>. You can also install via <code>pip</code>:</p>
<p><code>pip3 install z3-solver</code></p>
<p>To update to the latest version of the solver, you can run:</p>
<p><code>pip3 install z3-solver --upgrade</code></p>
<p>Another great solver is <a href="https://cvc5.github.io">CVC5</a>. Although we won't use it in class, it supports some things that Z3 doesn't (and vice versa). For instance: relations!</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>We've still got the boolean-logic capabilities of a normal SAT solver:</p>
<pre><code class="language-python">def demoBool():
        # Create a new solver
        s = Solver()

        # declare some boolean *solver* variables
        p, q = Bools('p q')         
        
        s.add(Or(p, q))
        if s.check() == sat:        
            print(s.model()) # remember, &quot;model&quot; ~= &quot;instance&quot; here 
        
        # (Think: how would we get a different instance?)

        # getting at pieces of a model for programmatic use
        print(s.model().evaluate(p)) # can pass a formula              
</code></pre>
<p>When we run this, we get:</p>
<pre><code>[p = True, q = False]
True
</code></pre>
<div id="admonition-terminology-model" class="admonition admonish-warning">
<div class="admonition-title">
<p>Terminology: model</p>
<p><a class="admonition-anchor-link" href="#admonition-terminology-model"></a></p>
</div>
<div>
<p>Different communities use different terminology. In this book, we use the word <em>model</em> to describe the definitions and constraints you use to model a system, just like an automotive engineer might build a computer model of a car. This is generally what the software-engineering community means by the word. </p>
<p>The logic community, on the other hand, uses <em>model</em> to mean the same thing that we call an <em>instance</em> in Forge: the valuation that either satisfies or dissatisfies a set of constraints.  There are good historical reasons for this, but for now, just be aware that Z3 will use the word &quot;model&quot; like a logician, not a software engineer.</p>
</div>
</div>
<h3 id="uninterpreted-functions-and-integer-inequalities"><a class="header" href="#uninterpreted-functions-and-integer-inequalities">Uninterpreted Functions And Integer Inequalities</a></h3>
<p>If a symbol (function, relation, constant, ...) is <em>interpreted</em>, then its meaning is encoded via constraints built into the solver. In Forge, we'd say that:</p>
<ul>
<li><code>add</code> is an interpreted function, since Forge assigns it a meaning innately; but</li>
<li>relations you add as sig fields are uninterpreted, since without constraints you add yourself, Forge treats their values as arbitrary.</li>
</ul>
<div id="admonition-error-rendering-admonishment" class="admonition admonish-bug">
<div class="admonition-title">
<p>Error rendering admonishment</p>
<p><a class="admonition-anchor-link" href="#admonition-error-rendering-admonishment"></a></p>
</div>
<div>
<p>Failed with:</p>
<pre><code class="language-log">TOML parsing error: TOML parse error at line 1, column 9
  |
1 | warning 
  |         ^
expected `.`, `=`

</code></pre>
<p>Original markdown input:</p>
<pre><code class="language-markdown">~~~admonish warning title=Functions, not relations&quot; 
With some exceptions, SMT solvers usually focus on functions, not relations. This is another reason for Froglet to be about functions: they're more useful as a foundation in other tools!
~~~
</code></pre>
</div>
</div>
<p>Here is a Z3 function that demonstrates the difference between interpreted and uninterpreted functions:</p>
<pre><code class="language-python">def demoUninterpreted():
    s = Solver()
    # Solver variables: Ints and an uninterpreted functions 
    a, b = Ints('a b')  
    f = Function('f', IntSort(), IntSort())

    s.add(And(b &gt; a, f(b) &lt; f(a)))        
    if s.check() == sat:        
        print(s.model()) 
        print(s.model().evaluate(f(a)))
        print(s.model().evaluate(f(b)))
        print(s.model().evaluate(f(1000000)))
</code></pre>
<p>When we run this, we get:</p>
<pre><code>[b = 1, a = 0, f = [0 -&gt; 0, else -&gt; -1]]
0
-1
-1
</code></pre>
<p>Notice how the solver is reporting the function. It's not a table like it would be in Forge, but something much more like an if-then-else.</p>
<h3 id="numbers-integers-vs-reals"><a class="header" href="#numbers-integers-vs-reals">Numbers: Integers vs. Reals</a></h3>
<p>Let's try something that involves arithmetic, and also explore how the solver handles real numbers vs. integers. Here's a small example of how numbers work in Z3:</p>
<pre><code class="language-python">def demoReals():
    s = Solver()
    x = Real('x') 
    s.add(x*x &gt; 4)
    s.add(x*x &lt; 9)
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)
</code></pre>
<p>When we run this, we get an answer. But if we change the <code>Real</code> to <code>Int</code>, we won't because there is no integer between 2 and 3. </p>
<h3 id="factoring"><a class="header" href="#factoring">Factoring</a></h3>
<p>Here's another example: factoring polynomials. </p>
<p>We could use a universal quantifier here, but perhaps we don't need one. How we frame the problem can drastically affect how Z3 performs—in cases like this, the solver can often automatically handle the quantifier. But not always.</p>
<pre><code class="language-python">def demoFactoringIntWithUniversal():
    s = Solver()

    # (x - 2)(x + 2) = x^2 - 4
    # Suppose we know the RHS and want to find an *equivalent formula* LHS. 
    # We will solve for the roots:
    # (x - ROOT1)(x + ROOT2) = x^2 - 4

    xi, r1i, r2i = Ints('x root1 root2') # int vars

    # Note: don't use xi ** 2 -- gives unsat?
    s.add(ForAll(xi, (xi + r1i) * (xi + r2i) == (xi * xi) - 4  ))
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)

    s.reset()   

    # Try another one: 
    # (x + 123)(x - 321) = x^2 - 198x - 39483
    s.add(ForAll(xi, (xi + r1i) * (xi + r2i) 
                     == (xi * xi) + (198 * xi) - 39483))
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)
    # Note how fast, even with numbers up to almost 40k. Power of theory solver.

def demoFactoringReals():
    s = Solver()
    x, r1, r2 = Reals('x root1 root2') # real number vars
    # ^ As before, solve for r1, r2 because they are unbound in outer constraints
    #   x is quantified over and therefore not a var to &quot;solve&quot; for

    # (x + ???)(x + ???) = x^2 - 198x - 39484         
    s.add(ForAll(x, (x + r1) * (x + r2) 
                     == (x * x) + (198 * x) - 39484))
    result = s.check()
    if result == sat:
        print(s.model())    
    else: 
        print(result)
</code></pre>
<h3 id="unsatisfiable-cores"><a class="header" href="#unsatisfiable-cores">Unsatisfiable Cores</a></h3>
<p>Let's try the same problem, but with a polynomial without any real roots. We should expect unsat (and indeed that's what we get). But can we get more than &quot;unsat&quot; out of the solver?</p>
<pre><code class="language-python">def demoFactoringRealsUnsat():
    s = Solver()

    # Here's how to start using cores in Z3 if you want, but
    # see the docs -- it's a bit more annoying because you need to create 
    # new boolean variables etc.

    s.set(unsat_core=True) # there are so many options, at many different levels

    x, r1, r2 = Reals('x root1 root2') # real number vars

    # Note e.g., x^2 - 2x + 5 has no real roots (b^2 - 4ac negative)
    # To enable core extraction, we need to name every top-level constraint we want to blame
    s.assert_and_track(ForAll(x, (x + r1) * (x + r2) 
                             == (x * x) - (2 * x) + 5), 'constr1')

    result = s.check() 
    if result == sat:
        print(s.model())    
    else: 
        print(result)
        # Note: it's a method of the solver, not the result. 
        print(s.unsat_core())         
</code></pre>
<h3 id="another-demo-n-queens"><a class="header" href="#another-demo-n-queens">Another Demo: N-Queens</a></h3>
<pre><code class="language-python">   def nQueens(numQ):
        s = Solver()
        # Model board as 2d list of booleans. Note the list is *Python*, booleans are *Solver*
        cells = [ [ z3.Bool(&quot;cell_{i}{j}&quot;.format(i=i,j=j)) 
                    for j in range(0, numQ)] 
                    for i in range(0, numQ) ]
        #print(cells)
        
        # a queen on every row
        queenEveryRow = And([Or([cells[i][j] for j in range(0, numQ)]) for i in range(0, numQ)])
        #print(queenEveryRow) # for demo only
        s.add(queenEveryRow)

        # for every i,j, if queen present there, implies no queen at various other places
        # Recall: queens can move vertically, horizontally, and diagonally.
        # &quot;Threaten&quot; means that a queen could capture another in 1 move. 
        queenThreats = And([Implies(cells[i][j], # Prefix notaton: (And x y) means &quot;x and y&quot;.
                                    And([Not(cells[i][k]) for k in range(0, numQ) if k != j] +
                                        [Not(cells[k][j]) for k in range(0, numQ) if k != i] +
                                        # Break up diagonals and don't try to be too smart about iteration
                                        [Not(cells[i+o][j+o]) for o in range(1, numQ) if (i+o &lt; numQ and j+o &lt; numQ) ] +
                                        [Not(cells[i-o][j-o]) for o in range(1, numQ) if (i-o &gt;= 0 and j-o &gt;= 0) ] +
                                        # flipped diagonals
                                        [Not(cells[i-o][j+o]) for o in range(1, numQ) if (i-o &gt;= 0 and j+o &lt; numQ) ] +
                                        [Not(cells[i+o][j-o]) for o in range(1, numQ) if (i+o &lt; numQ and j-o &gt;= 0) ]
                                        ))
                           for j in range(0, numQ)
                           for i in range(0, numQ)])
        #print(queenThreats) # for demo only
        s.add(queenThreats)

        if s.check() == sat:
            for i in range(0, numQ):
                print(' '.join([&quot;Q&quot; if s.model().evaluate(cells[i][j]) else &quot;_&quot; for j in range(0, numQ) ]))
        else: 
            print(&quot;unsat&quot;)

if __name__ == &quot;__main__&quot;:
    nQueens(4)
</code></pre>
<h2 id="whats-going-on-in-the-solver"><a class="header" href="#whats-going-on-in-the-solver">What's Going On In The Solver?</a></h2>
<p>Modern SMT-solvers tend to be <em>lazy</em> (a technical term): they use a base boolean solver, and call out to domain-specific algorithms (&quot;theory solvers&quot;) when needed. This is how Z3 manages to be so fast at algebraic reasoning.</p>
<p>But what shape of constraints do these theory-solvers accept? And how does an SMT solver manage to provide that? Let's look at one potential theory: systems of linear inequalities.</p>
<h3 id="an-example-theory-solver-linear-inequalities"><a class="header" href="#an-example-theory-solver-linear-inequalities">An Example Theory-Solver: Linear Inequalities</a></h3>
<p>If I gave you a system of linear inequalities, like this:</p>
<pre><code>x + y &lt; 3
x &lt; 2y
</code></pre>
<p>Could you find a solution? Probably (at least, if you Googled or had an old algebra textbook to hand). Or, if you're like me, you might <a href="https://www.wolframalpha.com/input?i=plot++x+%2B+y+%3C+3+and+x+%3C+2y">enter it into Wolfram Alpha</a>:</p>
<p><img src="https://i.imgur.com/NAETuFr.png" alt="" /></p>
<p>But suppose we added a bunch of boolean operators into the mix. Now what? You can't solve a &quot;system&quot; if the input involves &quot;or&quot;. </p>
<p>SMT solvers use a technique to separate out the boolean portion of a problem from the theory-specific portion. For example, if I wrote: <code>x &gt; 3 or y &gt; 5</code>, the solver will convert this to a <em>boolean skeleton</em>, replacing all the theory terms with boolean variables: <code>T1 or T2</code>, where <code>T1</code> means <code>x &gt; 3</code> and <code>T2</code> means <code>y &gt; 5</code>.  It can now find an assignment to that boolean skeleton with a normal SAT-solver. And every assignment is implicitly conjunctive: there's no &quot;or&quot;s left! </p>
<p>Suppose the solver finds <code>T1=True, T2=True</code>. Then we have the system:</p>
<pre><code>x &gt; 3
y &gt; 5
</code></pre>
<p>If, instead, the solver found <code>T1=False, T2=True</code>, we'd have the system:</p>
<pre><code>x &lt;= 3
y &gt; 5
</code></pre>
<p>Notice that each of these solutions to the boolean skeleton provide a system of inequalities that we could solve with algebra. We'll call this the <em>theory solver</em>; it can solve very restricted kinds of problem (like linear inequalities), but solve them intelligently.</p>
<p>This idea lets us implement a very basic SMT solver by following these 3 steps:</p>
<ul>
<li>(1) get another instance that satisfies the boolean skeleton; and then</li>
<li>(2) solve the resulting system with algebra. </li>
<li>(3) If the result of (2) is unsat, or another solution is desired, restart from (1).</li>
</ul>
<p>Modern SMT solvers have more integration between the boolean and theory solvers, but that's outside the scope of this course.</p>
<h3 id="another-example-theory-solver-uninterpreted-functions-with-equality"><a class="header" href="#another-example-theory-solver-uninterpreted-functions-with-equality">Another Example Theory-Solver: Uninterpreted Functions With Equality</a></h3>
<p>Here are some constraints:</p>
<pre><code>! ( f(f(f(a))) != a or f(a) = a ) 
f(f(f(f(f(a))))) = a or f(f(a)) != f(f(f(f(a))))
</code></pre>
<p>Are these constraints satisfiable? Does there exist some value of <code>a</code> and <code>f</code> such that these constraints are satisfied?</p>
<p>As before, we'll convert these to a boolean skeleton:</p>
<pre><code>!(T1 or T2)
T3 or T4
</code></pre>
<h3 id="an-unproductive-assignment"><a class="header" href="#an-unproductive-assignment">An Unproductive Assignment</a></h3>
<p>This CNF is satisfied by the assignment <code>T1=False, T2=False, T3=True, T4=False</code>, which gives us the theory problem:</p>
<pre><code>f3(a) = a
f(a) != a
f5(a) = a
f2(a) = f4(a)
</code></pre>
<p>(I won't even need that fourth constraint to show this skeleton-assignment won't work.)</p>
<p>This system of equalities can be solved via an algorithm called <em>congruence closure</em>. It goes something like this. First, collect all the terms involved in equalities and make</p>
<p><img src="https://i.imgur.com/BKRgQH7.png" alt="" /></p>
<p>Now draw undirected edges between the terms that the positive equality constraints force to be equivalent. Since we're being told that <code>f3(a) = a</code>, we'd draw an edge between those nodes. And similarly between <code>f5(a)</code> and <code>a</code>:</p>
<p><img src="https://i.imgur.com/FnX80hb.png" alt="" /></p>
<p>But equality is transitive! So we have learned that <code>f5(a)</code> and <code>f3(a)</code> are equivalent. (This is the &quot;closure&quot; part of the algorithm's name.)</p>
<p>From there, what else can we infer? Well, if <code>f3(a)</code> is the same as <code>a</code>, we can substitute <code>a</code> for <code>f(f(f(a)))</code> inside <code>f(f(f(f(f(a)))))</code>, giving us that <code>f(f(a))</code> (which we're calling <code>f2(a)</code> for brevity) is equivalent to <code>a</code> as well, since <code>f5(a) = a</code>. And since equality is transitive, <code>f2(a)</code> equals all the other things that equal <code>a</code>.</p>
<p><img src="https://i.imgur.com/NweNJdR.png" alt="" /></p>
<p>And if <code>f2(a) = a</code>, we can substitute <code>a</code> for <code>f(f(a))</code> within <code>f(f(f(a)))</code>, to get <code>f(a) = a</code>. </p>
<p>But this contradicts the negative equality constraint <code>f(a) != a</code>. So we've found a contradiction.</p>
<p><img src="https://i.imgur.com/6s7Rv6N.png" alt="" /></p>
<p>Now we've invented a second theory solver. The more of these we have, the more domains the solver can handle intelligently. (A natural question is: will all of these solvers work well together? The answer is not always, but we won't need to worry about that this semester.)</p>
<h3 id="a-productive-assignment"><a class="header" href="#a-productive-assignment">A Productive Assignment</a></h3>
<p>Another way of solving the boolean skeleton is with the assignment <code>T1=False, T2=False, T3=False, T4=True</code>, which gives us the theory problem:</p>
<pre><code>f3(a) = a
f(a) != a
f5(a) != a
f2(a) != f4(a)
</code></pre>
<p>We'd proceed similarly. But this time we don't have many unavoidable equalities between terms: <code>f3(a)</code> is linked with <code>a</code>, and we could say that <code>f6(a) = a</code> via substitution---if we cared about <code>f6(a)</code>. But it's not necessary for any of the inequalities to be violated. </p>
<h2 id="return-to-decidability"><a class="header" href="#return-to-decidability">Return to Decidability</a></h2>
<p>There's a famous unsolved problem in number theory called <a href="https://en.wikipedia.org/wiki/Goldbach%27s_conjecture">Goldbach's conjecture</a>. It states:</p>
<blockquote>
<p>Every integer greater than 2 can be written as the sum of three primes.</p>
</blockquote>
<div id="admonition-1-isnt-prime" class="admonition admonish-warning">
<div class="admonition-title">
<p>1 isn't prime!</p>
<p><a class="admonition-anchor-link" href="#admonition-1-isnt-prime"></a></p>
</div>
<div>
<p>We generally consider 1 to be a non-prime number nowadays. But in the original formulation of this conjecture, it was meant to be. There are some alternative formulations in the article linked above, e.g., that <em>every even natural number greater than two is the sum of two primes</em>.</p>
</div>
</div>
<p>This is simple to state, and it's straightforward to express to Z3 or other SMT solvers. Yet, <strong>we don't know</strong> (at time of writing) whether or not the conjecture holds for <em>all</em> integers greater than 2. Mathematicians have looked for small (and not so small) counterexamples, and haven't found one yet. </p>
<p>That illustrates a big problem. To know whether Goldbach's conjecture is <em>false</em>, we just need to find an integer greater than 2 that cannot be written as the sum of 3 primes. Here's an algorithm for disproving the conjecture:</p>
<pre><code class="language-python">    for i in Integers:
        for p1, p2, p3 in PrimesUpTo(i):
            if i = p1 + p2 + p3: 
                continue;
        return i;
</code></pre>
<p>If Goldbach's conjecture is wrong, this computation will eventually terminate and give us the counterexample.</p>
<p>But what about the other direction? What if the conjecture is actually true? Then this computation never terminates, and never gives us an answer. We never learn that the conjecture is true, because we're never done searching for counterexamples. </p>
<p>Now, just because this specific algorithm isn't great doesn't mean that a better one might not exist. Maybe it's possible to be very smart, and search in a way that will terminate with <em>either</em> true or false. </p>
<p>Except that it's not <em>always</em> possible. CSCI 1010 talks about this a lot more, but I want to give you a bit of a taste of the ideas now that we're nearing the end of 1710.</p>
<h2 id="undecidability"><a class="header" href="#undecidability">Undecidability</a></h2>
<p>I want to tell you a story---with only <em>some</em> embellishment. </p>
<p>First, some context. How do we count things? Does <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span></span></span></span></span> have the same number of elements as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span>? What about <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> vs. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">}</span></span></span></span>? If we're comparing infinite sets, then it seems reasonable to say that they have the same size if we can make a bijection between them: a 1-1 mapping. </p>
<p>But then, counter-intuitively, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">}</span></span></span></span> are the same size. Why? Here's the idea, which is often called <em>Hilbert's Hotel</em>: suppose you work at the front desk of a hotel with a room for every natural number. And, that night, every room is occupied. A new guest arrives. Can you find room for them?</p>
<details>
<summary>Think, then click!</summary>
Yes! Here's how. For every room <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, tell that guest to move into room <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. You'll never run out of rooms, and room 0 will be free for the new guest. Every guest will need to do a finite amount of work, but assuming we can send this message to everyone at once, it works out.
<p><img src="https://i.imgur.com/vLlsryz.png" alt="" /></p>
</details>
<p>So, it's the late 1800's. Hilbert's Hotel (and related ideas) have excited the mathematical world. Indeed, can we use this trick to show that <em>every</em> infinite set is the same size? Are all infinities one, in a philosophical sense?</p>
<p>At this time, there was a non-famous but moderately successful mathematician named Georg Cantor. He was in his 40's when he made a groundbreaking discovery---contradicting the conventional wisdom (thanks, Hardy) that young mathematicians do all the interesting work. <strong>Cantor proved that the power set of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>, that is, the set of subsets of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>, must be strictly larger than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</strong></p>
<p>There is pandemonium. There is massive controversy. But, later mathematicians said that his ideas came 100 years before the community was ready for them. Hilbert himself actually said, later, that &quot;No one shall drive us from the paradise Cantor has created for us.&quot;</p>
<p>How did Cantor prove this? By contradiction. Assume you're given a bijection between a set <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> and its power set. Now, this bijection can be thought of as an infinite table, with subsets of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as rows and elements of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as columns. The cells contain booleans: true if the subset contains the element, and false if it doesn't. </p>
<div class="table-wrapper"><table><thead><tr><th>Set</th><th>0</th><th>1</th><th>...</th></tr></thead><tbody>
<tr><td>{}</td><td>N</td><td>N</td><td>...</td></tr>
<tr><td>{0}</td><td>Y</td><td>N</td><td>...</td></tr>
<tr><td>{0, 1}</td><td>Y</td><td>Y</td><td>...</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
</tbody></table>
</div>
<p>Cantor showed that there must <em>always</em> be a subset of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> that <em>isn't</em> represented as a row in the table. That is, such a bijection cannot exist. Even with the very permissive definition of &quot;same size&quot; we use for infinite sets, there are <em>still</em> more subsets of the natural numbers than there are natural numbers.</p>
<p>What is the subset that can't be represented as a row in the table?</p>
<details>
<summary>Think, then click!</summary>
<p>Read off the diagonal from the top-left onward, and invert each boolean. In the table above, the set would contain both 0 and 1 (because those first two rows do not contain them, respectively) and so on.</p>
<p>This technique is called &quot;Cantor diagonalization&quot;. </p>
</details>
<p>Why does this matter to <em>US</em>? Let me ask you two questions:</p>
<p><strong>QUESTION 1</strong>: How many syntactically-valid Java program source files are there?</p>
<details>
<summary>Think, then click!</summary>
<p>There are infinitely many. But let's be more precise. A the source code of a program is a <em>finite</em> text file. The size may be unbounded, but each specific file is finite. And the alphabet used for each character is also finite (let's say between 0 and 255, although that isn't always entirely accurate). </p>
<p>Thus, we can think of a program source file as a finite sequence of numbers between 0 and 255. This is the same as representing a natural number in base 256. There are as many Java program source files as there are natural numbers. </p>
</details>
<p><strong>QUESTION 2</strong>: How many mathematical functions from non-negative integer inputs to <code>bool</code> outputs are there, assuming your language has unbounded integers?</p>
<details>
<summary>Think, then click!</summary>
<p>Each such function returns true or false for any given non-negative integer. In effect, it is defining a specific set of these. There are as many such mathematical functions as there are sets of natural numbers. </p>
</details>
<p>What is our conclusion? </p>
<p>Try as you might, it is impossible to express all functions of these in any programming language where program texts are finite. So we know that programs in any language must be unable to express <em>some</em> things (indeed, most things). But is there anything that <strong>no</strong> language can express? Maybe all the things that are inexpressible are things that nobody actually needs or cares about. That would be comforting.</p>
<p>Unfortunately, there are <em>plenty</em> of important ideas that can't be expressed in any finite program. If you're curious about this, you might investigate CSCI 1010. I'm also happy to talk more about it offline. The following (very rough!) notes are meant to sketch one of the most famous problems in this area.</p>
<h3 id="another-story-outline"><a class="header" href="#another-story-outline">Another Story (OUTLINE)</a></h3>
<p>It's the early 1900's. Hilbert and others: <em>IS MATHEMATICS MECHANIZABLE</em>?</p>
<p>In 30's: Church, Turing, Godel: &quot;No. At least not completely.&quot; </p>
<p>Why? A few reasons. Here's a challenge. Write for me a program <code>h(f, v)</code> that accepts two arguments:</p>
<ul>
<li>another program; and</li>
<li>an input to that program.</li>
</ul>
<p>It must:</p>
<ul>
<li>always terminate; </li>
<li>return true IFF f(v) terminates in finite time;</li>
<li>return false IFF f(v) does not terminate in finite time</li>
</ul>
<p>Suppose <code>h</code> exists, and can be embodied in our language. Then consider this program.</p>
<pre><code>def g(x):
  if h(g, x): # AM I GOING TO HALT? (remember h always terminates)
    while(1); # NUH UH IM NOT!
  else:       
    return;   # HAHAHAHAHA YES I AM
</code></pre>
<p>Argh! Assuming that our halting function h is a program itself: CANNOT EXIST! This is called the &quot;halting problem&quot;.</p>
<p>Exercise: what consequences for us? OK to be philosophical, uncertain.</p>
<p>&quot;Undecidability&quot;</p>
<p><img src="https://i.imgur.com/1VISrAR.png" alt="" /></p>
<h3 id="what-does-this-have-to-do-with-smt"><a class="header" href="#what-does-this-have-to-do-with-smt">What Does This Have To Do With SMT?</a></h3>
<p>Gödel also proved that number theory is undecidable: if you've got the natural numbers, multiplication, and addition, it is impossible to write an algorithm that answers <em>arbitrary</em> questions about number theory in an <em>always correct</em> way, in <em>finite</em> time.</p>
<p>There are also tricks you'll learn in 1010 that let you say &quot;Well, if I could solve arbitrary questions about number theory, then I could turn the halting problem into a question about number theory!&quot;</p>
<p>There's so much more I'd like to talk about, but this lecture is already pretty disorganized, so I'm not going to plan on saying more today.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../chapters/solvers/resolution.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../chapters/solvers/cegis.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../chapters/solvers/resolution.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../chapters/solvers/cegis.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
